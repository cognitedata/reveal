/* eslint-disable no-useless-escape */
import {
  CodeActionEdit,
  CodeActionEditItem,
  CodeActionsOptions,
  CodeEditorRange,
  DiagnosticItem,
  EditorCodeAction,
} from './types';

export class CodeActionsService {
  getCodeActions(
    graphQlCode: string,
    range: CodeEditorRange,
    diagnostics: DiagnosticItem[],
    options: CodeActionsOptions
  ) {
    return diagnostics
      .map((error) => {
        if (this.isUnknownTypePredicate(error.message)) {
          return this.handleMissingType(error, options);
        }
        return null;
      })
      .filter((item) => item);
  }

  private mapMarkerDataToCodeAction(
    title: string,
    edits: CodeActionEditItem[],
    errorMarker: DiagnosticItem
  ): EditorCodeAction {
    return {
      title: title, // Name of quickfix
      diagnostics: [errorMarker],
      kind: 'quickfix',
      edit: {
        edits: edits.map((edit) => ({ edit })),
      },
      isPreferred: true,
    };
  }

  private handleMissingType(
    errorMarker: DiagnosticItem,
    options: CodeActionsOptions
  ) {
    const missingType = errorMarker.message
      .replace(/^Unknown type \"/gm, '')
      .replace(/\".$/gim, '')
      .trim();

    if (!missingType) {
      return null;
    }

    // we need to append this type at the end of the document
    const editRange = {
      startLineNumber: options.lineCount,
      startColumn: options.lastLineLength,
      endLineNumber: options.lineCount,
      endColumn: options.lastLineLength,
    };

    return this.mapMarkerDataToCodeAction(
      'Create missing type',
      [
        {
          range: editRange as CodeEditorRange,
          text: `\n\ntype ${missingType} {\n  _autogeneratedField: String \n}\n`, // text to replace with
        },
      ],
      errorMarker
    );
  }

  private isUnknownTypePredicate(errorMessage: string): boolean {
    const regex = /^Unknown type \"/gm;
    return regex.test(errorMessage);
  }
}
