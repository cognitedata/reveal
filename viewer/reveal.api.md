## API Report File for "@cognite/reveal"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Box3 } from 'three';
import { CogniteClient } from '@cognite/sdk';
import { CogniteInternalId } from '@cognite/sdk';
import { Color } from 'three';
import { EventDispatcher } from 'three';
import { ListResponse } from '@cognite/sdk';
import { Matrix4 } from 'three';
import { Node3D } from '@cognite/sdk';
import { OrthographicCamera } from 'three';
import { PerspectiveCamera } from 'three';
import { Quaternion } from 'three';
import * as THREE_2 from 'three';
import { Vector3 } from 'three';

// @public
export type AbsolutePosition = {
    xAbsolute: number;
    yAbsolute: number;
};

// @public (undocumented)
export type AddImage360Options = {
    collectionTransform?: THREE.Matrix4;
    preMultipliedRotation?: boolean;
};

// @public
export interface AddModelOptions {
    // (undocumented)
    geometryFilter?: GeometryFilter;
    // (undocumented)
    localPath?: string;
    // (undocumented)
    modelId: number;
    // (undocumented)
    revisionId: number;
}

// @public
export class AnnotationIdPointCloudObjectCollection extends PointCloudObjectCollection {
    constructor(ids: Iterable<number>);
    // (undocumented)
    getAnnotationIds(): Iterable<number>;
    // (undocumented)
    get isLoading(): false;
}

// @public
export interface AreaCollection {
    addAreas(boxes: Iterable<THREE.Box3>): void;
    areas(): Generator<THREE.Box3>;
    intersectsBox(box: THREE.Box3): boolean;
    intersectWith(boxes: Iterable<THREE.Box3>): void;
    // (undocumented)
    readonly isEmpty: boolean;
}

// @public
export class AssetNodeCollection extends NodeCollection {
    constructor(client: CogniteClient, modelMetadataProvider: CdfModelNodeCollectionDataProvider);
    // (undocumented)
    static readonly classToken = "AssetNodeCollection";
    // (undocumented)
    clear(): void;
    executeFilter(filter: {
        assetId?: number;
        boundingBox?: THREE_2.Box3;
    }): Promise<void>;
    // (undocumented)
    getAreas(): AreaCollection;
    // (undocumented)
    getFilter(): {
        assetId?: number | undefined;
        boundingBox?: THREE_2.Box3 | undefined;
    } | undefined;
    // (undocumented)
    getIndexSet(): IndexSet;
    // (undocumented)
    get isLoading(): boolean;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @public
export type AxisBoxCompassConfig = {
    ringLabel?: string;
    labelDelta?: number;
    fontSize?: number;
    fontColor?: THREE_2.Color;
    tickColor?: THREE_2.Color;
};

// @public
export type AxisBoxConfig = {
    size?: number;
    position?: AbsolutePosition | RelativePosition;
    animationSpeed?: number;
    faces?: {
        xPositiveFace?: AxisBoxFaceConfig;
        xNegativeFace?: AxisBoxFaceConfig;
        yPositiveFace?: AxisBoxFaceConfig;
        yNegativeFace?: AxisBoxFaceConfig;
        zPositiveFace?: AxisBoxFaceConfig;
        zNegativeFace?: AxisBoxFaceConfig;
    };
    compass?: AxisBoxCompassConfig;
};

// @public
export type AxisBoxFaceConfig = {
    label?: string;
    fontSize?: number;
    fontColor?: THREE_2.Color;
    outlineSize?: number;
    outlineColor?: THREE_2.Color;
    faceColor?: THREE_2.Color;
};

// @public (undocumented)
export class AxisViewTool extends Cognite3DViewerToolBase {
    constructor(viewer: Cognite3DViewer, config?: AxisBoxConfig);
    // (undocumented)
    dispose(): void;
}

// @public
export type BeforeSceneRenderedDelegate = (event: {
    frameNumber: number;
    renderer: THREE.WebGLRenderer;
    camera: THREE.PerspectiveCamera;
}) => void;

// @public (undocumented)
export interface BinaryFileProvider {
    // (undocumented)
    getBinaryFile(baseUrl: string, fileName: string): Promise<ArrayBuffer>;
}

// @public (undocumented)
export interface BlobOutputMetadata {
    // (undocumented)
    blobId: number;
    // (undocumented)
    format: File3dFormat | string;
    // (undocumented)
    version: number;
}

// @public (undocumented)
export class BoundingBoxClipper {
    constructor(box?: THREE_2.Box3);
    // (undocumented)
    get clippingPlanes(): THREE_2.Plane[];
    set maxX(x: number);
    // (undocumented)
    get maxX(): number;
    set maxY(y: number);
    // (undocumented)
    get maxY(): number;
    set maxZ(z: number);
    // (undocumented)
    get maxZ(): number;
    set minX(x: number);
    // (undocumented)
    get minX(): number;
    set minY(y: number);
    // (undocumented)
    get minY(): number;
    set minZ(z: number);
    // (undocumented)
    get minZ(): number;
}

// @public (undocumented)
export type CadIntersection = {
    type: 'cad';
    model: CogniteCadModel;
    point: THREE.Vector3;
    treeIndex: number;
    distanceToCamera: number;
};

// @public
export type CadModelBudget = {
    readonly highDetailProximityThreshold: number;
    readonly maximumRenderCost: number;
};

// @public
export type CameraChangeDelegate = (position: THREE.Vector3, target: THREE.Vector3) => void;

// @public
export type CameraConfiguration = {
    readonly position: THREE.Vector3;
    readonly target: THREE.Vector3;
};

// @public (undocumented)
export type CameraControlsOptions = {
    mouseWheelAction?: 'zoomToTarget' | 'zoomPastCursor' | 'zoomToCursor';
    changeCameraTargetOnClick?: boolean;
};

// @public
export interface CameraManager {
    activate(cameraManager?: CameraManager): void;
    deactivate(): void;
    // (undocumented)
    dispose(): void;
    enabled: boolean;
    fitCameraToBoundingBox(boundingBox: THREE_2.Box3, duration?: number, radiusFactor?: number): void;
    getCamera(): THREE_2.PerspectiveCamera;
    getCameraState(): Required<CameraState>;
    off(event: 'cameraChange', callback: CameraChangeDelegate): void;
    on(event: 'cameraChange', callback: CameraChangeDelegate): void;
    setCameraState(state: CameraState): void;
    update(deltaTime: number, boundingBox: THREE_2.Box3): void;
}

// @public
export class CameraManagerHelper {
    static calculateCameraStateToFitBoundingBox(camera: THREE_2.PerspectiveCamera, box: THREE_2.Box3, radiusFactor?: number): {
        position: THREE_2.Vector3;
        target: THREE_2.Vector3;
    };
    static calculateNewTargetFromRotation(camera: THREE_2.PerspectiveCamera, rotation: THREE_2.Quaternion, currentTarget: THREE_2.Vector3): THREE_2.Vector3;
    static updateCameraNearAndFar(camera: THREE_2.PerspectiveCamera, combinedBbox: THREE_2.Box3): void;
}

// @public (undocumented)
export type CameraState = {
    position?: THREE.Vector3;
    target?: THREE.Vector3;
    rotation?: THREE.Quaternion;
};

// @public
export const CDF_TO_VIEWER_TRANSFORMATION: Matrix4;

// @public
export class CdfModelIdentifier implements ModelIdentifier {
    constructor(modelId: number, revisionId: number);
    // (undocumented)
    readonly modelId: number;
    // (undocumented)
    readonly revealInternalId: symbol;
    // (undocumented)
    readonly revisionId: number;
    // (undocumented)
    toString(): string;
}

// @public
export interface CdfModelNodeCollectionDataProvider {
    getCdfToDefaultModelTransformation(out?: THREE_2.Matrix4): THREE_2.Matrix4;
    getModelTransformation(out?: THREE_2.Matrix4): THREE_2.Matrix4;
    modelId: number;
    nodeCount: number;
    // (undocumented)
    revisionId: number;
}

// @public
export class ClusteredAreaCollection implements AreaCollection {
    // (undocumented)
    addAreas(boxes: Iterable<THREE.Box3>): void;
    // (undocumented)
    areas(): Generator<THREE.Box3>;
    // (undocumented)
    intersectsBox(box: THREE.Box3): boolean;
    // (undocumented)
    intersectWith(boxes: Iterable<THREE.Box3>): void;
    // (undocumented)
    get isEmpty(): boolean;
}

// @public (undocumented)
export class Cognite3DViewer {
    constructor(options: Cognite3DViewerOptions);
    add360ImageSet(datasource: 'events', eventFilter: {
        [key: string]: string;
    }, add360ImageOptions?: AddImage360Options): Promise<Image360Entity[]>;
    addCadModel(options: AddModelOptions): Promise<CogniteCadModel>;
    addModel(options: AddModelOptions): Promise<CogniteModel>;
    addObject3D(object: THREE_2.Object3D): void;
    addPointCloudModel(options: AddModelOptions): Promise<CognitePointCloudModel>;
    get cadBudget(): CadModelBudget;
    set cadBudget(budget: CadModelBudget);
    // (undocumented)
    get cameraManager(): CameraManager;
    get canvas(): HTMLCanvasElement;
    determineModelType(modelId: number, revisionId: number): Promise<SupportedModelTypes | ''>;
    dispose(): void;
    get domElement(): HTMLElement;
    enter360Image(image360: Image360Entity): Promise<void>;
    exit360Image(): void;
    fitCameraToBoundingBox(box: THREE_2.Box3, duration?: number, radiusFactor?: number): void;
    fitCameraToModel(model: CogniteModel, duration?: number): void;
    fitCameraToModels(models?: CogniteModel[], duration?: number, restrictToMostGeometry?: boolean): void;
    getClippingPlanes(): THREE_2.Plane[];
    getIntersectionFromPixel(offsetX: number, offsetY: number): Promise<null | Intersection>;
    getScreenshot(width?: number, height?: number, includeUI?: boolean): Promise<string>;
    getVersion(): string;
    getViewState(): ViewerState;
    loadCameraFromModel(model: CogniteModel): void;
    get models(): CogniteModel[];
    // (undocumented)
    off(event: 'click' | 'hover', callback: PointerEventDelegate): void;
    // (undocumented)
    off(event: 'cameraChange', callback: CameraChangeDelegate): void;
    off(event: 'beforeSceneRendered', callback: BeforeSceneRenderedDelegate): void;
    // (undocumented)
    off(event: 'sceneRendered', callback: SceneRenderedDelegate): void;
    // (undocumented)
    off(event: 'disposed', callback: DisposedDelegate): void;
    on(event: 'disposed', callback: DisposedDelegate): void;
    // (undocumented)
    on(event: 'click' | 'hover', callback: PointerEventDelegate): void;
    // (undocumented)
    on(event: 'cameraChange', callback: CameraChangeDelegate): void;
    on(event: 'beforeSceneRendered', callback: BeforeSceneRenderedDelegate): void;
    on(event: 'sceneRendered', callback: SceneRenderedDelegate): void;
    get pointCloudBudget(): PointCloudBudget;
    set pointCloudBudget(budget: PointCloudBudget);
    remove360Images(...image360Entities: Image360Entity[]): Promise<void>;
    removeModel(model: CogniteModel): void;
    removeObject3D(object: THREE_2.Object3D): void;
    requestRedraw(): void;
    setBackgroundColor(backgroundColor: {
        color?: THREE_2.Color;
        alpha?: number;
    }): void;
    setCameraManager(cameraManager: CameraManager): void;
    setClippingPlanes(clippingPlanes: THREE_2.Plane[]): void;
    setLogLevel(level: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'silent' | 'none'): void;
    setViewState(state: ViewerState): Promise<void>;
    worldToScreen(point: THREE_2.Vector3, normalize?: boolean): THREE_2.Vector2 | null;
}

// @public
export interface Cognite3DViewerOptions {
    antiAliasingHint?: 'disabled' | 'fxaa' | 'msaa2+fxaa' | 'msaa4+fxaa' | 'msaa8+fxaa' | 'msaa16+fxaa' | 'msaa2' | 'msaa4' | 'msaa8' | 'msaa16';
    cameraManager?: CameraManager;
    continuousModelStreaming?: boolean;
    customDataSource?: DataSource;
    domElement?: HTMLElement;
    enableEdges?: boolean;
    loadingIndicatorStyle?: {
        placement: 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';
        opacity: number;
    };
    logMetrics?: boolean;
    onLoading?: OnLoadingCallback;
    pointCloudEffects?: {
        pointBlending?: boolean;
        edlOptions?: Partial<EdlOptions> | 'disabled';
    };
    renderer?: THREE.WebGLRenderer;
    rendererResolutionThreshold?: number;
    renderTargetOptions?: {
        target: THREE.WebGLRenderTarget;
        autoSetSize?: boolean;
    };
    sdk: CogniteClient;
    ssaoQualityHint?: 'medium' | 'high' | 'veryhigh' | 'disabled';
}

// @public
export abstract class Cognite3DViewerToolBase {
    dispose(): void;
    protected ensureNotDisposed(): void;
    off(event: 'disposed', handler: () => void): void;
}

// @public
export class CogniteCadModel implements CdfModelNodeCollectionDataProvider {
    assignStyledNodeCollection(nodeCollection: NodeCollection, appearance: NodeAppearance): void;
    dispose(): void;
    getAncestorTreeIndices(treeIndex: number, generation: number): Promise<NumericRange>;
    getBoundingBoxByNodeId(nodeId: number, box?: THREE_2.Box3): Promise<THREE_2.Box3>;
    getBoundingBoxByTreeIndex(treeIndex: number, box?: THREE_2.Box3): Promise<THREE_2.Box3>;
    getCameraConfiguration(): CameraConfiguration | undefined;
    getCdfToDefaultModelTransformation(out?: THREE_2.Matrix4): THREE_2.Matrix4;
    getDefaultNodeAppearance(): NodeAppearance;
    getModelBoundingBox(outBbox?: THREE_2.Box3, restrictToMostGeometry?: boolean): THREE_2.Box3;
    getModelTransformation(out?: THREE_2.Matrix4): THREE_2.Matrix4;
    getSubtreeTreeIndices(treeIndex: number): Promise<NumericRange>;
    iterateNodesByTreeIndex(action: (treeIndex: number) => void): Promise<void>;
    iterateSubtreeByTreeIndex(treeIndex: number, action: (treeIndex: number) => void): Promise<void>;
    mapNodeIdsToTreeIndices(nodeIds: CogniteInternalId[]): Promise<number[]>;
    mapNodeIdToTreeIndex(nodeId: CogniteInternalId): Promise<number>;
    mapTreeIndexToNodeId(treeIndex: number): Promise<CogniteInternalId>;
    mapTreeIndicesToNodeIds(treeIndices: number[]): Promise<CogniteInternalId[]>;
    readonly modelId: number;
    get modelUnit(): WellKnownUnit | '';
    get modelUnitToMetersFactor(): number | undefined;
    get nodeCount(): number;
    removeAllStyledNodeCollections(): void;
    resetNodeTransform(treeIndices: NumericRange): void;
    resetNodeTransformByTreeIndex(treeIndex: number, applyToChildren?: boolean): Promise<number>;
    readonly revisionId: number;
    setDefaultNodeAppearance(appearance: NodeAppearance): void;
    setModelTransformation(matrix: THREE_2.Matrix4): void;
    setNodeTransform(treeIndices: NumericRange, transformMatrix: THREE_2.Matrix4): void;
    setNodeTransformByTreeIndex(treeIndex: number, transform: THREE_2.Matrix4, applyToChildren?: boolean): Promise<number>;
    get styledNodeCollections(): {
        nodeCollection: NodeCollection;
        appearance: NodeAppearance;
    }[];
    // (undocumented)
    readonly type: SupportedModelTypes;
    unassignStyledNodeCollection(nodeCollection: NodeCollection): void;
    set visible(value: boolean);
    get visible(): boolean;
}

// @public
export type CogniteModel = CogniteCadModel | CognitePointCloudModel;

// @public
export class CognitePointCloudModel {
    assignStyledObjectCollection(objectCollection: PointCloudObjectCollection, appearance: PointCloudAppearance): void;
    dispose(): void;
    getCameraConfiguration(): CameraConfiguration | undefined;
    getCdfToDefaultModelTransformation(out?: THREE_2.Matrix4): THREE_2.Matrix4;
    getClasses(): Array<{
        name: string;
        code: number | WellKnownAsprsPointClassCodes;
    }>;
    getDefaultPointCloudAppearance(): PointCloudAppearance;
    // (undocumented)
    getModelBoundingBox(outBbox?: THREE_2.Box3): THREE_2.Box3;
    getModelTransformation(out?: THREE_2.Matrix4): THREE_2.Matrix4;
    hasClass(pointClass: number | WellKnownAsprsPointClassCodes): boolean;
    isClassVisible(pointClass: number | WellKnownAsprsPointClassCodes): boolean;
    // (undocumented)
    readonly modelId: number;
    get pointColorType(): PointColorType;
    set pointColorType(type: PointColorType);
    get pointShape(): PointShape;
    set pointShape(shape: PointShape);
    get pointSize(): number;
    set pointSize(size: number);
    get pointSizeType(): PointSizeType;
    set pointSizeType(type: PointSizeType);
    removeAllStyledObjectCollections(): void;
    readonly revisionId: number;
    setClassVisible(pointClass: number | WellKnownAsprsPointClassCodes, visible: boolean): void;
    setDefaultPointCloudAppearance(appearance: PointCloudAppearance): void;
    setModelTransformation(transformationMatrix: THREE_2.Matrix4): void;
    // (undocumented)
    get stylableObjectCount(): number;
    get styledCollections(): StyledPointCloudObjectCollection[];
    traverseStylableObjects(callback: (annotationMetadata: PointCloudObjectMetadata) => void): void;
    // (undocumented)
    readonly type: SupportedModelTypes;
    unassignStyledObjectCollection(objectCollection: PointCloudObjectCollection): void;
    get visiblePointCount(): number;
}

// @public (undocumented)
export class ComboControls extends EventDispatcher {
    constructor(camera: PerspectiveCamera | OrthographicCamera, domElement: HTMLElement);
    get cameraRawRotation(): Quaternion;
    // (undocumented)
    dampingFactor: number;
    // (undocumented)
    dispose: () => void;
    // (undocumented)
    dollyFactor: number;
    // (undocumented)
    dynamicTarget: boolean;
    // (undocumented)
    enabled: boolean;
    // (undocumented)
    enableDamping: boolean;
    // (undocumented)
    enableKeyboardNavigation: boolean;
    // (undocumented)
    EPSILON: number;
    // (undocumented)
    firstPersonRotationFactor: number;
    // (undocumented)
    getScrollTarget: () => Vector3;
    // (undocumented)
    getState: () => {
        target: Vector3;
        position: Vector3;
    };
    // (undocumented)
    keyboardDollySpeed: number;
    // (undocumented)
    keyboardPanSpeed: number;
    // (undocumented)
    keyboardRotationSpeedAzimuth: number;
    // (undocumented)
    keyboardRotationSpeedPolar: number;
    // (undocumented)
    keyboardSpeedFactor: number;
    // (undocumented)
    lookAtViewTarget: boolean;
    // (undocumented)
    maxAzimuthAngle: number;
    // (undocumented)
    maxDeltaDownscaleCoefficient: number;
    // (undocumented)
    maxDeltaRatio: number;
    // (undocumented)
    maxPolarAngle: number;
    // (undocumented)
    maxZoom: number;
    // (undocumented)
    minAzimuthAngle: number;
    // (undocumented)
    minDeltaDownscaleCoefficient: number;
    // (undocumented)
    minDeltaRatio: number;
    // (undocumented)
    minDistance: number;
    // (undocumented)
    minPolarAngle: number;
    // (undocumented)
    minZoom: number;
    // (undocumented)
    minZoomDistance: number;
    // (undocumented)
    mouseFirstPersonRotationSpeed: number;
    // (undocumented)
    orthographicCameraDollyFactor: number;
    // (undocumented)
    panDollyMinDistanceFactor: number;
    // (undocumented)
    pinchEpsilon: number;
    // (undocumented)
    pinchPanSpeed: number;
    // (undocumented)
    pointerRotationSpeedAzimuth: number;
    // (undocumented)
    pointerRotationSpeedPolar: number;
    // (undocumented)
    setScrollTarget: (target: Vector3) => void;
    // (undocumented)
    setState: (position: Vector3, target: Vector3) => void;
    // (undocumented)
    setViewTarget: (target: Vector3) => void;
    // (undocumented)
    triggerCameraChangeEvent: () => void;
    // (undocumented)
    update: (deltaTime: number, forceUpdate?: boolean) => boolean;
    // (undocumented)
    useScrollTarget: boolean;
    // (undocumented)
    zoomToCursor: boolean;
}

// @public (undocumented)
export type CompletePointCloudAppearance = Required<PointCloudAppearance>;

// @public
export enum Corner {
    // (undocumented)
    BottomLeft = 2,
    // (undocumented)
    BottomRight = 3,
    // (undocumented)
    TopLeft = 1,
    // (undocumented)
    TopRight = 0
}

// @public
export interface DataSource {
    getModelDataProvider(): ModelDataProvider;
    getModelMetadataProvider(): ModelMetadataProvider;
    getNodesApiClient(): NodesApiClient;
}

// @public (undocumented)
export class DebugCameraTool extends Cognite3DViewerToolBase {
    constructor(viewer: Cognite3DViewer);
    // @override
    dispose(): void;
    // (undocumented)
    hideCameraHelper(): void;
    // (undocumented)
    showCameraHelper(): void;
}

// @public
export class DefaultCameraManager implements CameraManager {
    // (undocumented)
    activate(cameraManager?: CameraManager): void;
    automaticControlsSensitivity: boolean;
    automaticNearFarPlane: boolean;
    // @deprecated
    get cameraControls(): ComboControls;
    // (undocumented)
    deactivate(): void;
    // (undocumented)
    dispose(): void;
    get enabled(): boolean;
    // (undocumented)
    fitCameraToBoundingBox(box: THREE_2.Box3, duration?: number, radiusFactor?: number): void;
    // (undocumented)
    getCamera(): THREE_2.PerspectiveCamera;
    getCameraControlsOptions(): CameraControlsOptions;
    // (undocumented)
    getCameraState(): Required<CameraState>;
    set keyboardNavigationEnabled(enabled: boolean);
    get keyboardNavigationEnabled(): boolean;
    // (undocumented)
    off(event: 'cameraChange', callback: CameraChangeDelegate): void;
    // (undocumented)
    on(event: 'cameraChange', callback: CameraChangeDelegate): void;
    setCameraControlsOptions(controlsOptions: CameraControlsOptions): void;
    setCameraState(state: CameraState): void;
    // (undocumented)
    update(deltaTime: number, boundingBox: THREE_2.Box3): void;
}

// @public
export const DefaultNodeAppearance: {
    Default: NodeAppearance;
    Outlined: NodeAppearance;
    Hidden: NodeAppearance;
    InFront: NodeAppearance;
    Ghosted: NodeAppearance;
    Highlighted: {
        color?: Color | undefined;
        visible?: boolean | undefined;
        renderInFront?: boolean | undefined;
        renderGhosted?: boolean | undefined;
        outlineColor?: NodeOutlineColor | undefined;
        prioritizedForLoadingHint?: number | undefined;
    };
};

// @public (undocumented)
export const DefaultPointCloudAppearance: CompletePointCloudAppearance;

// @public
export type DisposedDelegate = () => void;

// @public (undocumented)
export enum File3dFormat {
    // (undocumented)
    AnyFormat = "all-outputs",
    // (undocumented)
    EptPointCloud = "ept-pointcloud",
    GltfCadModel = "gltf-directory"
}

// @public (undocumented)
export type GeometryFilter = {
    boundingBox?: THREE.Box3;
    isBoundingBoxInModelCoordinates?: boolean;
};

// @public
export type HtmlOverlayCreateClusterDelegate = (overlayElements: {
    htmlElement: HTMLElement;
    userData: any;
}[]) => HTMLElement;

// @public
export type HtmlOverlayOptions = {
    positionUpdatedCallback?: HtmlOverlayPositionUpdatedDelegate;
    userData?: any;
};

// @public
export type HtmlOverlayPositionUpdatedDelegate = (element: HTMLElement, position2D: THREE_2.Vector2, position3D: THREE_2.Vector3, distanceToCamera: number, userData: any) => void;

// @public
export class HtmlOverlayTool extends Cognite3DViewerToolBase {
    // Warning: (ae-forgotten-export) The symbol "HtmlOverlayToolOptions" needs to be exported by the entry point index.d.ts
    constructor(viewer: Cognite3DViewer, options?: HtmlOverlayToolOptions);
    add(htmlElement: HTMLElement, position3D: THREE_2.Vector3, options?: HtmlOverlayOptions): void;
    clear(): void;
    // @override
    dispose(): void;
    get elements(): {
        element: HTMLElement;
        position3D: THREE_2.Vector3;
    }[];
    forceUpdate(customCamera?: THREE_2.PerspectiveCamera): void;
    remove(htmlElement: HTMLElement): void;
    visible(enable: boolean): void;
}

// @public (undocumented)
export class Image360Entity {
    // Warning: (ae-forgotten-export) The symbol "Image360Descriptor" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "SceneHandler" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "Image360FileProvider" needs to be exported by the entry point index.d.ts
    constructor(image360Metadata: Image360Descriptor, sceneHandler: SceneHandler, imageProvider: Image360FileProvider, postTransform: THREE_2.Matrix4, preComputedRotation: boolean);
    // (undocumented)
    dispose(): void;
    // Warning: (ae-forgotten-export) The symbol "Image360Icon" needs to be exported by the entry point index.d.ts
    get icon(): Image360Icon;
    get image360Visualization(): Image360Visualization;
    load360Image(): Promise<void>;
    get transform(): THREE_2.Matrix4;
    unload360Image(): void;
}

// @public (undocumented)
export interface Image360Visualization {
    opacity: number;
    renderOrder: number;
    scale: THREE_2.Vector3;
    visible: boolean;
}

// @public (undocumented)
export class IndexSet {
    constructor(values?: Iterable<number>);
    constructor(values?: NumericRange);
    // (undocumented)
    add(index: number): void;
    // (undocumented)
    addRange(range: NumericRange): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    clone(): IndexSet;
    // (undocumented)
    contains(index: number): boolean;
    // (undocumented)
    get count(): number;
    // (undocumented)
    differenceWith(otherSet: IndexSet): IndexSet;
    // (undocumented)
    forEachRange(visitor: (range: NumericRange) => void): void;
    // (undocumented)
    hasIntersectionWith(otherSet: IndexSet | Map<number, number> | Set<number>): boolean;
    // (undocumented)
    intersectWith(otherSet: IndexSet): IndexSet;
    // (undocumented)
    invertedRanges(): NumericRange[];
    // (undocumented)
    remove(index: number): void;
    // (undocumented)
    removeRange(range: NumericRange): void;
    // Warning: (ae-forgotten-export) The symbol "IndexNode" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    rootNode?: IndexNode;
    // (undocumented)
    toIndexArray(): number[];
    // (undocumented)
    toPlainSet(): Set<number>;
    // (undocumented)
    toRangeArray(): NumericRange[];
    // (undocumented)
    unionWith(otherSet: IndexSet): IndexSet;
}

// Warning: (ae-forgotten-export) The symbol "PointCloudIntersection" needs to be exported by the entry point index.d.ts
//
// @public
export type Intersection = CadIntersection | PointCloudIntersection;

// Warning: (ae-forgotten-export) The symbol "CombineNodeCollectionBase" needs to be exported by the entry point index.d.ts
//
// @public
export class IntersectionNodeCollection extends CombineNodeCollectionBase {
    constructor(nodeCollections?: NodeCollection[]);
    // (undocumented)
    static readonly classToken = "IntersectionNodeCollection";
    // (undocumented)
    protected createCombinedIndexSet(): IndexSet;
    // (undocumented)
    getAreas(): AreaCollection;
    // (undocumented)
    makeDirty(): void;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @public
export class InvertedNodeCollection extends NodeCollection {
    constructor(model: CdfModelNodeCollectionDataProvider, innerSet: NodeCollection);
    // (undocumented)
    static readonly classToken = "InvertedNodeCollection";
    clear(): never;
    // (undocumented)
    getAreas(): AreaCollection;
    // (undocumented)
    getIndexSet(): IndexSet;
    // (undocumented)
    get isLoading(): boolean;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @public (undocumented)
export interface JsonFileProvider {
    // (undocumented)
    getJsonFile(baseUrl: string, fileName: string): Promise<any>;
}

// @public
class Keyframe_2 {
    constructor(model: CogniteCadModel, date: Date);
    activate(): void;
    assignStyledNodeCollection(nodeCollection: NodeCollection, nodeAppearance: NodeAppearance): void;
    deactivate(): void;
    getKeyframeDate(): Date;
    unassignStyledNodeCollection(nodeCollection: NodeCollection): void;
}
export { Keyframe_2 as Keyframe }

// Warning: (ae-forgotten-export) The symbol "LoadingState" needs to be exported by the entry point index.d.ts
//
// @public
export type LoadingStateChangeListener = (loadingState: LoadingState) => any;

// @public (undocumented)
export type Measurement = {
    readonly measurementId: number;
    readonly startPoint: THREE_2.Vector3;
    readonly endPoint: THREE_2.Vector3;
    readonly distanceInMeters: number;
};

// @public
export type MeasurementAddedDelegate = (event: {
    measurementId: number;
    startPoint: THREE.Vector3;
    endPoint: THREE.Vector3;
    distanceInMeters: number;
}) => void;

// @public
export type MeasurementEndedDelegate = () => void;

// @public
export type MeasurementOptions = {
    distanceToLabelCallback?: DistanceToLabelDelegate | undefined;
    lineWidth?: number;
    color?: THREE.Color;
};

// @public
export type MeasurementStartedDelegate = () => void;

// @public
export class MeasurementTool extends Cognite3DViewerToolBase {
    constructor(viewer: Cognite3DViewer, options?: MeasurementOptions);
    dispose(): void;
    enterMeasurementMode(): void;
    exitMeasurementMode(): void;
    getAllMeasurements(): Measurement[];
    get isInMeasurementMode(): boolean;
    // (undocumented)
    off(event: 'disposed', callback: DisposedDelegate): void;
    // (undocumented)
    off(event: 'added', callback: MeasurementAddedDelegate): void;
    // (undocumented)
    off(event: 'started', callback: MeasurementStartedDelegate): void;
    // (undocumented)
    off(event: 'ended', callback: MeasurementEndedDelegate): void;
    on(event: 'disposed', callback: DisposedDelegate): void;
    on(event: 'added', callback: MeasurementAddedDelegate): void;
    on(event: 'started', callback: MeasurementStartedDelegate): void;
    on(event: 'ended', callback: MeasurementEndedDelegate): void;
    removeAllMeasurements(): void;
    removeMeasurement(measurement: Measurement): void;
    setLineOptions(options: MeasurementOptions): void;
    setMeasurementLabelsVisible(enable: boolean): void;
    updateLineColor(measurement: Measurement, color: THREE_2.Color): void;
    updateLineWidth(measurement: Measurement, lineWidth: number): void;
    visible(enable: boolean): void;
}

// @public
export interface ModelDataProvider extends JsonFileProvider, BinaryFileProvider {
    getBinaryFile(baseUrl: string, fileName: string): Promise<ArrayBuffer>;
    getJsonFile(baseUrl: string, fileName: string): Promise<any>;
}

// @public
export interface ModelIdentifier {
    readonly revealInternalId: symbol;
}

// @public
export interface ModelMetadataProvider {
    // (undocumented)
    getModelCamera(identifier: ModelIdentifier): Promise<{
        position: THREE_2.Vector3;
        target: THREE_2.Vector3;
    } | undefined>;
    // (undocumented)
    getModelMatrix(identifier: ModelIdentifier, format: File3dFormat | string): Promise<THREE_2.Matrix4>;
    // (undocumented)
    getModelOutputs(modelIdentifier: ModelIdentifier): Promise<BlobOutputMetadata[]>;
    // (undocumented)
    getModelUri(identifier: ModelIdentifier, formatMetadata: BlobOutputMetadata): Promise<string>;
}

// @public (undocumented)
export type ModelState = {
    defaultNodeAppearance: SerializableNodeAppearance;
    modelId: number;
    revisionId: number;
    styledSets: {
        token: string;
        state: any;
        options?: any;
        appearance: SerializableNodeAppearance;
    }[];
};

// @public
export type NodeAppearance = {
    readonly color?: Color;
    readonly visible?: boolean;
    readonly renderInFront?: boolean;
    readonly renderGhosted?: boolean;
    readonly outlineColor?: NodeOutlineColor;
    readonly prioritizedForLoadingHint?: number;
};

// @public (undocumented)
export class NodeAppearanceProvider {
    // Warning: (ae-forgotten-export) The symbol "ApplyStyleDelegate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    applyStyles(applyCb: ApplyStyleDelegate): void;
    // (undocumented)
    assignStyledNodeCollection(nodeCollection: NodeCollection, appearance: NodeAppearance): void;
    // (undocumented)
    clear(): void;
    // Warning: (ae-forgotten-export) The symbol "PrioritizedArea" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getPrioritizedAreas(): PrioritizedArea[];
    // (undocumented)
    get isLoading(): boolean;
    // (undocumented)
    off(event: 'changed', listener: () => void): void;
    // (undocumented)
    off(event: 'loadingStateChanged', listener: (isLoading: boolean) => void): void;
    // (undocumented)
    on(event: 'changed', listener: () => void): void;
    // (undocumented)
    on(event: 'loadingStateChanged', listener: (isLoading: boolean) => void): void;
    // (undocumented)
    on(event: 'prioritizedAreasChanged', listener: () => void): void;
    // (undocumented)
    unassignStyledNodeCollection(nodeCollection: NodeCollection): void;
}

// @public
export abstract class NodeCollection {
    protected constructor(classToken: string);
    // (undocumented)
    get classToken(): string;
    // (undocumented)
    abstract clear(): void;
    abstract getAreas(): AreaCollection;
    // (undocumented)
    abstract getIndexSet(): IndexSet;
    // (undocumented)
    abstract get isLoading(): boolean;
    protected notifyChanged(): void;
    // (undocumented)
    off(event: 'changed', listener: () => void): void;
    // (undocumented)
    on(event: 'changed', listener: () => void): void;
    // (undocumented)
    abstract serialize(): SerializedNodeCollection;
}

// @public (undocumented)
export type NodeCollectionSerializationContext = {
    client: CogniteClient;
    model: CdfModelNodeCollectionDataProvider;
};

// Warning: (ae-forgotten-export) The symbol "CdfNodeCollectionBase" needs to be exported by the entry point index.d.ts
//
// @public
export class NodeIdNodeCollection extends CdfNodeCollectionBase {
    constructor(client: CogniteClient, model: CdfModelNodeCollectionDataProvider);
    // (undocumented)
    static readonly classToken = "NodeIdNodeCollection";
    // (undocumented)
    static deserialize(descriptor: SerializedNodeCollection, context: NodeCollectionSerializationContext): Promise<NodeIdNodeCollection>;
    executeFilter(nodeIds: number[]): Promise<void>;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @public (undocumented)
export enum NodeOutlineColor {
    // (undocumented)
    Black = 2,
    // (undocumented)
    Blue = 4,
    // (undocumented)
    Cyan = 3,
    // (undocumented)
    Green = 5,
    // (undocumented)
    NoOutline = 0,
    // (undocumented)
    Orange = 7,
    // (undocumented)
    Red = 6,
    // (undocumented)
    White = 1
}

// @public
export interface NodesApiClient {
    determineNodeAncestorsByNodeId(modelId: CogniteInternalId, revisionId: CogniteInternalId, nodeId: CogniteInternalId, generation: number): Promise<{
        treeIndex: number;
        subtreeSize: number;
    }>;
    determineTreeIndexAndSubtreeSizesByNodeIds(modelId: CogniteInternalId, revisionId: CogniteInternalId, nodeIds: CogniteInternalId[]): Promise<{
        treeIndex: number;
        subtreeSize: number;
    }[]>;
    getBoundingBoxesByNodeIds(modelId: CogniteInternalId, revisionId: CogniteInternalId, nodeIds: CogniteInternalId[]): Promise<THREE_2.Box3[]>;
    mapNodeIdsToTreeIndices(modelId: CogniteInternalId, revisionId: CogniteInternalId, nodeIds: CogniteInternalId[]): Promise<number[]>;
    mapTreeIndicesToNodeIds(modelId: CogniteInternalId, revisionId: CogniteInternalId, treeIndices: number[]): Promise<CogniteInternalId[]>;
}

// @public (undocumented)
export class NumericRange {
    constructor(from: number, count: number);
    // (undocumented)
    contains(value: number): boolean;
    // (undocumented)
    readonly count: number;
    // (undocumented)
    static createFromInterval(from: number, toInclusive: number): NumericRange;
    // (undocumented)
    equal(other: NumericRange): boolean;
    // (undocumented)
    forEach(action: (value: number) => void): void;
    // (undocumented)
    readonly from: number;
    // (undocumented)
    intersectionWith(range: NumericRange): NumericRange | undefined;
    // (undocumented)
    intersects(range: NumericRange): boolean;
    // (undocumented)
    intersectsOrCoinciding(range: NumericRange): boolean;
    // (undocumented)
    isInside(range: NumericRange): boolean;
    // (undocumented)
    static isNumericRange(value: any): value is NumericRange;
    // (undocumented)
    toArray(): number[];
    // (undocumented)
    readonly toInclusive: number;
    // (undocumented)
    toString(): string;
    // (undocumented)
    union(range: NumericRange): NumericRange;
    // (undocumented)
    values(): Generator<number>;
}

// @public
export type OnLoadingCallback = (itemsLoaded: number, itemsRequested: number, itemsCulled: number) => void;

// @public (undocumented)
export type PointCloudAppearance = {
    color?: Color;
    visible?: boolean;
};

// @public
export type PointCloudBudget = {
    readonly numberOfPoints: number;
};

// @public
export abstract class PointCloudObjectCollection {
    // (undocumented)
    abstract getAnnotationIds(): Iterable<number>;
    // (undocumented)
    abstract get isLoading(): boolean;
    protected notifyChanged(): void;
    // (undocumented)
    off(event: 'changed', listener: () => void): void;
    // (undocumented)
    on(event: 'changed', listener: () => void): void;
}

// @public (undocumented)
export type PointCloudObjectMetadata = {
    annotationId: number;
    assetId?: number;
    boundingBox: Box3;
};

// @public (undocumented)
export enum PointColorType {
    // (undocumented)
    Classification = 8,
    // (undocumented)
    Depth = 2,
    // (undocumented)
    Elevation = 3,
    // (undocumented)
    Height = 3,
    // (undocumented)
    Intensity = 4,
    // (undocumented)
    LevelOfDetail = 6,
    // (undocumented)
    Lod = 6,
    // (undocumented)
    PointIndex = 7,
    // (undocumented)
    Rgb = 0
}

// Warning: (ae-forgotten-export) The symbol "PointerEventData" needs to be exported by the entry point index.d.ts
//
// @public
export type PointerEventDelegate = (event: PointerEventData) => void;

// @public (undocumented)
export enum PointShape {
    // (undocumented)
    Circle = 1,
    // (undocumented)
    Paraboloid = 2,
    // (undocumented)
    Square = 0
}

// @public (undocumented)
export enum PointSizeType {
    // (undocumented)
    Adaptive = 2,
    // (undocumented)
    Attenuated = 1,
    // (undocumented)
    Fixed = 0
}

// @public
export class PropertyFilterNodeCollection extends CdfNodeCollectionBase {
    // Warning: (ae-forgotten-export) The symbol "PropertyFilterNodeCollectionOptions" needs to be exported by the entry point index.d.ts
    constructor(client: CogniteClient, model: CdfModelNodeCollectionDataProvider, options?: PropertyFilterNodeCollectionOptions);
    // (undocumented)
    static readonly classToken = "PropertyFilterNodeCollection";
    executeFilter(filter: {
        [category: string]: {
            [key: string]: string;
        };
    }): Promise<void>;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @public (undocumented)
export function registerNodeCollectionType<T extends NodeCollection>(nodeCollectionTypeName: string, deserializer: (descriptor: SerializedNodeCollection, context: NodeCollectionSerializationContext) => Promise<T>): void;

// @public
export type RelativePosition = {
    corner: Corner;
    padding: THREE_2.Vector2;
};

// @public (undocumented)
export const REVEAL_VERSION: string;

// @public
export type RevealOptions = {
    logMetrics?: boolean;
    renderOptions?: RenderOptions;
    continuousModelStreaming?: boolean;
    outputRenderTarget?: {
        target: THREE_2.WebGLRenderTarget;
        autoSize?: boolean;
    };
    rendererResolutionThreshold?: number;
    internal?: {
        cad?: InternalRevealCadOptions;
    };
};

// @public
export type SceneRenderedDelegate = (event: {
    frameNumber: number;
    renderTime: number;
    renderer: THREE.WebGLRenderer;
    camera: THREE.PerspectiveCamera;
}) => void;

// @public
export type SerializableNodeAppearance = {
    readonly color?: [number, number, number];
    readonly visible?: boolean;
    readonly renderInFront?: boolean;
    readonly renderGhosted?: boolean;
    readonly outlineColor?: NodeOutlineColor;
    readonly prioritizedForLoadingHint?: number;
};

// @public (undocumented)
export type SerializedNodeCollection = {
    token: string;
    state: any;
    options?: any;
};

// @public
export class SinglePropertyFilterNodeCollection extends CdfNodeCollectionBase {
    constructor(client: CogniteClient, model: CdfModelNodeCollectionDataProvider, options?: PropertyFilterNodeCollectionOptions);
    // (undocumented)
    static readonly classToken = "SinglePropertyNodeCollection";
    executeFilter(propertyCategory: string, propertyKey: string, propertyValues: string[]): Promise<void>;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @public
export class StyledPointCloudObjectCollection {
    constructor(objectCollection: PointCloudObjectCollection, style: CompletePointCloudAppearance);
    // (undocumented)
    objectCollection: PointCloudObjectCollection;
    // (undocumented)
    style: CompletePointCloudAppearance;
}

// @public (undocumented)
export type SupportedModelTypes = 'pointcloud' | 'cad';

// @public
export type TimelineDateUpdateDelegate = (event: {
    date: Date;
    activeKeyframe: Keyframe_2 | undefined;
    startDate: Date;
    endDate: Date;
}) => void;

// @public
export class TimelineTool extends Cognite3DViewerToolBase {
    constructor(cadModel: CogniteCadModel);
    createKeyframe(date: Date): Keyframe_2;
    // (undocumented)
    dispose(): void;
    getAllKeyframes(): Keyframe_2[];
    getKeyframeByDate(date: Date): Keyframe_2 | undefined;
    pause(): void;
    play(startDate: Date, endDate: Date, totalDurationInMilliSeconds: number): void;
    removeKeyframe(keyframe: Keyframe_2): void;
    removeKeyframeByDate(date: Date): void;
    resume(): void;
    stop(): void;
    subscribe(event: 'dateChanged', listener: TimelineDateUpdateDelegate): void;
    unsubscribe(event: 'dateChanged', listener: TimelineDateUpdateDelegate): void;
}

// @public
export class TreeIndexNodeCollection extends NodeCollection {
    constructor(treeIndexSet?: IndexSet);
    constructor(treeIndices?: Iterable<number>);
    constructor(treeIndexRange?: NumericRange);
    addAreaPoints(points: THREE_2.Vector3[]): void;
    addAreas(areas: THREE_2.Box3[]): void;
    // (undocumented)
    static readonly classToken = "TreeIndexNodeCollection";
    clear(): void;
    // (undocumented)
    clearAreas(): void;
    // (undocumented)
    getAreas(): AreaCollection;
    // (undocumented)
    getIndexSet(): IndexSet;
    // (undocumented)
    get isLoading(): boolean;
    // (undocumented)
    serialize(): SerializedNodeCollection;
    // (undocumented)
    updateSet(treeIndices: IndexSet): void;
    // (undocumented)
    updateSet(treeIndices: NumericRange): void;
    // (undocumented)
    updateSet(treeIndices: Iterable<number>): void;
}

// @public
export class UnionNodeCollection extends CombineNodeCollectionBase {
    constructor(nodeCollections?: NodeCollection[]);
    // (undocumented)
    static readonly classToken = "UnionNodeCollection";
    // (undocumented)
    protected createCombinedIndexSet(): IndexSet;
    // (undocumented)
    getAreas(): AreaCollection;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @public (undocumented)
export type ViewerState = {
    camera?: {
        position: {
            x: number;
            y: number;
            z: number;
        };
        target: {
            x: number;
            y: number;
            z: number;
        };
    };
    models?: ModelState[];
    clippingPlanes?: ClippingPlanesState[];
};

// @public
export enum WellKnownAsprsPointClassCodes {
    BridgeDeck = 17,
    // (undocumented)
    Building = 6,
    Created = 0,
    Default = -1,
    // (undocumented)
    Ground = 2,
    HighNoise = 18,
    // (undocumented)
    HighVegetation = 5,
    IgnoredGround = 20,
    LowPoint = 7,
    // (undocumented)
    LowVegetation = 3,
    // (undocumented)
    MedVegetation = 4,
    OverheadStructure = 19,
    // (undocumented)
    Rail = 10,
    ReservedOrBridgeDeck = 12,
    ReservedOrHighPoint = 8,
    // (undocumented)
    RoadSurface = 11,
    // (undocumented)
    Snow = 21,
    TemporalExclusion = 22,
    // (undocumented)
    TransmissionTower = 15,
    // (undocumented)
    Unclassified = 1,
    UserDefinableOffset = 64,
    // (undocumented)
    Water = 9,
    WireConductor = 14,
    WireGuard = 13,
    WireStructureConnector = 16
}

// @public
export type WellKnownUnit = 'Meters' | 'Centimeters' | 'Millimeters' | 'Micrometers' | 'Kilometers' | 'Feet' | 'Inches' | 'Yards' | 'Miles' | 'Mils' | 'Microinches';

// Warnings were encountered during analysis:
//
// dist/packages/api/src/public/migration/types.d.ts:108:9 - (ae-forgotten-export) The symbol "EdlOptions" needs to be exported by the entry point index.d.ts
// dist/packages/api/src/public/types.d.ts:17:5 - (ae-forgotten-export) The symbol "RenderOptions" needs to be exported by the entry point index.d.ts
// dist/packages/api/src/public/types.d.ts:25:9 - (ae-forgotten-export) The symbol "InternalRevealCadOptions" needs to be exported by the entry point index.d.ts
// dist/packages/api/src/utilities/ViewStateHelper.d.ts:18:5 - (ae-forgotten-export) The symbol "ClippingPlanesState" needs to be exported by the entry point index.d.ts
// dist/packages/tools/src/Measurement/types.d.ts:29:5 - (ae-forgotten-export) The symbol "DistanceToLabelDelegate" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
