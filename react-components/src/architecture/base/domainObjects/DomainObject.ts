import { Color, type ColorRepresentation } from 'three';
import { BLACK_COLOR, WHITE_COLOR } from '../utilities/colors/colorUtils';
import { type RenderStyle } from '../renderStyles/RenderStyle';
import { DomainObjectChange } from '../domainObjectsHelpers/DomainObjectChange';
import { Changes } from '../domainObjectsHelpers/Changes';
import { isInstanceOf, type Class } from '../domainObjectsHelpers/Class';
import { VisibleState } from '../domainObjectsHelpers/VisibleState';
import { clear, remove, removeAt } from '../utilities/extensions/arrayUtils';
import { getNextColor } from '../utilities/colors/getNextColor';
import { type RevealRenderTarget } from '../renderTarget/RevealRenderTarget';
import { ColorType } from '../domainObjectsHelpers/ColorType';
import { Views } from '../domainObjectsHelpers/Views';
import { type PanelInfo } from '../domainObjectsHelpers/PanelInfo';
import { PopupStyle } from '../domainObjectsHelpers/PopupStyle';
import { isTranslatedString, type TranslationInput } from '../utilities/translation/TranslateInput';
import { DeleteDomainObjectCommand } from '../concreteCommands/general/DeleteDomainObjectCommand';
import { CopyToClipboardCommand } from '../concreteCommands/general/CopyToClipboardCommand';
import { type BaseCommand } from '../commands/BaseCommand';
import { type Transaction } from '../undo/Transaction';
import { type IconName } from '../../base/utilities/types';
import { CycleLengthUnitsCommand } from '../concreteCommands/units/CycleLengthUnitsCommand';
import { ChangedDescription } from '../domainObjectsHelpers/ChangedDescription';
import {
  CheckboxState,
  type IconColor,
  type ILazyLoader,
  type TreeNodeAction,
  type TreeNodeType
} from '../../../advanced-tree-view';
import { getRenderTarget } from './getRoot';
import { translate } from '../utilities/translation/translateUtils';
import { effect } from '@cognite/signals';
import { generateUniqueId, type UniqueId } from '../utilities/types';

/**
 * Represents an abstract base class for domain objects.
 * @abstract
 */
export abstract class DomainObject implements TreeNodeType {
  // ==================================================
  // INSTANCE FIELDS
  // ==================================================

  // Some basic states
  private _name: string | undefined = undefined; // This is the name that the user can set, if undefined it is autogenerated
  private _color: Color | undefined; // Initial undefined, but created when needed

  // Selection. This is used for selection in 3D viewer. Selection in a tree view is
  // not implemented yet, but should be added in the future.
  private _isSelected: boolean = false;

  // Maximum one active object for each type of domain object. Works as a long term selection
  // For instance you can have many crop boxes, but only one can be used at the time.
  private _isActive: boolean = false;

  // Expand when it is shown in a tree view
  private _isExpanded = false;

  // Parent-Child relationship
  private readonly _children: DomainObject[] = [];
  private _parent: DomainObject | undefined = undefined;

  // Render style
  private _renderStyle: RenderStyle | undefined = undefined;

  // Views and listeners
  public readonly views: Views = new Views();
  private readonly _disposables: Array<() => void> = [];

  public get disposableCount(): number {
    return this._disposables.length;
  }

  // Unique guid for the domain object, used as soft reference
  private _uniqueId: UniqueId;

  public get uniqueId(): UniqueId {
    return this._uniqueId;
  }

  public set uniqueId(value: UniqueId) {
    this._uniqueId = value;
  }

  // ==================================================
  // CONSTRUCTOR
  // ==================================================

  public constructor() {
    this._uniqueId = generateUniqueId();
  }

  // ==================================================
  // IMPLEMENTATION of TreeNodeType interface
  // ==================================================

  public get id(): string {
    return this.uniqueId;
  }

  public get isVisibleInTree(): boolean {
    return true; // to be overridden
  }

  public get isParent(): boolean {
    return this.childCount > 0;
  }

  public get iconColor(): IconColor {
    if (!this.hasIconColor) {
      return undefined;
    }
    return this.color.getHexString();
  }

  public get hasBoldLabel(): boolean {
    return false;
  }

  public get checkboxState(): CheckboxState | undefined {
    switch (this.getVisibleState()) {
      case VisibleState.All:
        return CheckboxState.All;
      case VisibleState.None:
        return CheckboxState.None;
      case VisibleState.Some:
        return CheckboxState.Some;
      default:
        return undefined;
    }
  }

  public get isCheckboxEnabled(): boolean {
    return this.getVisibleState() !== VisibleState.Disabled;
  }

  public *getChildren(_loader?: ILazyLoader): Generator<TreeNodeType> {
    for (const child of this.children) {
      yield child;
    }
  }

  private readonly _treeNodeListeners: TreeNodeAction[] = [];

  public addTreeNodeListener(listener: TreeNodeAction): void {
    this._treeNodeListeners.push(listener);
  }

  public removeTreeNodeListener(listener: TreeNodeAction): void {
    remove(this._treeNodeListeners, listener);
  }

  public updateTreeNodeListeners(): void {
    for (const listener of this._treeNodeListeners) {
      listener(this);
    }
  }

  // ==================================================
  // INSTANCE/VIRTUAL PROPERTIES
  // ==================================================

  public abstract get typeName(): TranslationInput; // to be overridden

  // ==================================================
  // INSTANCE/VIRTUAL METHODS: Naming
  // ==================================================

  public get canChangeName(): boolean {
    return true; // to be overridden
  }

  public get name(): string | undefined {
    return this._name;
  }

  public set name(value: string | undefined) {
    this._name = value;
  }

  public get hasIndexOnLabel(): boolean {
    return true; // to be overridden, should return true if an index is added to the autogenerated label
  }

  public get labelExtension(): string | undefined {
    return undefined; // to be overridden, should be added is added to the autogenerated label for more information
  }

  /**
   * Generates a label for the domain object using the provided translation delegate.
   * If the name is provided, the label is set to the name, else
   * the label is constructed based on the object's type name, index, and label extension.
   * The label is used in UI
   * @remarks
   * - If the object's name is already defined, the method returns early without modifying the label.
   * - If the object has an index on the label, the index is appended to the label.
   * - If the object has a label extension, it is appended to the label in parentheses.
   */
  public get label(): string {
    if (this.name !== undefined) {
      return this.name; // The user has set the name
    }
    // Auto generate the name based on typeName, index and labelExtension
    let label = translate(this.typeName);
    if (this.hasIndexOnLabel) {
      const childIndex = getChildIndex(this);
      if (childIndex !== undefined) {
        label += ` ${childIndex + 1}`;
      }
    }
    if (this.labelExtension !== undefined) {
      label += ` (${this.labelExtension})`;
    }
    return label;

    function getChildIndex(self: DomainObject): number | undefined {
      const { parent } = self;
      if (parent === undefined) {
        return undefined;
      }
      let childIndex = 0;
      for (const child of parent.children) {
        if (child === self) {
          break;
        }
        if (self.getTypeName() === child.getTypeName()) {
          childIndex += 1;
        }
      }
      return childIndex;
    }
  }

  // ==================================================
  // INSTANCE/VIRTUAL METHODS: Color
  // ==================================================

  public get canChangeColor(): boolean {
    return true; // to be overridden
  }

  public get hasIconColor(): boolean {
    return true;
  }

  public get color(): Color {
    if (this._color === undefined) {
      this._color = getNextColor().clone();
    }
    return this._color;
  }

  public setColor(color: ColorRepresentation): void {
    if (this._color === undefined) {
      this._color = new Color(color);
    } else {
      this._color.set(color);
    }
  }

  // ==================================================
  // INSTANCE/VIRTUAL METHODS: Selected
  // ==================================================

  public get canBeSelected(): boolean {
    return true; // to be overridden
  }

  public get isSelected(): boolean {
    return this._isSelected;
  }

  public set isSelected(value: boolean) {
    this._isSelected = value;
  }

  public setSelectedInteractive(value: boolean): boolean {
    if (this.isSelected === value) {
      return false;
    }
    this.isSelected = value;
    this.notify(Changes.selected);
    return true;
  }

  // ==================================================
  // INSTANCE/VIRTUAL METHODS: Active
  // ==================================================

  public get canBeActive(): boolean {
    return false; // to be overridden
  }

  public get isActive(): boolean {
    return this._isActive;
  }

  public set isActive(value: boolean) {
    this._isActive = value;
  }

  public setActiveInteractive(): void {
    // To be called when a object should be active
    if (this.isActive) {
      return;
    }
    if (!this.canBeActive) {
      return;
    }
    if (this.parent !== undefined) {
      // Turn the others off
      for (const sibling of this.parent.children) {
        if (sibling === this) {
          continue;
        }
        if (sibling.getTypeName() !== this.getTypeName()) {
          continue;
        }
        if (!sibling.canBeActive) {
          continue;
        }
        if (!sibling.isActive) {
          continue;
        }
        sibling.isActive = false;
        sibling.notify(Changes.active);
      }
    }
    this.isActive = true;
    this.notify(Changes.active);
  }

  // ==================================================
  // INSTANCE/INSTANCE METHODS: Expanded in tree view
  // ==================================================

  public get isExpanded(): boolean {
    return this._isExpanded;
  }

  public set isExpanded(value: boolean) {
    if (this._isExpanded === value) {
      return;
    }
    this._isExpanded = value;
    this.notify(Changes.expanded);
  }

  // ==================================================
  // VIRTUAL METHODS: Appearance in the tree view
  // ==================================================

  public get canBeRemoved(): boolean {
    return true; // to be overridden
  }

  public canBeSetVisibleNow(_target: RevealRenderTarget): boolean {
    return true; // to be overridden
  }

  /**
   * Gets a value indicating whether the domain object is legal.
   * Normally it is legal, but if the object is pending when creating it, it is not legal.
   * @returns {boolean} A boolean value indicating whether the domain object is legal.
   */

  public get isLegal(): boolean {
    return true;
  }

  // ==================================================
  // VIRTUAL METHODS: Notification
  // ==================================================

  /**
   * Notifies the registered views and listeners about a change in the domain object.
   * This method should be overridden in derived classes to provide custom implementation.
   * @param change - The change object representing the update.
   * @remarks
   * Always call `super.notifyCore()` in the overrides.
   */
  protected notifyCore(change: DomainObjectChange): void {
    this.views.notify(this, change);

    // If isRenderStyleRoot is true, notify all descendants
    if (change.isChanged(Changes.renderStyle) && this.isRenderStyleRoot) {
      const description = change.getChangedDescription(Changes.renderStyle);
      if (description !== undefined) {
        const renderStyleChange = new DomainObjectChange(description);
        this.notifyDescendants(renderStyleChange);
      }
    }

    if (
      change.isChanged(
        Changes.visibleState,
        Changes.active,
        Changes.selected,
        Changes.childAdded,
        Changes.childDeleted
      )
    ) {
      // Update all the command buttons (in the toolbars).
      // This goes fast and will not slow the system down.
      const renderTarget = getRenderTarget(this);
      renderTarget?.updateAllCommands();
    }
    if (this.hasPanelInfo) {
      const renderTarget = getRenderTarget(this);
      renderTarget?.panelUpdater.notify(this, change);
    }
    this.updateTreeNodeListeners();
  }

  /**
   * Creates a transaction based on the specified changes. This is used for undoing
   * @param changed - A symbol representing the changes made to the domain object.
   * @returns A Transaction object if the transaction was created successfully, otherwise undefined.
   */
  public createTransaction(_changed: symbol): Transaction | undefined {
    return undefined;
  }

  /**
   * Creates a copy of this the domain object. The copy will not include any parent/child relationships, or views
   * @param what - Optional parameter specifying which properties to copy. If not provided, all properties will be copied.
   * @returns A new domain object
   */
  public clone(_what?: symbol): DomainObject {
    throw new Error('Method not implemented.');
  }

  /**
   * Copies the properties from another `DomainObject` instance to this instance.
   * @param domainObject - The `DomainObject` instance to copy from.
   * @param what - Optional parameter specifying which properties to copy. If not provided, all properties will be copied.
   */
  public copyFrom(domainObject: DomainObject, what?: symbol): void {
    if (what === undefined) {
      this.uniqueId = domainObject.uniqueId;
    }
    if (what === undefined || what === Changes.color) {
      if (this.canChangeColor) {
        this.setColor(domainObject.color);
      }
    }
    if (what === undefined || what === Changes.naming) {
      this.name = domainObject.name;
    }
    if (what === undefined || what === Changes.renderStyle) {
      this._renderStyle = domainObject._renderStyle?.clone();
    }
  }

  // ==================================================
  // VIRTUAL METHODS: For updating the panel
  // ==================================================

  public get hasPanelInfo(): boolean {
    return false; // to be overridden
  }

  public getPanelInfo(): PanelInfo | undefined {
    return undefined; // to be overridden
  }

  public getPanelInfoStyle(): PopupStyle {
    // Default lower left corner
    return new PopupStyle({ bottom: 50, left: 0 });
  }

  public getPanelToolbar(): BaseCommand[] {
    // to be overridden
    return [
      new CopyToClipboardCommand(),
      new CycleLengthUnitsCommand(),
      new DeleteDomainObjectCommand(this)
    ];
  }

  // ==================================================
  // VIRTUAL METHODS: Others
  // ==================================================

  public get icon(): IconName {
    return undefined;
  }

  /**
   * Removes the core functionality of the domain object.
   * This will automatically be called when the domain object is removed from its parent, by the function DomainObject.remove()
   * This method should be overridden in derived classes to provide custom implementation.
   * @remarks
   * Always call `super.dispose()` in the overrides.
   */
  public dispose(): void {
    this.views.dispose();
    for (const disposable of this._disposables) {
      disposable();
    }
    clear(this._disposables);
  }

  // ==================================================
  // VIRTUAL METHODS: Render styles
  // ==================================================

  /**
   * Override if the render style is taken from another domain object, for instance the parent
   * or somewhere else in the hierarchy
   * @returns The render style root
   */
  public get renderStyleRoot(): DomainObject | undefined {
    return undefined;
  }

  /**
   * Override if this domain object is a render style root, se method above
   * @returns true if this is a render style root
   */
  public get isRenderStyleRoot(): boolean {
    return false;
  }

  /**
   * Factory method to create the render style for the domain object.
   * Override this method to create a custom render style.
   * @returns The render style
   */
  public createRenderStyle(): RenderStyle | undefined {
    return undefined;
  }

  /**
   * Verifies the render style for the domain object, because the render style may
   * be not valid in some cases. In this method you can change the render style.
   * You can also change som fields in the renderStyle to get default values
   * dependent of the domain object itself.
   * Override this method when needed
   */
  public verifyRenderStyle(_style: RenderStyle): void {}

  // ==================================================
  // VIRTUAL METHODS: Visibility
  // ==================================================

  public getVisibleState(renderTarget?: RevealRenderTarget): VisibleState {
    // If renderTarget is not provided, use the renderTarget of the root
    if (renderTarget === undefined) {
      renderTarget = getRenderTarget(this);
      if (renderTarget === undefined) {
        return VisibleState.Disabled;
      }
    }
    let numCandidates = 0;
    let numAll = 0;
    let numNone = 0;

    for (const child of this.children) {
      const childState = child.getVisibleState(renderTarget);
      if (childState === VisibleState.Disabled) {
        continue;
      }
      numCandidates++;
      if (childState === VisibleState.All) {
        numAll++;
      } else if (
        childState === VisibleState.None ||
        childState === VisibleState.CanNotBeVisibleNow
      ) {
        numNone++;
      }
      if (numNone < numCandidates && numCandidates < numAll) {
        return VisibleState.Some;
      }
    }
    if (numCandidates === 0) {
      return VisibleState.Disabled;
    }
    if (numCandidates === numAll) {
      return VisibleState.All;
    }
    if (numCandidates === numNone) {
      return this.canBeSetVisibleNow(renderTarget)
        ? VisibleState.None
        : VisibleState.CanNotBeVisibleNow;
    }
    return VisibleState.Some;
  }

  public setVisibleInteractive(
    visible: boolean,
    renderTarget: RevealRenderTarget | undefined = undefined,
    topLevel = true // When calling this from outside, this value should always be true
  ): boolean {
    // If renderTarget is not provided, use the renderTarget of the root
    if (renderTarget === undefined) {
      renderTarget = getRenderTarget(this);
      if (renderTarget === undefined) {
        return false;
      }
    }
    const visibleState = this.getVisibleState(renderTarget);
    if (visibleState === VisibleState.Disabled) {
      return false;
    }
    if (visibleState === VisibleState.None && !this.canBeSetVisibleNow(renderTarget)) {
      return false;
    }
    let hasChanged = false;
    for (const child of this.children) {
      if (child.setVisibleInteractive(visible, renderTarget, false)) {
        hasChanged = true;
      }
    }
    if (!hasChanged) {
      return false;
    }
    if (topLevel) {
      this.notifyVisibleStateChange();
    }
    return true;
  }

  // ==================================================
  // INSTANCE METHODS: Notification
  // ==================================================

  public notify(change: DomainObjectChange | ChangedDescription | symbol): void {
    if (typeof change === 'symbol') {
      change = new DomainObjectChange(change);
    } else if (change instanceof ChangedDescription) {
      change = new DomainObjectChange(change);
    }
    this.notifyCore(change);
  }

  public notifyDescendants(change: DomainObjectChange | ChangedDescription | symbol): void {
    if (typeof change === 'symbol') {
      change = new DomainObjectChange(change);
    } else if (change instanceof ChangedDescription) {
      change = new DomainObjectChange(change);
    }
    for (const descendant of this.getDescendants()) {
      descendant.notify(change);
    }
  }

  protected notifyVisibleStateChange(): void {
    const change = new DomainObjectChange(Changes.visibleState);
    this.notify(change);
    for (const ancestor of this.getAncestors()) {
      ancestor.notify(change);
    }
    for (const descendant of this.getDescendants()) {
      descendant.notify(change);
    }
  }
  // ==================================================
  // INSTANCE METHODS: Visibility
  // ==================================================

  public toggleVisibleInteractive(renderTarget?: RevealRenderTarget): void {
    const visibleState = this.getVisibleState(renderTarget);
    if (visibleState === VisibleState.None) {
      this.setVisibleInteractive(true, renderTarget);
    } else if (visibleState === VisibleState.Some || visibleState === VisibleState.All) {
      this.setVisibleInteractive(false, renderTarget);
    }
  }

  /**
   * Checks if the domain object is visible in the specified render target.
   * @param renderTarget - The render target to check visibility in.
   * @returns `true` if the domain object is visible in the target, `false` otherwise.
   */
  public isVisible(renderTarget?: RevealRenderTarget): boolean {
    const visibleState = this.getVisibleState(renderTarget);
    return visibleState === VisibleState.Some || visibleState === VisibleState.All;
  }

  // ==================================================
  // INSTANCE PROPERTIES: Child-Parent relationship
  // ==================================================

  public get children(): DomainObject[] {
    return this._children;
  }

  public get childCount(): number {
    return this._children.length;
  }

  public get childIndex(): number | undefined {
    return this.parent === undefined ? undefined : this.parent.children.indexOf(this);
  }

  public get parent(): DomainObject | undefined {
    return this._parent;
  }

  public get root(): DomainObject {
    // Returns the root of the hierarchy, regardless what it is
    return this.parent === undefined ? this : this.parent.root;
  }

  public get isRoot(): boolean {
    // Returns true if it is RootDomainObject (To fix a cyclic dependency)
    return false;
  }

  public get hasParent(): boolean {
    return this._parent !== undefined;
  }

  // ==================================================
  // INSTANCE METHODS: Get a child or children
  // ==================================================

  public hasChildByType<T extends DomainObject>(classType: Class<T>): boolean {
    return this.getChildByType(classType) !== undefined;
  }

  public getChild(index: number): DomainObject {
    return this._children[index];
  }

  public getChildByType<T extends DomainObject>(classType: Class<T>): T | undefined {
    for (const child of this.children) {
      if (isInstanceOf(child, classType)) {
        return child;
      }
    }
    return undefined;
  }

  public getActiveChildByType<T extends DomainObject>(classType: Class<T>): T | undefined {
    for (const child of this.children) {
      if (child.isActive && isInstanceOf(child, classType)) {
        return child;
      }
    }
    return undefined;
  }

  public *getChildrenByType<T extends DomainObject>(classType: Class<T>): Generator<T> {
    for (const child of this.children) {
      if (isInstanceOf(child, classType)) {
        yield child;
      }
    }
  }

  // ==================================================
  // INSTANCE METHODS: Get descendants (returning a generator)
  // ==================================================

  public *getDescendants(): Generator<DomainObject> {
    for (const child of this.children) {
      yield child;
      yield* child.getDescendants();
    }
  }

  public *getThisAndDescendants(): Generator<DomainObject> {
    yield this;
    for (const descendant of this.getDescendants()) {
      yield descendant;
    }
  }

  public *getDescendantsByType<T extends DomainObject>(classType: Class<T>): Generator<T> {
    for (const descendant of this.getDescendants()) {
      if (isInstanceOf(descendant, classType)) {
        yield descendant;
      }
    }
  }

  public *getThisAndDescendantsByType<T extends DomainObject>(classType: Class<T>): Generator<T> {
    for (const descendant of this.getThisAndDescendants()) {
      if (isInstanceOf(descendant, classType)) {
        yield descendant;
      }
    }
  }

  // ==================================================
  // INSTANCE METHODS: Get single descendant
  // (returning a DomainObject | undefined)
  // ==================================================

  public getDescendantByType<T extends DomainObject>(classType: Class<T>): T | undefined {
    for (const descendant of this.getDescendants()) {
      if (isInstanceOf(descendant, classType)) {
        return descendant;
      }
    }
    return undefined;
  }

  public getThisOrDescendantByUniqueId(uniqueId: UniqueId): DomainObject | undefined {
    for (const descendant of this.getThisAndDescendants()) {
      if (descendant.uniqueId === uniqueId) {
        return descendant;
      }
    }
    return undefined;
  }

  public getSelectedDescendant(): DomainObject | undefined {
    for (const descendant of this.getThisAndDescendants()) {
      if (descendant.isSelected) {
        return descendant;
      }
    }
    return undefined;
  }

  public getSelectedDescendantByType<T extends DomainObject>(classType: Class<T>): T | undefined {
    for (const descendant of this.getDescendantsByType(classType)) {
      if (descendant.isSelected) {
        return descendant;
      }
    }
    return undefined;
  }

  public getActiveDescendantByType<T extends DomainObject>(classType: Class<T>): T | undefined {
    for (const descendant of this.getDescendantsByType(classType)) {
      if (descendant.isActive) {
        return descendant;
      }
    }
    return undefined;
  }

  // ==================================================
  // INSTANCE METHODS: Get ancestors
  // ==================================================

  public *getAncestors(): Generator<DomainObject> {
    let ancestor = this.parent;
    while (ancestor !== undefined) {
      yield ancestor;
      ancestor = ancestor.parent;
    }
  }

  public *getThisAndAncestors(): Generator<DomainObject> {
    yield this;
    let ancestor = this.parent;
    while (ancestor !== undefined) {
      yield ancestor;
      ancestor = ancestor.parent;
    }
  }

  public getAncestorByType<T>(classType: Class<T>): T | undefined {
    for (const ancestor of this.getAncestors()) {
      if (isInstanceOf(ancestor, classType)) {
        return ancestor as T;
      }
    }
    return undefined;
  }

  public getThisOrAncestorByType<T>(classType: Class<T>): T | undefined {
    for (const ancestor of this.getThisAndAncestors()) {
      if (isInstanceOf(ancestor, classType)) {
        return ancestor as T;
      }
    }
    return undefined;
  }

  // ==================================================
  // INSTANCE METHODS: Child-Parent relationship
  // ==================================================

  public addChild(child: DomainObject, insertFirst = false): void {
    if (child.hasParent) {
      throw Error(`The child ${child.getTypeName()} already has a parent`);
    }
    if (child === this) {
      throw Error(`Trying to add illegal child ${child.getTypeName()}`);
    }
    if (insertFirst) {
      this._children.unshift(child);
    } else {
      this._children.push(child);
    }
    child._parent = this;
  }

  public addChildInteractive(child: DomainObject, insertFirst = false): void {
    this.addChild(child, insertFirst);
    this.notify(Changes.childAdded);
    child.notify(Changes.added);
  }

  private remove(): boolean {
    const { childIndex } = this;
    if (childIndex === undefined) {
      throw Error(`The child ${this.getTypeName()} is not child of it's parent`);
    }
    clear(this._children);
    this.dispose();

    if (this.parent !== undefined) {
      removeAt(this.parent.children, childIndex);
      this._parent = undefined;
    }
    return true;
  }

  public removeInteractive(checkCanBeDeleted = true): boolean {
    if (checkCanBeDeleted && !this.canBeRemoved) {
      return false;
    }
    for (const child of this.children) {
      child.removeInteractive(false); // If parent can be removed, so the children also
    }
    const { parent, root } = this;
    this.notify(Changes.deleting);
    this.remove();
    parent?.notify(Changes.childDeleted);

    this.notify(Changes.deleted);
    if (root !== undefined && root !== this) {
      root.views.notifyListeners(this, new DomainObjectChange(Changes.deleted));
    }
    return true;
  }

  // ==================================================
  // INSTANCE METHODS: Render styles
  // ==================================================

  public getRenderStyle(): RenderStyle | undefined {
    // Find the root of the render style
    const root = this.renderStyleRoot;
    if (root !== undefined && root !== this) {
      return root.getRenderStyle();
    }
    // Create it if not created
    if (this._renderStyle === undefined) {
      this._renderStyle = this.createRenderStyle();
    }
    // Verify it
    if (this._renderStyle !== undefined) {
      this.verifyRenderStyle(this._renderStyle);
    }
    return this._renderStyle;
  }

  public setRenderStyle(value: RenderStyle | undefined = undefined): void {
    this._renderStyle = value;
  }

  // ==================================================
  // INSTANCE METHODS: Get auto name and color
  // ==================================================

  private getTypeName(): string {
    if (isTranslatedString(this.typeName)) {
      return this.typeName.key;
    } else {
      return this.typeName.untranslated;
    }
  }

  // ==================================================
  // INSTANCE METHODS: Color type
  // Used in the render style to determine which of the color a domain object should have.
  // ==================================================

  public supportsColorType(colorType: ColorType, solid: boolean): boolean {
    switch (colorType) {
      case ColorType.Specified:
      case ColorType.Parent:
      case ColorType.Black:
      case ColorType.White:
        return true;

      case ColorType.ColorMap:
        return solid;

      default:
        return false;
    }
  }

  public getColorByColorType(colorType: ColorType): Color {
    switch (colorType) {
      case ColorType.Specified:
        return this.color;
      case ColorType.Parent:
        if (this.parent !== undefined) {
          return this.parent.color;
        }
        break;
      case ColorType.Black:
        return BLACK_COLOR;
    }
    return WHITE_COLOR;
  }

  // ==================================================
  // INSTANCE METHODS: Miscellaneous
  // ==================================================

  protected addDisposable(disposable: () => void): void {
    this._disposables.push(disposable);
  }

  protected addEffect(effectFunction: () => void): void {
    this.addDisposable(
      effect(() => {
        effectFunction();
      })
    );
  }
}
