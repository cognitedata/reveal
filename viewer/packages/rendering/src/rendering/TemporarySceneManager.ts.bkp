/*!
 * Copyright 2022 Cognite AS
 */


import * as THREE from 'three';

export class TemporarySceneManager {

  private readonly _normalScene: THREE.Scene;
  private readonly _inFrontScene: THREE.Scene;

  private readonly _normalSceneBuilder: TemporarySceneBuilder;
  private readonly _inFrontSceneBuilder: TemporarySceneBuilder;

  constructor() {
    this._normalScene = new THREE.Scene();
    this._normalScene.autoUpdate = false;

    this._inFrontScene = new THREE.Scene();
    this._inFrontScene.autoUpdate = false;

    this._normalSceneBuilder = new TemporarySceneBuilder(this._normalScene);
    this._inFrontSceneBuilder = new TemporarySceneBuilder(this._inFrontScene);
  }

  public renderInFrontCadModels(camera: THREE.Camera) {

  }

  public renderNormalCadModels(camera: THREE.Camera) {

  }
}




/**
 * Holds parent-child relationship for a ThreeJS element in order to restore
 * the relationship after moving it temporarily.
 */
type Object3DStructure = {
  /**
   * Element described.
   */
  object: THREE.Object3D;
  /**
   * The previous parent of the element.
   */
  parent: THREE.Object3D;
  /**
   * The object that temporarily holds the elemnt.
   */
  sceneParent: THREE.Object3D;
};

class TemporarySceneBuilder {
  private readonly buffer: Object3DStructure[];
  private readonly temporaryScene: THREE.Scene;

  constructor(temporaryScene: THREE.Scene) {
    this.buffer = [];
    this.temporaryScene = temporaryScene;
  }

  addElement(element: THREE.Object3D, temporaryModelRootElement: THREE.Object3D): void {
    this.buffer.push({ object: element, parent: element.parent!, sceneParent: temporaryModelRootElement });
  }

  populateTemporaryScene(): void {
    this.buffer.forEach(x => x.sceneParent.add(x.object));
  }

  restoreOriginalScene(): void {
    this.buffer.forEach(p => {
      p.parent.add(p.object);
    });
    this.buffer.length = 0; // clear
    this.temporaryScene.remove(...this.temporaryScene.children);
  }
}
