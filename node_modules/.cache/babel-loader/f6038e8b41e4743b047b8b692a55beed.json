{"ast":null,"code":"import get from 'lodash/get';\nimport isArray from 'lodash/isArray';\nimport isEmpty from 'lodash/isEmpty';\nexport const extractMatchingLabels = (data, query, properties, fallbackFuzzyMatch) => {\n  const matchers = {\n    exact: [],\n    fuzzy: [],\n    partial: []\n  };\n  const getKey = property => {\n    if (typeof property === 'string') {\n      return property;\n    }\n    return property?.label || property.key;\n  };\n  properties.forEach(property => {\n    const value = typeof property === 'string' ? get(data, property) : get(data, property.key);\n    if (value) {\n      if (typeof property !== 'string' && property.customMatcher) {\n        property.customMatcher(value, query, matchers);\n        return;\n      }\n      const useSubstringMatch = typeof property !== 'string' && property.useSubstringMatch;\n      switch (typeof value) {\n        case 'number':\n          {\n            if (isExactMatch(value, query)) {\n              matchers.exact.push(getKey(property));\n            }\n            break;\n          }\n        case 'string':\n          {\n            if (isExactMatch(value, query)) {\n              matchers.exact.push(getKey(property));\n            } else if (isPartialMatch(value, query, useSubstringMatch)) {\n              matchers.partial.push(getKey(property));\n            }\n            break;\n          }\n        case 'object':\n          {\n            if (!isArray(value)) {\n              Object.keys(value).forEach(childKey => {\n                const childValue = value[childKey];\n                if (typeof childValue !== 'string') {\n                  console.warn('Unsupported nested value type');\n                  return;\n                }\n                const matchedProperty = `${getKey(property)} \"${childKey}\"`;\n                if (isExactMatch(childValue, query)) {\n                  matchers.exact.push(matchedProperty);\n                } else if (isPartialMatch(childValue, query, useSubstringMatch)) {\n                  matchers.partial.push(matchedProperty);\n                }\n              });\n            } else {\n              value.forEach(childValue => {\n                if (typeof childValue !== 'string') {\n                  console.warn('Unsupported nested value type');\n                  return;\n                }\n                const matchedProperty = `${getKey(property)} ${childValue}`;\n                if (isExactMatch(childValue, query)) {\n                  matchers.exact.push(matchedProperty);\n                } else if (isPartialMatch(childValue, query, useSubstringMatch)) {\n                  matchers.partial.push(matchedProperty);\n                }\n              });\n            }\n            break;\n          }\n        default:\n          {\n            console.warn('Unsupported matching label type');\n          }\n      }\n    }\n  });\n  if (isEmpty(matchers.exact) && isEmpty(matchers.partial) && isEmpty(matchers.fuzzy)) {\n    matchers.fuzzy.push(fallbackFuzzyMatch || 'Name or Description');\n  }\n  return matchers;\n};\nexport const isExactMatch = (value, query) => {\n  if (typeof value === 'number' && Number(query)) {\n    return value === Number(query);\n  }\n  return value.toString().toLowerCase() === query.toLowerCase();\n};\nexport const isPartialMatch = (value, query, checkSubstring) => {\n  if (checkSubstring) {\n    return value.toString().toLowerCase().includes(query.toLowerCase());\n  }\n  return value.toString().toLowerCase().startsWith(query.toLowerCase());\n};","map":{"version":3,"names":["get","isArray","isEmpty","extractMatchingLabels","data","query","properties","fallbackFuzzyMatch","matchers","exact","fuzzy","partial","getKey","property","label","key","forEach","value","customMatcher","useSubstringMatch","isExactMatch","push","isPartialMatch","Object","keys","childKey","childValue","console","warn","matchedProperty","Number","toString","toLowerCase","checkSubstring","includes","startsWith"],"sources":["/Volumes/csvol/fusion/libs/data-exploration/domain-layer/src/utils/extractMatchingLabels.ts"],"sourcesContent":["import get from 'lodash/get';\nimport isArray from 'lodash/isArray';\nimport isEmpty from 'lodash/isEmpty';\n\nimport { MatchingLabels } from '../types';\n\nexport type MatchingLabelPropertyType =\n  | string\n  | {\n      key: string;\n      label?: string;\n      useSubstringMatch?: boolean; // INFO: if you want to check for substring instead of prefix\n      customMatcher?: (\n        value: any,\n        query: string,\n        matchers: MatchingLabels\n      ) => void;\n    };\n\nexport const extractMatchingLabels = (\n  data: Record<string, any>,\n  query: string,\n  properties: MatchingLabelPropertyType[],\n  fallbackFuzzyMatch?: string\n): MatchingLabels => {\n  const matchers: MatchingLabels = {\n    exact: [],\n    fuzzy: [],\n    partial: [],\n  };\n\n  const getKey = (property: string | { key: string; label?: string }) => {\n    if (typeof property === 'string') {\n      return property;\n    }\n    return property?.label || property.key;\n  };\n\n  properties.forEach((property) => {\n    const value =\n      typeof property === 'string'\n        ? get(data, property)\n        : get(data, property.key);\n\n    if (value) {\n      if (typeof property !== 'string' && property.customMatcher) {\n        property.customMatcher(value, query, matchers);\n        return;\n      }\n\n      const useSubstringMatch =\n        typeof property !== 'string' && property.useSubstringMatch;\n\n      switch (typeof value) {\n        case 'number': {\n          if (isExactMatch(value, query)) {\n            matchers.exact.push(getKey(property));\n          }\n          break;\n        }\n        case 'string': {\n          if (isExactMatch(value, query)) {\n            matchers.exact.push(getKey(property));\n          } else if (isPartialMatch(value, query, useSubstringMatch)) {\n            matchers.partial.push(getKey(property));\n          }\n          break;\n        }\n        case 'object': {\n          if (!isArray(value)) {\n            Object.keys(value).forEach((childKey) => {\n              const childValue = value[childKey];\n              if (typeof childValue !== 'string') {\n                console.warn('Unsupported nested value type');\n                return;\n              }\n              const matchedProperty = `${getKey(property)} \"${childKey}\"`;\n              if (isExactMatch(childValue, query)) {\n                matchers.exact.push(matchedProperty);\n              } else if (isPartialMatch(childValue, query, useSubstringMatch)) {\n                matchers.partial.push(matchedProperty);\n              }\n            });\n          } else {\n            value.forEach((childValue) => {\n              if (typeof childValue !== 'string') {\n                console.warn('Unsupported nested value type');\n                return;\n              }\n              const matchedProperty = `${getKey(property)} ${childValue}`;\n              if (isExactMatch(childValue, query)) {\n                matchers.exact.push(matchedProperty);\n              } else if (isPartialMatch(childValue, query, useSubstringMatch)) {\n                matchers.partial.push(matchedProperty);\n              }\n            });\n          }\n          break;\n        }\n        default: {\n          console.warn('Unsupported matching label type');\n        }\n      }\n    }\n  });\n\n  if (\n    isEmpty(matchers.exact) &&\n    isEmpty(matchers.partial) &&\n    isEmpty(matchers.fuzzy)\n  ) {\n    matchers.fuzzy.push(fallbackFuzzyMatch || 'Name or Description');\n  }\n\n  return matchers;\n};\n\nexport const isExactMatch = (\n  value: string | number,\n  query: string\n): boolean => {\n  if (typeof value === 'number' && Number(query)) {\n    return value === Number(query);\n  }\n\n  return value.toString().toLowerCase() === query.toLowerCase();\n};\n\nexport const isPartialMatch = (\n  value: string,\n  query: string,\n  checkSubstring?: boolean\n): boolean => {\n  if (checkSubstring) {\n    return value.toString().toLowerCase().includes(query.toLowerCase());\n  }\n  return value.toString().toLowerCase().startsWith(query.toLowerCase());\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}