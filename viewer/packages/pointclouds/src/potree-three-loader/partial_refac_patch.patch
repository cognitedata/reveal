diff --git a/src/loading/binary-loader.ts b/src/loading/binary-loader.ts
index 2b27540..aa7f3ea 100644
--- a/src/loading/binary-loader.ts
+++ b/src/loading/binary-loader.ts
@@ -3,8 +3,8 @@
 // -------------------------------------------------------------------------------------------------
 
 import { Box3, BufferAttribute, BufferGeometry, Uint8BufferAttribute, Vector3 } from 'three';
-import { PointAttributeName, PointAttributeType } from '../point-attributes';
-import { PointCloudOctreeGeometryNode } from '../point-cloud-octree-geometry-node';
+import { PointAttributeName, PointAttributeType } from '../PointAttributes';
+import { PointCloudOctreeGeometryNode } from '../PointCloudOctreeGeometryNode';
 import { Version } from '../version';
 import { GetUrlFn, XhrRequest } from './types';
 
diff --git a/src/loading/ept/BinaryLoader.ts b/src/loading/ept/BinaryLoader.ts
new file mode 100644
index 0000000..3bb69cf
--- /dev/null
+++ b/src/loading/ept/BinaryLoader.ts
@@ -0,0 +1,119 @@
+
+import { PointCloudEptGeometryNode } from "../../PointCloudEptGeometryNode";
+import * as THREE from 'three';
+
+import { XHRFactory } from '../../utils/XHRFactory';
+import { workerPool } from '../../utils/WorkerPool';
+
+import { ILoader } from './ILoader';
+
+export class EptBinaryLoader implements ILoader{
+  extension() {
+    return '.bin';
+  }
+
+  workerPath() {
+    // return Potree.scriptPath + './workers/EptBinaryDecoderWorker.js';
+    return './workers/EptBinaryDecoderWorker.js';
+  }
+
+  load(node: any) {
+    if (node.loaded) return;
+
+    let url = node.url() + this.extension();
+
+    let xhr = XHRFactory.createXMLHttpRequest();
+    xhr.open('GET', url, true);
+    xhr.responseType = 'arraybuffer';
+    xhr.overrideMimeType('text/plain; charset=x-user-defined');
+    xhr.onreadystatechange = () => {
+      if (xhr.readyState === 4) {
+	if (xhr.status === 200) {
+	  let buffer = xhr.response;
+	  this.parse(node, buffer);
+	} else {
+	  console.log('Failed ' + url + ': ' + xhr.status);
+	}
+      }
+    };
+
+    try {
+      xhr.send(null);
+    }
+    catch (e) {
+      console.log('Failed request: ' + e);
+    }
+  }
+
+  parse(node: PointCloudEptGeometryNode, buffer: ArrayBuffer) {
+    let workerPath = this.workerPath();
+    let worker = workerPool.getWorker(workerPath);
+
+    worker.onmessage = function(e: any) {
+      let g = new THREE.BufferGeometry();
+      let numPoints = e.data.numPoints;
+
+      let position = new Float32Array(e.data.position);
+      g.setAttribute('position', new THREE.BufferAttribute(position, 3));
+
+      let indices = new Uint8Array(e.data.indices);
+      g.setAttribute('indices', new THREE.BufferAttribute(indices, 4));
+
+      if (e.data.color) {
+	let color = new Uint8Array(e.data.color);
+	g.setAttribute('color', new THREE.BufferAttribute(color, 4, true));
+      }
+      if (e.data.intensity) {
+	let intensity = new Float32Array(e.data.intensity);
+	g.setAttribute('intensity',
+		       new THREE.BufferAttribute(intensity, 1));
+      }
+      if (e.data.classification) {
+	let classification = new Uint8Array(e.data.classification);
+	g.setAttribute('classification',
+		       new THREE.BufferAttribute(classification, 1));
+      }
+      if (e.data.returnNumber) {
+	let returnNumber = new Uint8Array(e.data.returnNumber);
+	g.setAttribute('return number',
+		       new THREE.BufferAttribute(returnNumber, 1));
+      }
+      if (e.data.numberOfReturns) {
+	let numberOfReturns = new Uint8Array(e.data.numberOfReturns);
+	g.setAttribute('number of returns',
+		       new THREE.BufferAttribute(numberOfReturns, 1));
+      }
+      if (e.data.pointSourceId) {
+	let pointSourceId = new Uint16Array(e.data.pointSourceId);
+	g.setAttribute('source id',
+		       new THREE.BufferAttribute(pointSourceId, 1));
+      }
+
+      g.attributes.indices.normalized = true;
+
+      let tightBoundingBox = new THREE.Box3(
+	new THREE.Vector3().fromArray(e.data.tightBoundingBox.min),
+	new THREE.Vector3().fromArray(e.data.tightBoundingBox.max)
+      );
+
+      node.doneLoading(
+	g,
+	tightBoundingBox,
+	numPoints,
+	new THREE.Vector3(...e.data.mean));
+
+      workerPool.returnWorker(workerPath, worker);
+    };
+
+    let toArray = (v: THREE.Vector3) => [v.x, v.y, v.z];
+    let message = {
+      buffer: buffer,
+      schema: node.ept.schema,
+      scale: node.ept.eptScale,
+      offset: node.ept.eptOffset,
+      mins: toArray(node.key.b.min)
+    };
+
+    worker.postMessage(message, [message.buffer]);
+  }
+};
diff --git a/src/loading/ept/ILoader.ts b/src/loading/ept/ILoader.ts
new file mode 100644
index 0000000..cdbcc58
--- /dev/null
+++ b/src/loading/ept/ILoader.ts
@@ -0,0 +1,9 @@
+/*!
+ * Copyright 2022 Cognite AS
+ */
+
+export interface ILoader {
+  load(node: any): void;
+
+  parse(node: any, buffer: ArrayBuffer): void;
+}
diff --git a/src/loading/ept/LaszipLoader.js b/src/loading/ept/LaszipLoader.js
new file mode 100644
index 0000000..40fe98c
--- /dev/null
+++ b/src/loading/ept/LaszipLoader.js
@@ -0,0 +1,176 @@
+
+import * as THREE from "../../../libs/three.js/build/three.module.js";
+import {XHRFactory} from "../../XHRFactory.js";
+
+/**
+ * laslaz code taken and adapted from plas.io js-laslaz
+ *	  http://plas.io/
+ *	https://github.com/verma/plasio
+ *
+ * Thanks to Uday Verma and Howard Butler
+ *
+ */
+
+export class EptLaszipLoader {
+	load(node) {
+		if (node.loaded) return;
+
+		let url = node.url() + '.laz';
+
+		let xhr = XHRFactory.createXMLHttpRequest();
+		xhr.open('GET', url, true);
+		xhr.responseType = 'arraybuffer';
+		xhr.overrideMimeType('text/plain; charset=x-user-defined');
+		xhr.onreadystatechange = () => {
+			if (xhr.readyState === 4) {
+				if (xhr.status === 200) {
+					let buffer = xhr.response;
+					this.parse(node, buffer);
+				} else {
+					console.log('Failed ' + url + ': ' + xhr.status);
+				}
+			}
+		};
+
+		xhr.send(null);
+	}
+
+	async parse(node, buffer){
+		let lf = new LASFile(buffer);
+		let handler = new EptLazBatcher(node);
+
+		try{
+			await lf.open();
+
+			lf.isOpen = true;
+
+			const header = await lf.getHeader();
+
+			{
+				let i = 0;
+
+				let toArray = (v) => [v.x, v.y, v.z];
+				let mins = toArray(node.key.b.min);
+				let maxs = toArray(node.key.b.max);
+
+				let hasMoreData = true;
+
+				while(hasMoreData){
+					const data = await lf.readData(1000000, 0, 1);
+
+					let d = new LASDecoder(
+						data.buffer,
+						header.pointsFormatId,
+						header.pointsStructSize,
+						data.count,
+						header.scale,
+						header.offset,
+						mins,
+						maxs);
+
+					d.extraBytes = header.extraBytes;
+					d.pointsFormatId = header.pointsFormatId;
+					handler.push(d);
+
+					i += data.count;
+
+					hasMoreData = data.hasMoreData;
+				}
+
+				header.totalRead = i;
+				header.versionAsString = lf.versionAsString;
+				header.isCompressed = lf.isCompressed;
+
+				await lf.close();
+
+				lf.isOpen = false;
+			}
+
+		}catch(err){
+			console.error('Error reading LAZ:', err);
+			
+			if (lf.isOpen) {
+				await lf.close();
+
+				lf.isOpen = false;
+			}
+			
+			throw err;
+		}
+	}
+};
+
+export class EptLazBatcher {
+	constructor(node) { this.node = node; }
+
+	push(las) {
+		let workerPath = Potree.scriptPath +
+			'/workers/EptLaszipDecoderWorker.js';
+		let worker = Potree.workerPool.getWorker(workerPath);
+
+		worker.onmessage = (e) => {
+			let g = new THREE.BufferGeometry();
+			let numPoints = las.pointsCount;
+
+			let positions = new Float32Array(e.data.position);
+			let colors = new Uint8Array(e.data.color);
+
+			let intensities = new Float32Array(e.data.intensity);
+			let classifications = new Uint8Array(e.data.classification);
+			let returnNumbers = new Uint8Array(e.data.returnNumber);
+			let numberOfReturns = new Uint8Array(e.data.numberOfReturns);
+			let pointSourceIDs = new Uint16Array(e.data.pointSourceID);
+			let indices = new Uint8Array(e.data.indices);
+			let gpsTime = new Float32Array(e.data.gpsTime);
+
+			g.setAttribute('position',
+					new THREE.BufferAttribute(positions, 3));
+			g.setAttribute('rgba',
+					new THREE.BufferAttribute(colors, 4, true));
+			g.setAttribute('intensity',
+					new THREE.BufferAttribute(intensities, 1));
+			g.setAttribute('classification',
+					new THREE.BufferAttribute(classifications, 1));
+			g.setAttribute('return number',
+					new THREE.BufferAttribute(returnNumbers, 1));
+			g.setAttribute('number of returns',
+					new THREE.BufferAttribute(numberOfReturns, 1));
+			g.setAttribute('source id',
+					new THREE.BufferAttribute(pointSourceIDs, 1));
+			g.setAttribute('indices',
+					new THREE.BufferAttribute(indices, 4));
+			g.setAttribute('gpsTime',
+					new THREE.BufferAttribute(gpsTime, 1));
+			this.node.gpsTime = e.data.gpsMeta;
+
+			g.attributes.indices.normalized = true;
+
+			let tightBoundingBox = new THREE.Box3(
+				new THREE.Vector3().fromArray(e.data.tightBoundingBox.min),
+				new THREE.Vector3().fromArray(e.data.tightBoundingBox.max)
+			);
+
+			this.node.doneLoading(
+				g,
+				tightBoundingBox,
+				numPoints,
+				new THREE.Vector3(...e.data.mean));
+
+			Potree.workerPool.returnWorker(workerPath, worker);
+		};
+
+		let message = {
+			buffer: las.arrayb,
+			numPoints: las.pointsCount,
+			pointSize: las.pointSize,
+			pointFormatID: las.pointsFormatId,
+			scale: las.scale,
+			offset: las.offset,
+			mins: las.mins,
+			maxs: las.maxs
+		};
+
+		worker.postMessage(message, [message.buffer]);
+	};
+};
+
diff --git a/src/loading/ept/ZstandardLoader.js b/src/loading/ept/ZstandardLoader.js
new file mode 100644
index 0000000..ac7a687
--- /dev/null
+++ b/src/loading/ept/ZstandardLoader.js
@@ -0,0 +1,12 @@
+import {EptBinaryLoader} from "./BinaryLoader.js";
+
+export class EptZstandardLoader extends EptBinaryLoader {
+    extension() {
+        return '.zst';
+    }
+
+    workerPath() {
+        return Potree.scriptPath + '/workers/EptZstandardDecoderWorker.js';
+    }
+};
+
diff --git a/src/loading/globalLoadingCounter.ts b/src/loading/globalLoadingCounter.ts
new file mode 100644
index 0000000..e95f115
--- /dev/null
+++ b/src/loading/globalLoadingCounter.ts
@@ -0,0 +1,16 @@
+
+let globalNumNodesLoading: number = 0;
+const globalMaxNumNodesLoading: number = 10;
+
+export {
+  globalNumNodesLoading,
+  globalMaxNumNodesLoading
+};
+
+export function incrementGlobalNumNodesLoading() {
+  globalNumNodesLoading++;
+}
+
+export function decrementGlobalNumNodesLoading() {
+  globalNumNodesLoading--;
+}
diff --git a/src/loading/load-poc.ts b/src/loading/load-poc.ts
index c679042..2d0ef2e 100644
--- a/src/loading/load-poc.ts
+++ b/src/loading/load-poc.ts
@@ -3,9 +3,9 @@
 // -------------------------------------------------------------------------------------------------
 
 import { Box3, Vector3 } from 'three';
-import { PointAttributes, PointAttributeStringName } from '../point-attributes';
-import { PointCloudOctreeGeometry } from '../point-cloud-octree-geometry';
-import { PointCloudOctreeGeometryNode } from '../point-cloud-octree-geometry-node';
+import { PointAttributes, PointAttributeStringName } from '../PointAttributes';
+import { PointCloudOctreeGeometry } from '../PointCloudOctreeGeometry';
+import { PointCloudOctreeGeometryNode } from '../PointCloudOctreeGeometryNode';
 import { createChildAABB } from '../utils/bounds';
 import { getIndexFromName } from '../utils/utils';
 import { Version } from '../version';
diff --git a/src/materials/point-cloud-material.ts b/src/materials/PointCloudMaterial.ts
similarity index 98%
rename from src/materials/point-cloud-material.ts
rename to src/materials/PointCloudMaterial.ts
index 4566f06..5fe27c7 100644
--- a/src/materials/point-cloud-material.ts
+++ b/src/materials/PointCloudMaterial.ts
@@ -25,8 +25,9 @@ import {
   DEFAULT_RGB_GAMMA,
   PERSPECTIVE_CAMERA,
 } from '../constants';
-import { PointCloudOctree } from '../point-cloud-octree';
-import { PointCloudOctreeNode } from '../point-cloud-octree-node';
+import { PointCloudOctree } from '../PointCloudOctree';
+import { IPointCloudTreeNodeBase } from "../types/IPointCloudTreeNodeBase";
+import { IPointCloudTreeNode } from '../types/IPointCloudTreeNode';
 import { byLevelAndIndex } from '../utils/utils';
 import { DEFAULT_CLASSIFICATION } from './classification';
 import { ClipMode, IClipBox } from './clipping';
@@ -516,7 +517,7 @@ export class PointCloudMaterial extends RawShaderMaterial {
 
   updateMaterial(
     octree: PointCloudOctree,
-    visibleNodes: PointCloudOctreeNode[],
+    visibleNodes: IPointCloudTreeNodeBase[],
     camera: Camera,
     renderer: WebGLRenderer,
   ): void {
@@ -548,7 +549,7 @@ export class PointCloudMaterial extends RawShaderMaterial {
     }
   }
 
-  private updateVisibilityTextureData(nodes: PointCloudOctreeNode[]) {
+  private updateVisibilityTextureData(nodes: IPointCloudTreeNodeBase[]) {
     nodes.sort(byLevelAndIndex);
 
     const data = new Uint8Array(nodes.length * 4);
@@ -588,7 +589,7 @@ export class PointCloudMaterial extends RawShaderMaterial {
 
   static makeOnBeforeRender(
     octree: PointCloudOctree,
-    node: PointCloudOctreeNode,
+    node: IPointCloudTreeNode,
     pcIndex?: number,
   ) {
     return (
diff --git a/src/materials/index.ts b/src/materials/index.ts
index d2002d2..b79302c 100644
--- a/src/materials/index.ts
+++ b/src/materials/index.ts
@@ -1,7 +1,7 @@
 export * from './blur-material';
 export * from './clipping';
 export * from './enums';
-export * from './point-cloud-material';
+export * from './PointCloudMaterial';
 export * from './texture-generation';
 export * from './types';
 export * from './gradients';
diff --git a/src/point-cloud-tree.ts b/src/point-cloud-tree.ts
deleted file mode 100644
index 62274cd..0000000
--- a/src/point-cloud-tree.ts
+++ /dev/null
@@ -1,10 +0,0 @@
-import { Object3D } from 'three';
-import { IPointCloudTreeNode } from './types';
-
-export class PointCloudTree extends Object3D {
-  root: IPointCloudTreeNode | null = null;
-
-  initialized() {
-    return this.root !== null;
-  }
-}
diff --git a/src/potree.ts b/src/potree.ts
index 0f0a876..4c4c1a2 100644
--- a/src/potree.ts
+++ b/src/potree.ts
@@ -17,14 +17,18 @@ import {
   PERSPECTIVE_CAMERA,
 } from './constants';
 import { FEATURES } from './features';
-import { GetUrlFn, loadPOC } from './loading';
+import { GetUrlFn /* , loadPOC */ } from './loading';
+import { EptLoader } from './loading/EptLoader';
 import { ClipMode } from './materials';
-import { PointCloudOctree } from './point-cloud-octree';
-import { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';
-import { PointCloudOctreeNode } from './point-cloud-octree-node';
-import { PickParams, PointCloudOctreePicker } from './point-cloud-octree-picker';
+import { PointCloudOctree } from './PointCloudOctree';
+import { PointCloudOctreeGeometryNode } from './PointCloudOctreeGeometryNode';
+import { PointCloudOctreeNode } from './PointCloudOctreeNode';
+// import { IPointCloudOctree } from './IPointCloudOctree';
+import { PickParams, PointCloudOctreePicker } from './PointCloudOctreePicker';
 import { isGeometryNode, isTreeNode } from './type-predicates';
-import { IPointCloudTreeNode, IPotree, IVisibilityUpdateResult, PickPoint } from './types';
+import { IPotree, IVisibilityUpdateResult, PickPoint } from './types';
+import { IPointCloudTreeNodeBase } from './types/IPointCloudTreeNodeBase';
+import { IPointCloudTreeNode } from './types/IPointCloudTreeNode';
 import { BinaryHeap } from './utils/binary-heap';
 import { Box3Helper } from './utils/box3-helper';
 import { LRU } from './utils/lru';
@@ -33,8 +37,8 @@ export class QueueItem {
   constructor(
     public pointCloudIndex: number,
     public weight: number,
-    public node: IPointCloudTreeNode,
-    public parent?: IPointCloudTreeNode | null,
+    public node: IPointCloudTreeNodeBase,
+    public parent?: IPointCloudTreeNodeBase | null,
   ) {}
 }
 
@@ -47,12 +51,15 @@ export class Potree implements IPotree {
   features = FEATURES;
   lru = new LRU(this._pointBudget);
 
-  loadPointCloud(
+  async loadPointCloud(
     url: string,
     getUrl: GetUrlFn,
-    xhrRequest = (input: RequestInfo, init?: RequestInit) => fetch(input, init),
+    _xhrRequest = (input: RequestInfo, init?: RequestInit) => fetch(input, init),
   ): Promise<PointCloudOctree> {
-    return loadPOC(url, getUrl, xhrRequest).then(geometry => new PointCloudOctree(this, geometry));
+
+    return EptLoader.load(await getUrl(url)).then(geometry => new PointCloudOctree(this, geometry) );
+    // throw Error("Tried using url = " + url);
+    // return loadPOC(url, getUrl, xhrRequest).then(geometry => new PointCloudOctree(this, geometry));
   }
 
   updatePointClouds(
@@ -200,8 +207,8 @@ export class Potree implements IPotree {
 
   private updateTreeNodeVisibility(
     pointCloud: PointCloudOctree,
-    node: PointCloudOctreeNode,
-    visibleNodes: IPointCloudTreeNode[],
+    node: IPointCloudTreeNode,
+    visibleNodes: IPointCloudTreeNodeBase[],
   ): void {
     this.lru.touch(node.geometryNode);
 
@@ -265,7 +272,7 @@ export class Potree implements IPotree {
 
   private updateBoundingBoxVisibility(
     pointCloud: PointCloudOctree,
-    node: PointCloudOctreeNode,
+    node: IPointCloudTreeNode,
   ): void {
     if (pointCloud.showBoundingBox && !node.boundingBoxNode) {
       const boxHelper = new Box3Helper(node.boundingBox);
@@ -357,12 +364,18 @@ export class Potree implements IPotree {
 
         if (pointCloud.visible && pointCloud.root !== null) {
           const weight = Number.MAX_VALUE;
-          priorityQueue.push(new QueueItem(i, weight, pointCloud.root));
+          priorityQueue.push(new QueueItem(i, weight, pointCloud.root!));
         }
 
         // Hide any previously visible nodes. We will later show only the needed ones.
         if (isTreeNode(pointCloud.root)) {
-          pointCloud.hideDescendants(pointCloud.root.sceneNode);
+          console.log("Point cloud root: ", pointCloud.root);
+          console.log("Scene node: ", pointCloud.root!.sceneNode);
+          try {
+            pointCloud.hideDescendants(pointCloud.root!.sceneNode);
+          } catch (e) {
+            console.log("AAAAAH");
+          }
         }
 
         for (const boundingBoxNode of pointCloud.boundingBoxNodes) {
diff --git a/src/type-predicates.ts b/src/type-predicates.ts
index 894ce24..2ef6f2e 100644
--- a/src/type-predicates.ts
+++ b/src/type-predicates.ts
@@ -1,10 +1,11 @@
-import { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';
-import { PointCloudOctreeNode } from './point-cloud-octree-node';
+import { IPointCloudTreeNodeBase } from 'types/IPointCloudTreeNodeBase';
+import { PointCloudOctreeGeometryNode } from './PointCloudOctreeGeometryNode';
+import { PointCloudOctreeNode } from './PointCloudOctreeNode';
 
 export function isGeometryNode(node?: any): node is PointCloudOctreeGeometryNode {
   return node !== undefined && node !== null && node.isGeometryNode;
 }
 
-export function isTreeNode(node?: any): node is PointCloudOctreeNode {
+export function isTreeNode(node?: IPointCloudTreeNodeBase): boolean /* : node is PointCloudOctreeNode */ {
   return node !== undefined && node !== null && node.isTreeNode;
 }
diff --git a/src/types.ts b/src/types.ts
index 97e5988..dfb8092 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -1,28 +1,11 @@
-import { Box3, Camera, Sphere, Vector3, WebGLRenderer } from 'three';
+import { Camera, Vector3, WebGLRenderer } from 'three';
 import { GetUrlFn, XhrRequest } from './loading/types';
-import { PointCloudOctree } from './point-cloud-octree';
 import { LRU } from './utils/lru';
-
-export interface IPointCloudTreeNode {
-  id: number;
-  name: string;
-  level: number;
-  index: number;
-  spacing: number;
-  boundingBox: Box3;
-  boundingSphere: Sphere;
-  loaded: boolean;
-  numPoints: number;
-  readonly children: ReadonlyArray<IPointCloudTreeNode | null>;
-  readonly isLeafNode: boolean;
-
-  dispose(): void;
-
-  traverse(cb: (node: IPointCloudTreeNode) => void, includeSelf?: boolean): void;
-}
+import { PointCloudOctree } from './PointCloudOctree';
+import { IPointCloudTreeNodeBase } from './types/IPointCloudTreeNodeBase';
 
 export interface IVisibilityUpdateResult {
-  visibleNodes: IPointCloudTreeNode[];
+  visibleNodes: IPointCloudTreeNodeBase[];
   numVisiblePoints: number;
   /**
    * True when a node has been loaded but was not added to the scene yet.
diff --git a/src/types/IPointCloudTreeGeometryNode.ts b/src/types/IPointCloudTreeGeometryNode.ts
new file mode 100644
index 0000000..6d74a53
--- /dev/null
+++ b/src/types/IPointCloudTreeGeometryNode.ts
@@ -0,0 +1,11 @@
+/*!
+ * Copyright 2022 Cognite AS
+ */
+
+import { IPointCloudTreeNodeBase } from './IPointCloudTreeNodeBase';
+import * as THREE from 'three';
+
+export interface IPointCloudTreeGeometryNode extends IPointCloudTreeNodeBase {
+  geometry: THREE.BufferGeometry | undefined;
+  oneTimeDisposeHandlers: (() => void)[];
+};
diff --git a/src/types/IPointCloudTreeNode.ts b/src/types/IPointCloudTreeNode.ts
new file mode 100644
index 0000000..82115d4
--- /dev/null
+++ b/src/types/IPointCloudTreeNode.ts
@@ -0,0 +1,13 @@
+/*!
+ * Copyright 2022 Cognite AS
+ */
+
+import { IPointCloudTreeNodeBase } from './IPointCloudTreeNodeBase';
+import { IPointCloudTreeGeometryNode } from './IPointCloudTreeGeometryNode';
+
+import * as THREE from 'three';
+
+export interface IPointCloudTreeNode extends IPointCloudTreeNodeBase {
+  sceneNode: THREE.Points;
+  geometryNode: IPointCloudTreeGeometryNode;
+};
diff --git a/src/types/IPointCloudTreeNodeBase.ts b/src/types/IPointCloudTreeNodeBase.ts
new file mode 100644
index 0000000..309a700
--- /dev/null
+++ b/src/types/IPointCloudTreeNodeBase.ts
@@ -0,0 +1,25 @@
+
+import * as THREE from 'three';
+
+
+export interface IPointCloudTreeNodeBase {
+  id: number;
+  name: string;
+  level: number;
+  index: number;
+  spacing: number;
+  boundingBox: THREE.Box3;
+  boundingSphere: THREE.Sphere;
+  loaded: boolean;
+  numPoints: number;
+  isTreeNode: boolean;
+
+  boundingBoxNode?: THREE.Object3D;
+
+  readonly children: Array<IPointCloudTreeNodeBase | null>;
+  readonly isLeafNode: boolean;
+
+  dispose(): void;
+
+  traverse(cb: (node: IPointCloudTreeNodeBase) => void, includeSelf?: boolean): void;
+}
diff --git a/src/utils/WorkerPool.ts b/src/utils/WorkerPool.ts
new file mode 100644
index 0000000..ef8b9da
--- /dev/null
+++ b/src/utils/WorkerPool.ts
@@ -0,0 +1,29 @@
+
+class WorkerPool{
+  private readonly _workers: any;
+
+  constructor(){
+    this._workers = {};
+  }
+
+  getWorker(url: string){
+    if (!this._workers[url]){
+      this._workers[url] = [];
+    }
+
+    if (this._workers[url].length === 0){
+      let worker = new Worker(url);
+      this._workers[url].push(worker);
+    }
+
+    let worker = this._workers[url].pop();
+
+    return worker;
+  }
+
+  returnWorker(url: string, worker: any){
+    this._workers[url].push(worker);
+  }
+};
+
+export const workerPool = new WorkerPool();
diff --git a/src/utils/XHRFactory.ts b/src/utils/XHRFactory.ts
new file mode 100644
index 0000000..fb4d342
--- /dev/null
+++ b/src/utils/XHRFactory.ts
@@ -0,0 +1,32 @@
+
+const XHRFactory = {
+  config: {
+    withCredentials: false,
+    customHeaders: [
+      { header: null, value: null }
+    ]
+  },
+
+  createXMLHttpRequest: function () {
+    let xhr = new XMLHttpRequest();
+
+    if (this.config.customHeaders &&
+      Array.isArray(this.config.customHeaders) &&
+      this.config.customHeaders.length > 0) {
+      let baseOpen = xhr.open;
+      let customHeaders = this.config.customHeaders;
+      xhr.open = function () {
+	baseOpen.apply(this, ([] as any).slice.call(arguments));
+	customHeaders.forEach(function (customHeader: any) {
+	  if (!!customHeader.header && !!customHeader.value) {
+	    xhr.setRequestHeader(customHeader.header, customHeader.value);
+	  }
+	});
+      };
+    }
+
+    return xhr;
+  }
+};
+
+export { XHRFactory };
diff --git a/src/utils/lru.ts b/src/utils/lru.ts
index c134424..a0e0cb9 100644
--- a/src/utils/lru.ts
+++ b/src/utils/lru.ts
@@ -1,6 +1,6 @@
-import { IPointCloudTreeNode } from '../types';
+import { IPointCloudTreeNodeBase } from "../types/IPointCloudTreeNodeBase";
 
-export type Node = IPointCloudTreeNode;
+export type Node = IPointCloudTreeNodeBase;
 
 export class LRUItem {
   next: LRUItem | null = null;
diff --git a/src/utils/utils.ts b/src/utils/utils.ts
index 7c67c33..848d5a2 100644
--- a/src/utils/utils.ts
+++ b/src/utils/utils.ts
@@ -1,4 +1,4 @@
-import { IPointCloudTreeNode } from '../types';
+import { IPointCloudTreeNodeBase } from "../types/IPointCloudTreeNodeBase";
 
 export function getIndexFromName(name: string) {
   return parseInt(name.charAt(name.length - 1), 10);
@@ -7,7 +7,7 @@ export function getIndexFromName(name: string) {
 /**
  * When passed to `[].sort`, sorts the array by level and index: r, r0, r3, r4, r01, r07, r30, ...
  */
-export function byLevelAndIndex(a: IPointCloudTreeNode, b: IPointCloudTreeNode) {
+export function byLevelAndIndex(a: IPointCloudTreeNodeBase, b: IPointCloudTreeNodeBase) {
   const na = a.name;
   const nb = b.name;
   if (na.length !== nb.length) {
diff --git a/src/workers/EptBinaryDecoderWorker.js b/src/workers/EptBinaryDecoderWorker.js
new file mode 100644
index 0000000..b71e11d
--- /dev/null
+++ b/src/workers/EptBinaryDecoderWorker.js
@@ -0,0 +1,5 @@
+// importScripts('/libs/ept/ParseBuffer.js');
+onmessage = function(event) {
+	parseEpt(event);
+}
+
diff --git a/src/workers/binary-decoder-worker-internal.ts b/src/workers/binary-decoder-worker-internal.ts
index 2577cac..2ec699d 100644
--- a/src/workers/binary-decoder-worker-internal.ts
+++ b/src/workers/binary-decoder-worker-internal.ts
@@ -8,7 +8,7 @@ import {
   IPointAttributes,
   PointAttributeName,
   POINT_ATTRIBUTES,
-} from '../point-attributes';
+} from '../PointAttributes';
 import { Version } from '../version';
 import { CustomArrayView } from './custom-array-view';
 
