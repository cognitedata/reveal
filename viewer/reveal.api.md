## API Report File for "@cognite/reveal"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AnnotationModel } from '@cognite/sdk';
import { AnnotationsAssetRef } from '@cognite/sdk';
import { AnnotationsCogniteAnnotationTypesImagesAssetLink } from '@cognite/sdk';
import { AnnotationStatus } from '@cognite/sdk';
import { Box3 } from 'three';
import { Camera } from 'three';
import { CogniteClient } from '@cognite/sdk';
import { CogniteInternalId } from '@cognite/sdk';
import { Color } from 'three';
import { EventDispatcher } from 'three';
import { IdEither } from '@cognite/sdk';
import { ListResponse } from '@cognite/sdk';
import { Matrix4 } from 'three';
import { Node3D } from '@cognite/sdk';
import { Object3D } from 'three';
import { OrthographicCamera } from 'three';
import { PerspectiveCamera } from 'three';
import { Plane } from 'three';
import { Quaternion } from 'three';
import { Raycaster } from 'three';
import { Texture } from 'three';
import * as THREE from 'three';
import { Vector2 } from 'three';
import { Vector3 } from 'three';
import type { WebGLRenderer } from 'three';
import type { WebGLRenderTarget } from 'three';

// @public
export type AbsolutePosition = {
    xAbsolute: number;
    yAbsolute: number;
};

// @public (undocumented)
export type AddImage360Options = {
    collectionTransform?: Matrix4;
    preMultipliedRotation?: boolean;
    annotationFilter?: Image360AnnotationFilterOptions;
};

// @public
export type AddModelOptions<T extends DataSourceType = ClassicDataSourceType> = CommonModelOptions & T['modelIdentifier'];

// @public
export class AnnotationIdPointCloudObjectCollection extends PointCloudAnnotationVolumeCollection {
    constructor(ids: Iterable<number>);
    // (undocumented)
    getAnnotationIds(): Iterable<number>;
    // (undocumented)
    get isLoading(): false;
}

// @beta
export type AnyIntersection<T extends DataSourceType = DataSourceType> = CadIntersection | PointCloudIntersection<T> | Image360IconIntersection<T> | CustomObjectIntersection;

// @public
export interface AreaCollection {
    addAreas(boxes: Iterable<Box3>): void;
    areas(): Generator<Box3>;
    intersectsBox(box: Box3): boolean;
    intersectWith(boxes: Iterable<Box3>): void;
    // (undocumented)
    readonly isEmpty: boolean;
}

// @public
export type AssetAnnotationImage360Info<T extends DataSourceType = ClassicDataSourceType> = {
    annotationInfo: InstanceLinkable360ImageAnnotationType<T>;
    imageEntity: Image360<T>;
    imageRevision: Image360Revision<T>;
};

// @public
export class AssetNodeCollection extends NodeCollection {
    constructor(client: CogniteClient, modelMetadataProvider: CdfModelNodeCollectionDataProvider);
    // (undocumented)
    static readonly classToken = "AssetNodeCollection";
    // (undocumented)
    clear(): void;
    executeFilter(filter: {
        assetId?: number;
        boundingBox?: THREE.Box3;
    }): Promise<void>;
    // (undocumented)
    getAreas(): AreaCollection;
    // (undocumented)
    getFilter(): {
        assetId?: number | undefined;
        boundingBox?: THREE.Box3 | undefined;
    } | undefined;
    // (undocumented)
    getIndexSet(): IndexSet;
    // (undocumented)
    get isLoading(): boolean;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @public
export type AxisBoxCompassConfig = {
    ringLabel?: string;
    labelDelta?: number;
    fontSize?: number;
    fontColor?: THREE.Color;
    tickColor?: THREE.Color;
};

// @public
export type AxisBoxConfig = {
    size?: number;
    position?: AbsolutePosition | RelativePosition;
    animationSpeed?: number;
    faces?: {
        xPositiveFace?: AxisBoxFaceConfig;
        xNegativeFace?: AxisBoxFaceConfig;
        yPositiveFace?: AxisBoxFaceConfig;
        yNegativeFace?: AxisBoxFaceConfig;
        zPositiveFace?: AxisBoxFaceConfig;
        zNegativeFace?: AxisBoxFaceConfig;
    };
    compass?: AxisBoxCompassConfig;
};

// @public
export type AxisBoxFaceConfig = {
    label?: string;
    fontSize?: number;
    fontColor?: THREE.Color;
    outlineSize?: number;
    outlineColor?: THREE.Color;
    faceColor?: THREE.Color;
};

// @beta
export class AxisGizmoOptions {
    // (undocumented)
    animationDuration: number;
    // (undocumented)
    bobbleLineWidth: number;
    // (undocumented)
    bubbleRadius: number;
    // (undocumented)
    corner: Corner;
    // (undocumented)
    darkColors: number[];
    // (undocumented)
    focusCircleAlpha: number;
    // (undocumented)
    focusCircleColor: string;
    // (undocumented)
    fontFamily: string;
    // (undocumented)
    fontSize: string;
    // (undocumented)
    fontWeight: string;
    // (undocumented)
    fontYAdjust: number;
    getFont(): string;
    // (undocumented)
    insideMargin: number;
    // (undocumented)
    lightColors: number[];
    // (undocumented)
    normalTextColor: string;
    // (undocumented)
    primaryLineWidth: number;
    // (undocumented)
    get radius(): number;
    // (undocumented)
    secondaryLineWidth: number;
    // (undocumented)
    selectedTextColor: string;
    // (undocumented)
    size: number;
    // (undocumented)
    useGeoLabels: boolean;
    // (undocumented)
    xMargin: number;
    // (undocumented)
    yMargin: number;
    // (undocumented)
    yUp: boolean;
}

// @beta
export class AxisGizmoTool extends Cognite3DViewerToolBase {
    constructor(option?: AxisGizmoOptions);
    connect(viewer: Cognite3DViewer<DataSourceType>): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    get options(): AxisGizmoOptions;
}

// @public (undocumented)
export class AxisViewTool extends Cognite3DViewerToolBase {
    constructor(viewer: Cognite3DViewer, config?: AxisBoxConfig);
    // (undocumented)
    dispose(): void;
}

// @public
export type BeforeSceneRenderedDelegate = (event: {
    frameNumber: number;
    renderer: WebGLRenderer;
    camera: PerspectiveCamera;
}) => void;

// @public (undocumented)
export interface BinaryFileProvider {
    // (undocumented)
    getBinaryFile(baseUrl: string, fileName: string, abortSignal?: AbortSignal): Promise<ArrayBuffer>;
}

// @public (undocumented)
export interface BlobOutputMetadata {
    // (undocumented)
    blobId: number;
    // (undocumented)
    format: File3dFormat | string;
    // (undocumented)
    version: number;
}

// @public (undocumented)
export class BoundingBoxClipper {
    constructor(box?: THREE.Box3);
    // (undocumented)
    get clippingPlanes(): THREE.Plane[];
    set maxX(x: number);
    // (undocumented)
    get maxX(): number;
    set maxY(y: number);
    // (undocumented)
    get maxY(): number;
    set maxZ(z: number);
    // (undocumented)
    get maxZ(): number;
    set minX(x: number);
    // (undocumented)
    get minX(): number;
    set minY(y: number);
    // (undocumented)
    get minY(): number;
    set minZ(z: number);
    // (undocumented)
    get minZ(): number;
}

// @public (undocumented)
export type CadIntersection = {
    type: 'cad';
    model: CogniteCadModel;
    point: Vector3;
    treeIndex: number;
    distanceToCamera: number;
};

// @public
export type CadModelBudget = {
    readonly highDetailProximityThreshold: number;
    readonly maximumRenderCost: number;
};

// @public
export const CAMERA_MANAGER_EVENT_TYPE_LIST: readonly ["cameraChange", "cameraStop"];

// @public
export type CameraChangeDelegate = (position: Vector3, target: Vector3) => void;

// @public
export type CameraConfiguration = {
    readonly position: Vector3;
    readonly target: Vector3;
};

// @public (undocumented)
export type CameraControlsOptions = {
    mouseWheelAction?: 'zoomToTarget' | 'zoomPastCursor' | 'zoomToCursor';
    changeCameraTargetOnClick?: boolean;
    changeCameraPositionOnDoubleClick?: boolean;
};

// @public
export type CameraEventDelegate = CameraChangeDelegate | CameraStopDelegate;

// @public
export interface CameraManager {
    activate(cameraManager?: CameraManager): void;
    deactivate(): void;
    // (undocumented)
    dispose(): void;
    fitCameraToBoundingBox(boundingBox: Box3, duration?: number, radiusFactor?: number): void;
    getCamera(): PerspectiveCamera;
    getCameraState(): Required<CameraState>;
    off(event: 'cameraChange', callback: CameraChangeDelegate): void;
    // (undocumented)
    off(event: 'cameraStop', callback: CameraStopDelegate): void;
    // (undocumented)
    off(event: CameraManagerEventType, callback: CameraEventDelegate): void;
    on(event: 'cameraChange', callback: CameraChangeDelegate): void;
    // (undocumented)
    on(event: 'cameraStop', callback: CameraStopDelegate): void;
    // (undocumented)
    on(event: CameraManagerEventType, callback: CameraEventDelegate): void;
    setCameraState(state: CameraState): void;
    update(deltaTime: number, boundingBox: Box3): void;
}

// @public
export type CameraManagerEventType = (typeof CAMERA_MANAGER_EVENT_TYPE_LIST)[number];

// @public
export class CameraManagerHelper {
    static calculateCameraStateToFitBoundingBox(camera: PerspectiveCamera, boundingBox: Box3, radiusFactor?: number): {
        position: Vector3;
        target: Vector3;
    };
    static calculateNewRotationFromTarget(camera: PerspectiveCamera, newTarget: Vector3): Quaternion;
    static calculateNewTargetFromRotation(camera: PerspectiveCamera, rotation: Quaternion, currentTarget: Vector3, position: Vector3): Vector3;
    // @deprecated
    static updateCameraNearAndFar(camera: PerspectiveCamera, boundingBox: Box3): void;
    updateCameraNearAndFar(camera: PerspectiveCamera, boundingBox: Box3): void;
}

// @public (undocumented)
export type CameraState = {
    position?: Vector3;
    target?: Vector3;
    rotation?: Quaternion;
};

// @public
export type CameraStopDelegate = () => void;

// @public
export const CDF_TO_VIEWER_TRANSFORMATION: Matrix4;

// @public
export class CdfModelIdentifier implements ModelIdentifier {
    constructor(modelId: number, revisionId: number);
    // (undocumented)
    readonly modelId: number;
    // (undocumented)
    readonly revealInternalId: symbol;
    // (undocumented)
    readonly revisionId: number;
    // (undocumented)
    toString(): string;
}

// @public
export interface CdfModelNodeCollectionDataProvider {
    getCdfToDefaultModelTransformation(out?: THREE.Matrix4): THREE.Matrix4;
    getModelTransformation(out?: THREE.Matrix4): THREE.Matrix4;
    modelId: number;
    nodeCount: number;
    // (undocumented)
    revisionId: number;
}

// @public (undocumented)
export abstract class CdfNodeCollectionBase extends NodeCollection {
    constructor(classToken: string, model: CdfModelNodeCollectionDataProvider);
    clear(): void;
    // (undocumented)
    getAreas(): AreaCollection;
    // (undocumented)
    getIndexSet(): IndexSet;
    // (undocumented)
    get isLoading(): boolean;
    // (undocumented)
    protected updateCollectionFromResults(requests: Promise<ListResponse<Node3D[]>>[]): Promise<void>;
}

// @public
export type ClassicAddModelOptions = AddModelOptions<ClassicDataSourceType>;

// @public
export type ClassicDataSourceType = {
    modelIdentifier: ClassicModelIdentifierType;
    pointCloudVolumeMetadata: {
        annotationId: number;
        assetRef?: AnnotationsAssetRef;
    };
    pointCloudCollectionType: PointCloudAnnotationVolumeCollection;
    image360Identifier: {
        [key: string]: string;
    } | Image360DataModelIdentifier;
    image360AnnotationType: AnnotationModel;
    _never: never;
};

// @public
export type ClassicModelIdentifierType = {
    modelId: number;
    revisionId: number;
};

// @public (undocumented)
export type ClippingPlanesState = {
    nx: number;
    ny: number;
    nz: number;
    constant: number;
};

// @beta
export class ClosestGeometryFinder<T> {
    constructor(origin: Vector3);
    add(point: Vector3, geometry: T): boolean;
    addLazy(point: Vector3, geometryCreator: () => T): boolean;
    clear(): void;
    getClosestGeometry(): T | undefined;
    isClosest(point: Vector3): boolean;
    set minDistance(value: number);
    get minDistance(): number;
    setClosestGeometry(geometry: T): void;
}

// @public
export class ClusteredAreaCollection implements AreaCollection {
    // (undocumented)
    addAreas(boxes: Iterable<Box3>): void;
    // (undocumented)
    areas(): Generator<Box3>;
    // (undocumented)
    intersectsBox(box: Box3): boolean;
    // (undocumented)
    intersectWith(boxes: Iterable<Box3>): void;
    // (undocumented)
    get isEmpty(): boolean;
}

// @public (undocumented)
export class Cognite3DViewer<DataSourceT extends DataSourceType = ClassicDataSourceType> {
    constructor(options: Cognite3DViewerOptions);
    add360ImageSet(datasource: 'datamodels', dataModelIdentifier: Image360DataModelIdentifier): Promise<Image360Collection<DataSourceT & ClassicDataSourceType>>;
    add360ImageSet(datasource: 'events', eventFilter: {
        [key: string]: string;
    }, add360ImageOptions?: AddImage360Options): Promise<Image360Collection<DataSourceT & ClassicDataSourceType>>;
    addCadModel<T extends DataSourceT>(options: AddModelOptions<T>): Promise<CogniteCadModel>;
    // @beta
    addCustomObject(customObject: ICustomObject): void;
    addModel(options: AddModelOptions<DataSourceT>): Promise<CogniteModel<DataSourceT>>;
    addObject3D(object: THREE.Object3D): void;
    addPointCloudModel(options: AddModelOptions<DataSourceT>): Promise<CognitePointCloudModel<DataSourceT>>;
    get cadBudget(): CadModelBudget;
    set cadBudget(budget: CadModelBudget);
    // (undocumented)
    get cameraManager(): CameraManager;
    // @beta
    canDoImage360Action(action: Image360Action): boolean;
    get canvas(): HTMLCanvasElement;
    // @beta
    createCustomObjectIntersectInput(pixelCoords: THREE.Vector2): CustomObjectIntersectInput;
    determineModelType(modelId: number, revisionId: number): Promise<SupportedModelTypes | ''>;
    dispose(): void;
    get domElement(): HTMLElement;
    enter360Image(image360: Image360<DataSourceT>, revision?: Image360Revision<DataSourceT>): Promise<void>;
    exit360Image(): void;
    fitCameraToBoundingBox(boundingBox: THREE.Box3, duration?: number, radiusFactor?: number): void;
    fitCameraToModel(model: CogniteModel<DataSourceT>, duration?: number): void;
    fitCameraToModels(models?: CogniteModel<DataSourceT>[], duration?: number, restrictToMostGeometry?: boolean): void;
    fitCameraToVisualSceneBoundingBox(duration?: number): void;
    get360AnnotationIntersectionFromPixel(offsetX: number, offsetY: number): Promise<null | Image360AnnotationIntersection<DataSourceT>>;
    get360ImageCollections(): Image360Collection<DataSourceT>[];
    getActive360ImageInfo(): Image360WithCollection<DataSourceT> | undefined;
    // @beta
    getAnyIntersectionFromPixel(pixelCoords: THREE.Vector2, options?: {
        stopOnHitting360Icon?: boolean;
        predicate?: (customObject: ICustomObject) => boolean;
    }): Promise<AnyIntersection<DataSourceT> | undefined>;
    // @deprecated
    getClippingPlanes(): THREE.Plane[];
    getGlobalClippingPlanes(): THREE.Plane[];
    getIntersectionFromPixel(offsetX: number, offsetY: number): Promise<null | Intersection<DataSourceT>>;
    getNormalizedPixelCoordinates(pixelCoords: THREE.Vector2): THREE.Vector2;
    getPixelCoordinatesFromEvent(event: PointerEvent | WheelEvent): THREE.Vector2;
    // @beta
    getSceneBoundingBox(): THREE.Box3;
    getScreenshot(width?: number, height?: number, includeUI?: boolean): Promise<string>;
    getVersion(): string;
    getViewState(): ViewerState;
    // @beta
    getVisualSceneBoundingBox(): THREE.Box3;
    // @beta
    image360Action(action: Image360Action): Promise<void>;
    loadCameraFromModel(model: CogniteModel<DataSourceT>): void;
    get models(): CogniteModel<DataSourceT>[];
    // (undocumented)
    off(event: 'click' | 'hover', callback: PointerEventDelegate): void;
    // (undocumented)
    off(event: 'cameraChange', callback: CameraChangeDelegate): void;
    // (undocumented)
    off(event: 'cameraStop', callback: CameraStopDelegate): void;
    off(event: 'beforeSceneRendered', callback: BeforeSceneRenderedDelegate): void;
    // (undocumented)
    off(event: 'sceneRendered', callback: SceneRenderedDelegate): void;
    // (undocumented)
    off(event: 'disposed', callback: DisposedDelegate): void;
    on(event: 'disposed', callback: DisposedDelegate): void;
    // (undocumented)
    on(event: 'click' | 'hover', callback: PointerEventDelegate): void;
    // (undocumented)
    on(event: 'cameraChange', callback: CameraChangeDelegate): void;
    // (undocumented)
    on(event: 'cameraStop', callback: CameraStopDelegate): void;
    on(event: 'beforeSceneRendered', callback: BeforeSceneRenderedDelegate): void;
    on(event: 'sceneRendered', callback: SceneRenderedDelegate): void;
    // @beta
    onClick360Images(event: PointerEvent): Promise<boolean>;
    // @beta
    onHover360Images(event: PointerEvent): boolean;
    get pointCloudBudget(): PointCloudBudget;
    set pointCloudBudget(budget: PointCloudBudget);
    // @deprecated
    remove360Images(...image360Entities: Image360<DataSourceT>[]): Promise<void>;
    remove360ImageSet(imageCollection: Image360Collection<DataSourceT>): void;
    // @beta
    removeCustomObject(customObject: ICustomObject): void;
    removeModel(model: CogniteModel<DataSourceT>): void;
    removeObject3D(object: THREE.Object3D): void;
    get renderParameters(): RenderParameters;
    requestRedraw(): void;
    setBackgroundColor(backgroundColor: {
        color?: THREE.Color;
        alpha?: number;
    }): void;
    setCameraManager(cameraManager: CameraManager): void;
    // @deprecated
    setClippingPlanes(clippingPlanes: THREE.Plane[]): void;
    setGlobalClippingPlanes(clippingPlanes: THREE.Plane[]): void;
    setLogLevel(level: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'silent' | 'none'): void;
    setResolutionOptions(options: ResolutionOptions): void;
    setViewState(state: ViewerState): Promise<void>;
    worldToScreen(point: THREE.Vector3, normalize?: boolean): THREE.Vector2 | null;
}

// @public
export interface Cognite3DViewerOptions {
    antiAliasingHint?: 'disabled' | 'fxaa' | 'msaa2+fxaa' | 'msaa4+fxaa' | 'msaa8+fxaa' | 'msaa16+fxaa' | 'msaa2' | 'msaa4' | 'msaa8' | 'msaa16';
    cameraManager?: CameraManager;
    continuousModelStreaming?: boolean;
    customDataSource?: DataSource;
    domElement?: HTMLElement;
    enableEdges?: boolean;
    // @beta
    hasEventListeners?: boolean;
    loadingIndicatorStyle?: {
        placement: 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';
        opacity: number;
    };
    logMetrics?: boolean;
    onLoading?: OnLoadingCallback;
    pointCloudEffects?: {
        pointBlending?: boolean;
        edlOptions?: Partial<EdlOptions> | 'disabled';
    };
    renderer?: WebGLRenderer;
    // @deprecated
    rendererResolutionThreshold?: number;
    renderTargetOptions?: {
        target: WebGLRenderTarget;
        autoSetSize?: boolean;
    };
    sdk: CogniteClient;
    ssaoQualityHint?: 'medium' | 'high' | 'veryhigh' | 'disabled';
    // @beta
    useFlexibleCameraManager?: boolean;
}

// @public
export abstract class Cognite3DViewerToolBase {
    dispose(): void;
    protected ensureNotDisposed(): void;
    off(event: 'disposed', handler: () => void): void;
}

// @public
export class CogniteCadModel implements CdfModelNodeCollectionDataProvider {
    assignStyledNodeCollection(nodeCollection: NodeCollection, appearance: NodeAppearance, importance?: number): void;
    dispose(): void;
    getAncestorTreeIndices(treeIndex: number, generation: number): Promise<NumericRange>;
    getBoundingBoxByNodeId(nodeId: number, box?: THREE.Box3): Promise<THREE.Box3>;
    getBoundingBoxByTreeIndex(treeIndex: number, box?: THREE.Box3): Promise<THREE.Box3>;
    getBoundingBoxesByNodeIds(nodeIds: number[]): Promise<THREE.Box3[]>;
    getCameraConfiguration(): CameraConfiguration | undefined;
    getCdfToDefaultModelTransformation(out?: THREE.Matrix4): THREE.Matrix4;
    getDefaultNodeAppearance(): NodeAppearance;
    getModelBoundingBox(outBoundingBox?: THREE.Box3, restrictToMostGeometry?: boolean): THREE.Box3;
    getModelClippingPlanes(): THREE.Plane[];
    getModelTransformation(out?: THREE.Matrix4): THREE.Matrix4;
    getSubtreeTreeIndices(treeIndex: number): Promise<NumericRange>;
    iterateNodesByTreeIndex(action: (treeIndex: number) => void): Promise<void>;
    iterateSubtreeByTreeIndex(treeIndex: number, action: (treeIndex: number) => void): Promise<void>;
    mapBoxFromCdfToModelCoordinates(box: THREE.Box3, out?: THREE.Box3): THREE.Box3;
    mapNodeIdsToTreeIndices(nodeIds: CogniteInternalId[]): Promise<number[]>;
    mapNodeIdToTreeIndex(nodeId: CogniteInternalId): Promise<number>;
    mapPointFromCdfToModelCoordinates(point: THREE.Vector3, out?: THREE.Vector3): THREE.Vector3;
    mapTreeIndexToNodeId(treeIndex: number): Promise<CogniteInternalId>;
    mapTreeIndicesToNodeIds(treeIndices: number[]): Promise<CogniteInternalId[]>;
    readonly modelId: number;
    get modelUnit(): WellKnownUnit | '';
    get modelUnitToMetersFactor(): number | undefined;
    get nodeCount(): number;
    removeAllStyledNodeCollections(): void;
    resetNodeTransform(treeIndices: NumericRange): void;
    resetNodeTransformByTreeIndex(treeIndex: number, applyToChildren?: boolean): Promise<number>;
    readonly revisionId: number;
    setDefaultNodeAppearance(appearance: NodeAppearance): void;
    setModelClippingPlanes(clippingPlanes: THREE.Plane[]): void;
    setModelTransformation(matrix: THREE.Matrix4): void;
    setNodeTransform(treeIndices: NumericRange, transformMatrix: THREE.Matrix4, boundingBox?: THREE.Box3, space?: 'model' | 'world'): void;
    setNodeTransformByTreeIndex(treeIndex: number, transform: THREE.Matrix4, applyToChildren?: boolean, space?: 'model' | 'world'): Promise<number>;
    get styledNodeCollections(): {
        nodeCollection: NodeCollection;
        appearance: NodeAppearance;
    }[];
    // (undocumented)
    readonly type: SupportedModelTypes;
    unassignStyledNodeCollection(nodeCollection: NodeCollection): void;
    set visible(value: boolean);
    get visible(): boolean;
}

// @public
export type CogniteModel<T extends DataSourceType = ClassicDataSourceType> = CogniteCadModel | CognitePointCloudModel<T>;

// @public
export class CognitePointCloudModel<T extends DataSourceType = ClassicDataSourceType> {
    assignStyledObjectCollection(objectCollection: T['pointCloudCollectionType'], appearance: PointCloudAppearance): void;
    dispose(): void;
    getCameraConfiguration(): CameraConfiguration | undefined;
    getCdfToDefaultModelTransformation(out?: THREE.Matrix4): THREE.Matrix4;
    getClasses(): Array<{
        name: string;
        code: number | WellKnownAsprsPointClassCodes;
        color: THREE.Color;
    }>;
    getDefaultPointCloudAppearance(): PointCloudAppearance;
    // (undocumented)
    getModelBoundingBox(outBoundingBox?: THREE.Box3): THREE.Box3;
    getModelClippingPlanes(): THREE.Plane[];
    getModelTransformation(out?: THREE.Matrix4): THREE.Matrix4;
    hasClass(pointClass: number | WellKnownAsprsPointClassCodes): boolean;
    isClassVisible(pointClass: number | WellKnownAsprsPointClassCodes): boolean;
    mapBoxFromCdfToModelCoordinates(box: THREE.Box3, out?: THREE.Box3): THREE.Box3;
    mapPointFromCdfToModelCoordinates(point: THREE.Vector3, out?: THREE.Vector3): THREE.Vector3;
    // @deprecated
    readonly modelId: number;
    readonly modelIdentifier: T['modelIdentifier'];
    get pointColorType(): PointColorType;
    set pointColorType(type: PointColorType);
    get pointShape(): PointShape;
    set pointShape(shape: PointShape);
    get pointSize(): number;
    set pointSize(size: number);
    get pointSizeType(): PointSizeType;
    set pointSizeType(type: PointSizeType);
    removeAllStyledObjectCollections(): void;
    // @deprecated
    readonly revisionId: number;
    setClassVisible(pointClass: number | WellKnownAsprsPointClassCodes, visible: boolean): void;
    setDefaultPointCloudAppearance(appearance: PointCloudAppearance): void;
    setModelClippingPlanes(clippingPlanes: THREE.Plane[]): void;
    setModelTransformation(transformationMatrix: THREE.Matrix4): void;
    // (undocumented)
    get stylableObjectCount(): number;
    get stylableObjects(): PointCloudObjectMetadata<T>[];
    get styledCollections(): StyledPointCloudVolumeCollection<T>[];
    // @deprecated (undocumented)
    traverseStylableObjects(callback: (annotationMetadata: PointCloudObjectMetadata<T>) => void): void;
    // (undocumented)
    readonly type: SupportedModelTypes;
    unassignStyledObjectCollection(objectCollection: T['pointCloudCollectionType']): void;
    set visible(value: boolean);
    get visible(): boolean;
    get visiblePointCount(): number;
}

// @public
export abstract class CombineNodeCollectionBase extends NodeCollection {
    constructor(classToken: string, nodeCollections?: NodeCollection[]);
    // (undocumented)
    add(nodeCollection: NodeCollection): void;
    clear(): void;
    // (undocumented)
    protected abstract createCombinedIndexSet(): IndexSet;
    // (undocumented)
    abstract getAreas(): AreaCollection;
    // @override (undocumented)
    getIndexSet(): IndexSet;
    // @override (undocumented)
    get isLoading(): boolean;
    // (undocumented)
    protected makeDirty(): void;
    // (undocumented)
    protected _nodeCollections: NodeCollection[];
    // (undocumented)
    remove(nodeCollection: NodeCollection): void;
    // (undocumented)
    abstract serialize(): SerializedNodeCollection;
}

// @public (undocumented)
export class ComboControls extends EventDispatcher<ComboControlsEventType> {
    constructor(camera: PerspectiveCamera | OrthographicCamera, domElement: HTMLElement);
    get cameraRawRotation(): Quaternion;
    // (undocumented)
    dispose: () => void;
    get enabled(): boolean;
    set enabled(newEnabledValue: boolean);
    // (undocumented)
    getScrollTarget: () => Vector3;
    // (undocumented)
    getState: () => {
        target: Vector3;
        position: Vector3;
    };
    get options(): Readonly<ComboControlsOptions>;
    set options(options: Partial<ComboControlsOptions>);
    // (undocumented)
    setScrollTarget: (target: Vector3) => void;
    // (undocumented)
    setState: (position: Vector3, target: Vector3) => void;
    // (undocumented)
    setViewTarget: (target: Vector3) => void;
    // (undocumented)
    triggerCameraChangeEvent: () => void;
    // (undocumented)
    update: (deltaTimeS: number, forceUpdate?: boolean) => boolean;
}

// @public
export type ComboControlsEventType = {
    cameraChange: {
        camera: {
            position: Vector3;
            target: Vector3;
        };
    };
};

// @public
export type ComboControlsOptions = {
    enableDamping: boolean;
    dampingFactor: number;
    dynamicTarget: boolean;
    minDistance: number;
    minZoomDistance: number;
    dollyFactor: number;
    minPolarAngle: number;
    maxPolarAngle: number;
    minAzimuthAngle: number;
    maxAzimuthAngle: number;
    panDollyMinDistanceFactor: number;
    firstPersonRotationFactor: number;
    pointerRotationSpeedAzimuth: number;
    pointerRotationSpeedPolar: number;
    enableKeyboardNavigation: boolean;
    keyboardRotationSpeedAzimuth: number;
    keyboardRotationSpeedPolar: number;
    mouseFirstPersonRotationSpeed: number;
    keyboardDollySpeed: number;
    keyboardPanSpeed: number;
    keyboardSpeedFactor: number;
    pinchEpsilon: number;
    pinchPanSpeed: number;
    EPSILON: number;
    minZoom: number;
    maxZoom: number;
    orthographicCameraDollyFactor: number;
    lookAtViewTarget: boolean;
    useScrollTarget: boolean;
    zoomToCursor: boolean;
    minDeltaRatio: number;
    maxDeltaRatio: number;
    minDeltaDownscaleCoefficient: number;
    maxDeltaDownscaleCoefficient: number;
};

// @public
export type CommonModelOptions = {
    localPath?: string;
    geometryFilter?: GeometryFilter;
};

// @public (undocumented)
export type CompletePointCloudAppearance = Required<PointCloudAppearance>;

// @public
export type CoreDmImage360Annotation = {
    sourceType: 'dm';
    annotationIdentifier: DMInstanceRef;
    assetRef?: DMInstanceRef;
    polygon: Vector3[];
    status: 'suggested' | 'approved';
    connectedImageId: DMInstanceRef;
};

// @public
export enum Corner {
    // (undocumented)
    BottomLeft = 2,
    // (undocumented)
    BottomRight = 3,
    // (undocumented)
    TopLeft = 1,
    // (undocumented)
    TopRight = 0
}

// @beta
export class CustomObject implements ICustomObject {
    constructor(object: Object3D);
    beforeRender(_camera: PerspectiveCamera): void;
    getBoundingBox(target: Box3): Box3;
    intersectIfCloser(intersectInput: CustomObjectIntersectInput, closestDistance: number | undefined): undefined | CustomObjectIntersection;
    get isPartOfBoundingBox(): boolean;
    set isPartOfBoundingBox(value: boolean);
    get object(): Object3D;
    get shouldPick(): boolean;
    set shouldPick(value: boolean);
    get shouldPickBoundingBox(): boolean;
    set shouldPickBoundingBox(value: boolean);
    get useDepthTest(): boolean;
    set useDepthTest(value: boolean);
}

// @beta
export class CustomObjectIntersectInput {
    constructor(normalizedCoords: Vector2, camera: PerspectiveCamera, clippingPlanes?: Plane[] | undefined);
    // (undocumented)
    readonly camera: PerspectiveCamera;
    // (undocumented)
    readonly clippingPlanes: Plane[] | undefined;
    // (undocumented)
    isVisible(point: Vector3): boolean;
    // (undocumented)
    readonly normalizedCoords: Vector2;
    // (undocumented)
    readonly raycaster: Raycaster;
}

// @beta
export type CustomObjectIntersection = {
    type: 'customObject';
    point: Vector3;
    distanceToCamera: number;
    customObject: ICustomObject;
    boundingBox?: Box3;
    userData?: any;
};

// @public
export interface DataSource {
    getModelDataProvider(): ModelDataProvider;
    getModelMetadataProvider(): ModelMetadataProvider;
    getNodesApiClient(): NodesApiClient;
}

// @public
export type DataSourceType = ClassicDataSourceType | DMDataSourceType;

// @public
export class DebouncedCameraStopEventTrigger {
    constructor(cameraManager: CameraManager, debounceTimeMs?: number);
    dispose(): void;
    subscribe(callback: CameraStopDelegate): void;
    unsubscribe(callback: CameraStopDelegate): void;
}

// @public (undocumented)
export class DebugCameraTool extends Cognite3DViewerToolBase {
    constructor(viewer: Cognite3DViewer<DataSourceType>);
    // @override
    dispose(): void;
    // (undocumented)
    hideCameraHelper(): void;
    // (undocumented)
    showCameraHelper(): void;
}

// @public
export class DefaultCameraManager implements CameraManager {
    // (undocumented)
    activate(cameraManager?: CameraManager): void;
    automaticControlsSensitivity: boolean;
    automaticNearFarPlane: boolean;
    // (undocumented)
    deactivate(): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    fitCameraToBoundingBox(box: THREE.Box3, duration?: number, radiusFactor?: number): void;
    // (undocumented)
    getCamera(): THREE.PerspectiveCamera;
    getCameraControlsOptions(): CameraControlsOptions;
    // (undocumented)
    getCameraState(): Required<CameraState>;
    getComboControlsOptions(): Readonly<ComboControlsOptions>;
    set keyboardNavigationEnabled(enabled: boolean);
    get keyboardNavigationEnabled(): boolean;
    // (undocumented)
    off(event: CameraManagerEventType, callback: CameraEventDelegate): void;
    // (undocumented)
    on(event: CameraManagerEventType, callback: CameraEventDelegate): void;
    setCameraControlsOptions(controlsOptions: CameraControlsOptions): void;
    setCameraState(state: CameraState): void;
    setComboControlsOptions(options: Partial<ComboControlsOptions>): void;
    // (undocumented)
    update(deltaTime: number, boundingBox: THREE.Box3): void;
}

// @public
export const DefaultNodeAppearance: {
    Default: NodeAppearance;
    Outlined: NodeAppearance;
    Hidden: NodeAppearance;
    InFront: NodeAppearance;
    Ghosted: NodeAppearance;
    Highlighted: {
        color?: Color;
        visible?: boolean;
        renderInFront?: boolean;
        renderGhosted?: boolean;
        outlineColor?: NodeOutlineColor;
        prioritizedForLoadingHint?: number;
    };
};

// @public
export type DefaultOverlay3DContentType = {
    [key: string]: string;
};

// @public (undocumented)
export const DefaultPointCloudAppearance: CompletePointCloudAppearance;

// @public
export type DisposedDelegate = () => void;

// @public
export type DistanceToLabelDelegate = (distanceInMeters: number) => string;

// @public
export type DMAddModelOptions = AddModelOptions<DMDataSourceType>;

// @public
export type DMDataSourceType = {
    pointCloudVolumeMetadata: {
        volumeInstanceRef: DMInstanceRef;
        assetRef?: DMInstanceRef;
    };
    pointCloudCollectionType: PointCloudDMVolumeCollection;
    modelIdentifier: DMModelIdentifierType;
    image360Identifier: Image360DataModelIdentifier;
    image360AnnotationType: CoreDmImage360Annotation;
    _never: never;
};

// @public
export type DMInstanceRef = {
    externalId: string;
    space: string;
};

// @public
export type DMModelIdentifierType = {
    revisionExternalId: string;
    revisionSpace: string;
};

// @public
export type EdlOptions = {
    strength: number;
    radius: number;
};

// @public (undocumented)
export enum File3dFormat {
    // (undocumented)
    AnyFormat = "all-outputs",
    // (undocumented)
    EptPointCloud = "ept-pointcloud",
    GltfCadModel = "gltf-directory"
}

// @beta (undocumented)
export class FlexibleControlsOptions {
    // (undocumented)
    animationDuration: number;
    // (undocumented)
    automaticNearFarPlane: boolean;
    // (undocumented)
    automaticSensitivity: boolean;
    // (undocumented)
    controlsType: FlexibleControlsType;
    // (undocumented)
    dampingFactor: number;
    // (undocumented)
    defaultFov: number;
    // (undocumented)
    enableChangeControlsTypeOn123Key: boolean;
    // (undocumented)
    enableDamping: boolean;
    // (undocumented)
    enableKeyboardNavigation: boolean;
    // (undocumented)
    getKeyboardSpeed(shift: boolean): number;
    // (undocumented)
    getLegalAzimuthAngle(azimuthAngle: number): number;
    // (undocumented)
    getLegalFov(fov: number): number;
    // (undocumented)
    getLegalPolarAngle(polarAngle: number): number;
    // (undocumented)
    getLegalSensitivity(controlsSensitivity: number): number;
    // (undocumented)
    innerMarkerColor: string;
    // (undocumented)
    keyboardDollySpeed: number;
    // (undocumented)
    keyboardFastMoveFactor: number;
    // (undocumented)
    keyboardFastRotationFactor: number;
    // (undocumented)
    keyboardPanSpeed: number;
    // (undocumented)
    keyboardRotationSpeedAzimuth: number;
    // (undocumented)
    keyboardRotationSpeedPolar: number;
    // (undocumented)
    keyboardSpeed: number;
    // (undocumented)
    maxAzimuthAngle: number;
    // (undocumented)
    maximumFov: number;
    // (undocumented)
    maximumTimeBetweenRaycasts: number;
    // (undocumented)
    maxOrthographicZoom: number;
    // (undocumented)
    maxPolarAngle: number;
    // (undocumented)
    maxSensitivity: number;
    // (undocumented)
    minAzimuthAngle: number;
    // (undocumented)
    minimumFov: number;
    // (undocumented)
    minimumTimeBetweenRaycasts: number;
    // (undocumented)
    minOrthographicZoom: number;
    // (undocumented)
    minPolarAngle: number;
    // (undocumented)
    minSensitivity: number;
    // (undocumented)
    mouseClickType: FlexibleMouseActionType;
    // (undocumented)
    mouseDistanceThresholdBetweenRaycasts: number;
    // (undocumented)
    mouseDollySpeed: number;
    // (undocumented)
    mouseDoubleClickType: FlexibleMouseActionType;
    // (undocumented)
    mousePanSpeed: number;
    // (undocumented)
    mouseRotationSpeedAzimuth: number;
    // (undocumented)
    mouseRotationSpeedPolar: number;
    // (undocumented)
    mouseWheelAction: FlexibleWheelZoomType;
    // (undocumented)
    orthographicCameraDollyFactor: number;
    // (undocumented)
    outerMarkerColor: string;
    // (undocumented)
    pinchEpsilon: number;
    // (undocumented)
    pinchPanSpeed: number;
    // (undocumented)
    get realMouseWheelAction(): FlexibleWheelZoomType;
    // (undocumented)
    relativeMarkerSize: number;
    // (undocumented)
    sensitivity: number;
    // (undocumented)
    sensitivityDiagonalFraction: number;
    // (undocumented)
    get shouldPick(): boolean;
    // (undocumented)
    showTarget: boolean;
    // (undocumented)
    wheelDollySpeed: number;
    // (undocumented)
    zoomFraction: number;
}

// @beta (undocumented)
export enum FlexibleControlsType {
    // (undocumented)
    FirstPerson = "firstPerson",
    // (undocumented)
    Orbit = "orbit",
    // (undocumented)
    OrbitInCenter = "orbitInCenter"
}

// @beta (undocumented)
export type FlexibleControlsTypeChangeDelegate = (controlsType: FlexibleControlsType) => void;

// @beta (undocumented)
export enum FlexibleMouseActionType {
    // (undocumented)
    None = "none",
    // (undocumented)
    SetTarget = "setTarget",
    // (undocumented)
    SetTargetAndCameraDirection = "setTargetAndCameraDirection",
    // (undocumented)
    SetTargetAndCameraPosition = "setTargetAndCameraPosition"
}

// @beta
export enum FlexibleWheelZoomType {
    // (undocumented)
    Auto = "auto",
    // (undocumented)
    Center = "center",
    // (undocumented)
    PastCursor = "pastCursor",
    // (undocumented)
    ToCursor = "toCursor"
}

// @public (undocumented)
export type GeometryFilter = {
    boundingBox?: Box3;
    isBoundingBoxInModelCoordinates?: boolean;
};

// @public (undocumented)
export function getNormalizedPixelCoordinates(domElement: HTMLElement, pixelX: number, pixelY: number): THREE.Vector2;

// @public
export function getNormalizedPixelCoordinatesBySize(pixelX: number, pixelY: number, width: number, height: number): THREE.Vector2;

// @beta
export function getWheelEventDelta(event: WheelEvent): number;

// @public
export type HtmlOverlayCreateClusterDelegate = (overlayElements: {
    htmlElement: HTMLElement;
    userData: any;
}[]) => HTMLElement;

// @public
export type HtmlOverlayOptions = {
    positionUpdatedCallback?: HtmlOverlayPositionUpdatedDelegate;
    userData?: any;
};

// @public
export type HtmlOverlayPositionUpdatedDelegate = (element: HTMLElement, position2D: THREE.Vector2, position3D: THREE.Vector3, distanceToCamera: number, userData: any) => void;

// @public
export class HtmlOverlayTool extends Cognite3DViewerToolBase {
    constructor(viewer: Cognite3DViewer<DataSourceType>, options?: HtmlOverlayToolOptions);
    add(htmlElement: HTMLElement, position3D: THREE.Vector3, options?: HtmlOverlayOptions): void;
    clear(): void;
    // @override
    dispose(): void;
    get elements(): {
        element: HTMLElement;
        position3D: THREE.Vector3;
    }[];
    forceUpdate(customCamera?: THREE.PerspectiveCamera): void;
    remove(htmlElement: HTMLElement): void;
    visible(enable: boolean): void;
}

// @public
export type HtmlOverlayToolClusteringOptions = {
    mode: 'overlapInScreenSpace';
    createClusterElementCallback: HtmlOverlayCreateClusterDelegate;
};

// @public
export type HtmlOverlayToolOptions = {
    clusteringOptions?: HtmlOverlayToolClusteringOptions;
};

// @beta
export interface ICustomObject {
    beforeRender(camera: PerspectiveCamera): void;
    getBoundingBox(target: Box3): Box3;
    intersectIfCloser(intersectInput: CustomObjectIntersectInput, closestDistance: number | undefined): undefined | CustomObjectIntersection;
    get isPartOfBoundingBox(): boolean;
    get object(): Object3D;
    get shouldPick(): boolean;
    get shouldPickBoundingBox(): boolean;
    get useDepthTest(): boolean;
}

// @beta
export interface IFlexibleCameraManager extends CameraManager {
    addControlsTypeChangeListener(callback: FlexibleControlsTypeChangeDelegate): void;
    get controlsType(): FlexibleControlsType;
    set controlsType(value: FlexibleControlsType);
    onClick(event: PointerEvent): Promise<void>;
    onDoubleClick(event: PointerEvent): Promise<void>;
    onFocusChanged(haveFocus: boolean): void;
    onKey(event: KeyboardEvent, down: boolean): void;
    onPointerDown(event: PointerEvent, leftButton: boolean): Promise<void>;
    onPointerDrag(event: PointerEvent, leftButton: boolean): Promise<void>;
    onPointerUp(event: PointerEvent, leftButton: boolean): Promise<void>;
    onWheel(event: WheelEvent, delta: number): Promise<void>;
    get options(): FlexibleControlsOptions;
    removeControlsTypeChangeListener(callback: FlexibleControlsTypeChangeDelegate): void;
    rotateCameraTo(direction: Vector3, animationDuration: number): void;
}

// @public
export interface Image360<T extends DataSourceType = ClassicDataSourceType> {
    getActiveRevision(): Image360Revision<T>;
    getIconColor(): Color | 'default';
    getRevisions(): Image360Revision<T>[];
    readonly id: Image360Id<T>;
    readonly image360Visualization: Image360Visualization;
    readonly label: string | undefined;
    setIconColor(color: Color | 'default'): void;
    readonly transform: Matrix4;
}

// @beta
export enum Image360Action {
    Backward = 1,
    Enter = 2,
    Exit = 3,
    Forward = 0
}

// @public
export interface Image360Annotation<T extends DataSourceType = ClassicDataSourceType> {
    readonly annotation: T['image360AnnotationType'];
    getCenter(out?: Vector3): Vector3;
    getColor(): Color;
    getVisible(): boolean;
    setColor(color?: Color): void;
    setVisible(visible?: boolean): void;
}

// @public
export type Image360AnnotationAppearance = {
    color?: Color;
    visible?: boolean;
};

// @public
export type Image360AnnotationAssetFilter<T extends DataSourceType = ClassicDataSourceType> = {
    assetRef: InstanceReference<T>;
};

// @public
export type Image360AnnotationAssetQueryResult<T extends DataSourceType = ClassicDataSourceType> = {
    image: Image360<T>;
    revision: Image360Revision<T>;
    annotation: Image360Annotation<T>;
};

// @public
export type Image360AnnotationFilterOptions = {
    status?: 'all' | AnnotationStatus | AnnotationStatus[];
};

// @public
export type Image360AnnotationIntersection<T extends DataSourceType = ClassicDataSourceType> = {
    type: 'image360Annotation';
    annotation: Image360Annotation<T>;
    direction: Vector3;
};

// @public
export type Image360BaseIdentifier = {
    space: string;
    image360CollectionExternalId: string;
};

// @public
export interface Image360Collection<T extends DataSourceType = ClassicDataSourceType> {
    findImageAnnotations(filter: Image360AnnotationAssetFilter<T>): Promise<Image360AnnotationAssetQueryResult<T>[]>;
    getAnnotationsInfo(source: 'all'): Promise<AssetAnnotationImage360Info<DataSourceType>[]>;
    getAnnotationsInfo(source: 'assets'): Promise<AssetAnnotationImage360Info<ClassicDataSourceType>[]>;
    getAnnotationsInfo(source: 'cdm'): Promise<AssetAnnotationImage360Info<DMDataSourceType>[]>;
    getAnnotationsInfo(source: 'assets' | 'cdm' | 'all'): Promise<AssetAnnotationImage360Info<ClassicDataSourceType>[] | AssetAnnotationImage360Info<DMDataSourceType> | AssetAnnotationImage360Info<DataSourceType>[]>;
    // @deprecated
    getAssetIds(): Promise<IdEither[]>;
    getDefaultAnnotationStyle(): Image360AnnotationAppearance;
    getIconsOpacity(): number;
    getIconsVisibility(): boolean;
    getImagesOpacity(): number;
    getModelTransformation(out?: Matrix4): Matrix4;
    readonly id: string;
    readonly image360Entities: Image360<T>[];
    isOccludedIconsVisible(): boolean;
    readonly label: string | undefined;
    off(event: 'image360Entered', callback: Image360EnteredDelegate<T>): void;
    // (undocumented)
    off(event: 'image360Exited', callback: Image360ExitedDelegate): void;
    on(event: 'image360Entered', callback: Image360EnteredDelegate<T>): void;
    // (undocumented)
    on(event: 'image360Exited', callback: Image360ExitedDelegate): void;
    set360IconCullingRestrictions(radius: number, pointLimit: number): void;
    setDefaultAnnotationStyle(appearance: Image360AnnotationAppearance): void;
    setIconsOpacity(opacity: number): void;
    setIconsVisibility(visible: boolean): void;
    setImagesOpacity(opacity: number): void;
    setModelTransformation(matrix: Matrix4): void;
    setOccludedIconsVisible(visible: boolean): void;
    targetRevisionDate: Date | undefined;
}

// @public
export type Image360CoreDataModelIdentifier = {
    source: 'cdm';
} & Image360BaseIdentifier;

// @public
export type Image360DataModelIdentifier = Image360BaseIdentifier & {
    source?: 'dm' | 'cdm';
};

// @public
export type Image360EnteredDelegate<T extends DataSourceType = ClassicDataSourceType> = (image360: Image360<T>, revision: Image360Revision<T>) => void;

// @public
export type Image360ExitedDelegate = () => void;

// @beta
export type Image360IconIntersection<T extends DataSourceType = DataSourceType> = {
    type: 'image360Icon';
    image360: Image360<T>;
    image360Collection: Image360Collection<T>;
    point: Vector3;
    distanceToCamera: number;
};

// @public
export type Image360IconStyle = {
    color?: Color;
};

// @public
export type Image360Id<T extends DataSourceType> = Image360RevisionId<T>;

// @public
export type Image360LegacyDataModelIdentifier = {
    source: 'dm';
} & Image360BaseIdentifier;

// @public
export interface Image360Revision<T extends DataSourceType = ClassicDataSourceType> {
    readonly date: Date | undefined;
    getAnnotations(): Promise<Image360Annotation<T>[]>;
    getPreviewThumbnailUrl(): Promise<string | undefined>;
}

// @public
export type Image360RevisionId<T extends DataSourceType> = T extends DMDataSourceType ? DMInstanceRef : string;

// @public
export interface Image360Visualization {
    opacity: number;
}

// @public
export type Image360WithCollection<T extends DataSourceType = ClassicDataSourceType> = {
    image360Collection: Image360Collection<T>;
    image360: Image360<T>;
};

// @public
export type ImageAssetLinkAnnotationInfo = Omit<AnnotationModel, 'data'> & {
    data: AnnotationsCogniteAnnotationTypesImagesAssetLink;
};

// @public (undocumented)
export class IndexSet {
    constructor(values?: Iterable<number>);
    constructor(values?: NumericRange);
    // (undocumented)
    add(index: number): void;
    // (undocumented)
    addRange(range: NumericRange): void;
    // (undocumented)
    clear(): void;
    // (undocumented)
    clone(): IndexSet;
    // (undocumented)
    contains(index: number): boolean;
    // (undocumented)
    get count(): number;
    // (undocumented)
    differenceWith(otherSet: IndexSet): IndexSet;
    // (undocumented)
    forEachRange(visitor: (range: NumericRange) => void): void;
    // (undocumented)
    hasIntersectionWith(otherSet: IndexSet | Set<number>): boolean;
    // (undocumented)
    hasIntersectionWithMap(otherMap: Map<number, number>): boolean;
    // (undocumented)
    intersectWith(otherSet: IndexSet): IndexSet;
    // (undocumented)
    invertedRanges(): NumericRange[];
    // (undocumented)
    remove(index: number): void;
    // (undocumented)
    removeRange(range: NumericRange): void;
    // (undocumented)
    toIndexArray(): number[];
    // (undocumented)
    toPlainSet(): Set<number>;
    // (undocumented)
    toRangeArray(): NumericRange[];
    // (undocumented)
    unionWith(otherSet: IndexSet): IndexSet;
}

// @public
export type InstanceLinkable360ImageAnnotationType<T extends DataSourceType> = T extends ClassicDataSourceType ? ImageAssetLinkAnnotationInfo : T['image360AnnotationType'];

// @public
export type InstanceReference<T extends DataSourceType> = T extends ClassicDataSourceType ? IdEither : DMInstanceRef;

// @public
export type Intersection<T extends DataSourceType = ClassicDataSourceType> = CadIntersection | PointCloudIntersection<T>;

// @public
export class IntersectionNodeCollection extends CombineNodeCollectionBase {
    constructor(nodeCollections?: NodeCollection[]);
    // (undocumented)
    static readonly classToken = "IntersectionNodeCollection";
    // (undocumented)
    protected createCombinedIndexSet(): IndexSet;
    // (undocumented)
    getAreas(): AreaCollection;
    // (undocumented)
    makeDirty(): void;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @public
export class InvertedNodeCollection extends NodeCollection {
    constructor(model: CdfModelNodeCollectionDataProvider, innerSet: NodeCollection);
    // (undocumented)
    static readonly classToken = "InvertedNodeCollection";
    clear(): never;
    // (undocumented)
    getAreas(): AreaCollection;
    // (undocumented)
    getIndexSet(): IndexSet;
    // (undocumented)
    get isLoading(): boolean;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @public
export function isClassicPointCloudModel(model: CognitePointCloudModel<DataSourceType>): model is CognitePointCloudModel<ClassicDataSourceType>;

// @public
export function isClassicPointCloudVolume(pointCloudMetadata: DataSourceType['pointCloudVolumeMetadata']): pointCloudMetadata is ClassicDataSourceType['pointCloudVolumeMetadata'];

// @public
export function isDefaultCameraManager(cameraManager: CameraManager): cameraManager is DefaultCameraManager;

// @public
export function isDMPointCloudModel(model: CognitePointCloudModel<DataSourceType>): model is CognitePointCloudModel<DMDataSourceType>;

// @public
export function isDMPointCloudVolume(pointCloudMetadata: DataSourceType['pointCloudVolumeMetadata']): pointCloudMetadata is DMDataSourceType['pointCloudVolumeMetadata'];

// @beta
export function isFlexibleCameraManager(manager: CameraManager): manager is IFlexibleCameraManager;

// @public
export function isPointVisibleByPlanes(planes: Plane[], point: Vector3): boolean;

// @public (undocumented)
export interface JsonFileProvider {
    // (undocumented)
    getJsonFile(baseUrl: string, fileName: string): Promise<any>;
}

// @public
class Keyframe_2 {
    constructor(model: CogniteCadModel, date: Date);
    activate(): void;
    assignStyledNodeCollection(nodeCollection: NodeCollection, nodeAppearance: NodeAppearance): void;
    deactivate(): void;
    getKeyframeDate(): Date;
    unassignStyledNodeCollection(nodeCollection: NodeCollection): void;
}
export { Keyframe_2 as Keyframe }

// @public (undocumented)
export type Measurement = {
    readonly measurementId: number;
    readonly startPoint: Vector3;
    readonly endPoint: Vector3;
    readonly distanceInMeters: number;
};

// @public
export type MeasurementAddedDelegate = (measurement: Measurement) => void;

// @public
export type MeasurementEndedDelegate = () => void;

// @public
export type MeasurementOptions = {
    distanceToLabelCallback?: DistanceToLabelDelegate | undefined;
    lineWidth?: number;
    color?: Color;
};

// @public
export type MeasurementStartedDelegate = () => void;

// @public
export class MeasurementTool extends Cognite3DViewerToolBase {
    constructor(viewer: Cognite3DViewer<DataSourceType>, options?: MeasurementOptions);
    addMeasurement(startPoint: THREE.Vector3, endPoint: THREE.Vector3): Measurement;
    dispose(): void;
    enterMeasurementMode(): void;
    exitMeasurementMode(): void;
    getAllMeasurements(): Measurement[];
    get isInMeasurementMode(): boolean;
    // (undocumented)
    off(event: 'disposed', callback: DisposedDelegate): void;
    // (undocumented)
    off(event: 'added', callback: MeasurementAddedDelegate): void;
    // (undocumented)
    off(event: 'started', callback: MeasurementStartedDelegate): void;
    // (undocumented)
    off(event: 'ended', callback: MeasurementEndedDelegate): void;
    on(event: 'disposed', callback: DisposedDelegate): void;
    on(event: 'added', callback: MeasurementAddedDelegate): void;
    on(event: 'started', callback: MeasurementStartedDelegate): void;
    on(event: 'ended', callback: MeasurementEndedDelegate): void;
    removeAllMeasurements(): void;
    removeMeasurement(measurement: Measurement): void;
    setLineOptions(options: MeasurementOptions): void;
    setMeasurementLabelsVisible(enable: boolean): void;
    updateLineColor(measurement: Measurement, color: THREE.Color): void;
    updateLineWidth(measurement: Measurement, lineWidth: number): void;
    visible(enable: boolean): void;
}

// @public
export interface ModelDataProvider extends JsonFileProvider, BinaryFileProvider {
    getBinaryFile(baseUrl: string, fileName: string, abortSignal?: AbortSignal): Promise<ArrayBuffer>;
    getJsonFile(baseUrl: string, fileName: string): Promise<any>;
}

// @public
export interface ModelIdentifier {
    readonly revealInternalId: symbol;
}

// @public
export interface ModelMetadataProvider {
    // (undocumented)
    getModelCamera(identifier: ModelIdentifier): Promise<{
        position: THREE.Vector3;
        target: THREE.Vector3;
    } | undefined>;
    // (undocumented)
    getModelMatrix(identifier: ModelIdentifier, format: File3dFormat | string): Promise<THREE.Matrix4>;
    // (undocumented)
    getModelOutputs(modelIdentifier: ModelIdentifier): Promise<BlobOutputMetadata[]>;
    // (undocumented)
    getModelUri(identifier: ModelIdentifier, formatMetadata: BlobOutputMetadata): Promise<string>;
}

// @public (undocumented)
export type ModelState = {
    defaultNodeAppearance: SerializableNodeAppearance;
    modelId: number;
    revisionId: number;
    styledSets: {
        token: string;
        state: any;
        options?: any;
        appearance: SerializableNodeAppearance;
    }[];
};

// @public
export type NodeAppearance = {
    readonly color?: Color;
    readonly visible?: boolean;
    readonly renderInFront?: boolean;
    readonly renderGhosted?: boolean;
    readonly outlineColor?: NodeOutlineColor;
    readonly prioritizedForLoadingHint?: number;
};

// @public
export abstract class NodeCollection {
    protected constructor(classToken: string);
    // (undocumented)
    get classToken(): string;
    // (undocumented)
    abstract clear(): void;
    abstract getAreas(): AreaCollection;
    // (undocumented)
    abstract getIndexSet(): IndexSet;
    // (undocumented)
    abstract get isLoading(): boolean;
    protected notifyChanged(): void;
    // (undocumented)
    off(event: 'changed', listener: () => void): void;
    // (undocumented)
    on(event: 'changed', listener: () => void): void;
    // (undocumented)
    abstract serialize(): SerializedNodeCollection;
}

// @public (undocumented)
export type NodeCollectionSerializationContext = {
    client: CogniteClient;
    model: CdfModelNodeCollectionDataProvider;
};

// @public
export class NodeIdNodeCollection extends CdfNodeCollectionBase {
    constructor(client: CogniteClient, model: CdfModelNodeCollectionDataProvider);
    // (undocumented)
    static readonly classToken = "NodeIdNodeCollection";
    // (undocumented)
    static deserialize(descriptor: SerializedNodeCollection, context: NodeCollectionSerializationContext): Promise<NodeIdNodeCollection>;
    executeFilter(nodeIds: number[]): Promise<void>;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @public (undocumented)
export enum NodeOutlineColor {
    // (undocumented)
    Black = 2,
    // (undocumented)
    Blue = 4,
    // (undocumented)
    Cyan = 3,
    // (undocumented)
    Green = 5,
    // (undocumented)
    NoOutline = 0,
    // (undocumented)
    Orange = 7,
    // (undocumented)
    Red = 6,
    // (undocumented)
    White = 1
}

// @public
export interface NodesApiClient {
    determineNodeAncestorsByNodeId(modelId: CogniteInternalId, revisionId: CogniteInternalId, nodeId: CogniteInternalId, generation: number): Promise<{
        treeIndex: number;
        subtreeSize: number;
    }>;
    determineTreeIndexAndSubtreeSizesByNodeIds(modelId: CogniteInternalId, revisionId: CogniteInternalId, nodeIds: CogniteInternalId[]): Promise<{
        treeIndex: number;
        subtreeSize: number;
    }[]>;
    getBoundingBoxesByNodeIds(modelId: CogniteInternalId, revisionId: CogniteInternalId, nodeIds: CogniteInternalId[]): Promise<THREE.Box3[]>;
    mapNodeIdsToTreeIndices(modelId: CogniteInternalId, revisionId: CogniteInternalId, nodeIds: CogniteInternalId[]): Promise<number[]>;
    mapTreeIndicesToNodeIds(modelId: CogniteInternalId, revisionId: CogniteInternalId, treeIndices: number[]): Promise<CogniteInternalId[]>;
}

// @public (undocumented)
export class NumericRange {
    constructor(from: number, count: number);
    // (undocumented)
    contains(value: number): boolean;
    // (undocumented)
    readonly count: number;
    // (undocumented)
    static createFromInterval(from: number, toInclusive: number): NumericRange;
    // (undocumented)
    equal(other: NumericRange): boolean;
    // (undocumented)
    forEach(action: (value: number) => void): void;
    // (undocumented)
    readonly from: number;
    // (undocumented)
    intersectionWith(range: NumericRange): NumericRange | undefined;
    // (undocumented)
    intersects(range: NumericRange): boolean;
    // (undocumented)
    intersectsOrCoinciding(range: NumericRange): boolean;
    // (undocumented)
    isInside(range: NumericRange): boolean;
    // (undocumented)
    static isNumericRange(value: any): value is NumericRange;
    // (undocumented)
    toArray(): number[];
    // (undocumented)
    readonly toInclusive: number;
    // (undocumented)
    toString(): string;
    // (undocumented)
    union(range: NumericRange): NumericRange;
    // (undocumented)
    values(): Generator<number>;
}

// @public
export type OnLoadingCallback = (itemsLoaded: number, itemsRequested: number, itemsCulled: number) => void;

// @public
export interface Overlay3D<ContentType> {
    getColor(): Color;
    getContent(): ContentType;
    getPosition(): Vector3;
    getVisible(): boolean;
    setColor(color: Color): void;
    setVisible(visible: boolean): void;
}

// @public
export class Overlay3DCollection<MetadataType = DefaultOverlay3DContentType> extends Object3D implements OverlayCollection<MetadataType> {
    constructor(overlayInfos: OverlayInfo<MetadataType>[], options?: Overlay3DCollectionOptions);
    addOverlays(overlayInfos: OverlayInfo<MetadataType>[]): Overlay3D<MetadataType>[];
    dispose(): void;
    getOverlays(): Overlay3D<MetadataType>[];
    intersectOverlays(normalizedCoordinates: Vector2, camera: Camera): Overlay3D<MetadataType> | undefined;
    removeAllOverlays(): void;
    removeOverlays(overlays: Overlay3D<MetadataType>[]): void;
    setVisibility(visibility: boolean): void;
}

// @public
export type Overlay3DCollectionOptions = {
    overlayTexture?: Texture;
    overlayTextureMask?: Texture;
    maxPointSize?: number;
    defaultOverlayColor?: Color;
};

// @public
export class Overlay3DTool<ContentType = DefaultOverlay3DContentType> extends Cognite3DViewerToolBase {
    constructor(viewer: Cognite3DViewer, toolParameters?: Overlay3DToolParameters);
    clear(): void;
    createOverlayCollection(overlays?: OverlayInfo<ContentType>[], options?: OverlayCollectionOptions): OverlayCollection<ContentType>;
    dispose(): void;
    getCollections(): OverlayCollection<ContentType>[];
    getTextOverlayVisible(): boolean;
    getVisible(): boolean;
    // (undocumented)
    off(event: 'hover', eventHandler: OverlayEventHandler<ContentType>): void;
    // (undocumented)
    off(event: 'click', eventHandler: OverlayEventHandler<ContentType>): void;
    // (undocumented)
    off(event: 'disposed', eventHandler: DisposedDelegate): void;
    on(event: 'hover', eventHandler: OverlayEventHandler<ContentType>): void;
    // (undocumented)
    on(event: 'click', eventHandler: OverlayEventHandler<ContentType>): void;
    // (undocumented)
    on(event: 'disposed', eventHandler: DisposedDelegate): void;
    removeOverlayCollection(overlayCollection: OverlayCollection<ContentType>): void;
    setTextOverlayVisible(visible: boolean): void;
    setVisible(visible: boolean): void;
}

// @public
export type Overlay3DToolParameters = {
    maxPointSize?: number;
    defaultOverlayColor: THREE.Color;
};

// @public
export interface OverlayCollection<ContentType> {
    addOverlays(overlays: OverlayInfo<ContentType>[]): Overlay3D<ContentType>[];
    getOverlays(): Overlay3D<ContentType>[];
    removeAllOverlays(): void;
    removeOverlays(overlays: Overlay3D<ContentType>[]): void;
    setVisibility(visibility: boolean): void;
}

// @public
export type OverlayCollectionOptions = {
    defaultOverlayColor?: THREE.Color;
    overlayTexture?: THREE.Texture;
    overlayTextureMask?: THREE.Texture;
};

// @public
export type OverlayEventHandler<ContentType> = (event: {
    targetOverlay: Overlay3D<ContentType>;
    htmlTextOverlay: HTMLElement;
    mousePosition: {
        offsetX: number;
        offsetY: number;
    };
}) => void;

// @public
export type OverlayInfo<ContentType = DefaultOverlay3DContentType> = {
    position: Vector3;
    content: ContentType;
    color?: Color;
};

// @public
export type OverlayToolEvent = 'hover' | 'click' | 'disposed';

// @public
export abstract class PointCloudAnnotationVolumeCollection {
    abstract getAnnotationIds(): Iterable<number>;
    abstract get isLoading(): boolean;
    protected notifyChanged(): void;
    off(event: 'changed', listener: () => void): void;
    on(event: 'changed', listener: () => void): void;
}

// @public (undocumented)
export type PointCloudAppearance = {
    color?: Color;
    visible?: boolean;
};

// @public
export type PointCloudBudget = {
    readonly numberOfPoints: number;
};

// @public
export class PointCloudDMVolumeCollection {
    constructor(ids: Iterable<DMInstanceRef>);
    getDataModelInstanceRefs(): Iterable<DMInstanceRef>;
    get isLoading(): false;
}

// @public
export type PointCloudIntersection<T extends DataSourceType = ClassicDataSourceType> = {
    type: 'pointcloud';
    model: CognitePointCloudModel<T>;
    point: Vector3;
    pointIndex: number;
    distanceToCamera: number;
    annotationId: number;
    assetRef?: AnnotationsAssetRef;
    volumeMetadata?: T['pointCloudVolumeMetadata'];
};

// @public @deprecated
export abstract class PointCloudObjectCollection extends PointCloudAnnotationVolumeCollection {
}

// @public
export type PointCloudObjectMetadata<T extends DataSourceType = ClassicDataSourceType> = {
    boundingBox: Box3;
} & T['pointCloudVolumeMetadata'];

// @public (undocumented)
export enum PointColorType {
    // (undocumented)
    Classification = 8,
    // (undocumented)
    Depth = 2,
    // (undocumented)
    Elevation = 3,
    // (undocumented)
    Height = 3,
    // (undocumented)
    Intensity = 4,
    // (undocumented)
    LevelOfDetail = 6,
    // (undocumented)
    Lod = 6,
    // (undocumented)
    PointIndex = 7,
    // (undocumented)
    Rgb = 0
}

// @public
export type PointerEventData = {
    offsetX: number;
    offsetY: number;
    button?: number;
};

// @public
export type PointerEventDelegate = (event: PointerEventData) => void;

// @beta
export class PointerEvents {
    // (undocumented)
    get isEnabled(): boolean;
    // (undocumented)
    onClick(_event: PointerEvent): Promise<void>;
    // (undocumented)
    onDoubleClick(_event: PointerEvent): Promise<void>;
    // (undocumented)
    onHover(_event: PointerEvent): void;
    // (undocumented)
    onPointerDown(_event: PointerEvent, _leftButton: boolean): Promise<void>;
    // (undocumented)
    onPointerDrag(_event: PointerEvent, _leftButton: boolean): Promise<void>;
    // (undocumented)
    onPointerUp(_event: PointerEvent, _leftButton: boolean): Promise<void>;
}

// @beta
export class PointerEventsTarget {
    constructor(domElement: HTMLElement, events: PointerEvents);
    // (undocumented)
    addEventListeners(): void;
    // (undocumented)
    removeEventListeners(): void;
}

// @public (undocumented)
export enum PointShape {
    // (undocumented)
    Circle = 1,
    // (undocumented)
    Paraboloid = 2,
    // (undocumented)
    Square = 0
}

// @public (undocumented)
export enum PointSizeType {
    // (undocumented)
    Adaptive = 2,
    // (undocumented)
    Attenuated = 1,
    // (undocumented)
    Fixed = 0
}

// @public
export class PropertyFilterNodeCollection extends CdfNodeCollectionBase {
    constructor(client: CogniteClient, model: CdfModelNodeCollectionDataProvider, options?: PropertyFilterNodeCollectionOptions);
    // (undocumented)
    static readonly classToken = "PropertyFilterNodeCollection";
    executeFilter(filter: {
        [category: string]: {
            [key: string]: string;
        };
    }): Promise<void>;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @public
export type PropertyFilterNodeCollectionOptions = {
    requestPartitions?: number;
};

// @public (undocumented)
export function registerNodeCollectionType<T extends NodeCollection>(nodeCollectionTypeName: string, deserializer: (descriptor: SerializedNodeCollection, context: NodeCollectionSerializationContext) => Promise<T>): void;

// @public
export type RelativePosition = {
    corner: Corner;
    padding: THREE.Vector2;
};

// @public
export type RenderParameters = {
    renderSize: Vector2;
};

// @public
export type ResolutionOptions = {
    maxRenderResolution?: number;
    movingCameraResolutionFactor?: number;
};

// @public (undocumented)
export const REVEAL_VERSION: string;

// @public
export type SceneRenderedDelegate = (event: {
    frameNumber: number;
    renderTime: number;
    renderer: WebGLRenderer;
    camera: PerspectiveCamera;
}) => void;

// @public
export type SerializableNodeAppearance = {
    readonly color?: [number, number, number];
    readonly visible?: boolean;
    readonly renderInFront?: boolean;
    readonly renderGhosted?: boolean;
    readonly outlineColor?: NodeOutlineColor;
    readonly prioritizedForLoadingHint?: number;
};

// @public (undocumented)
export type SerializedNodeCollection = {
    token: string;
    state: any;
    options?: any;
};

// @public
export class SinglePropertyFilterNodeCollection extends CdfNodeCollectionBase {
    constructor(client: CogniteClient, model: CdfModelNodeCollectionDataProvider, options?: PropertyFilterNodeCollectionOptions);
    // (undocumented)
    static readonly classToken = "SinglePropertyNodeCollection";
    executeFilter(propertyCategory: string, propertyKey: string, propertyValues: string[]): Promise<void>;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @public @deprecated
export class StyledPointCloudObjectCollection extends StyledPointCloudVolumeCollection<ClassicDataSourceType> {
}

// @public
export class StyledPointCloudVolumeCollection<T extends DataSourceType> {
    constructor(
    objectCollection: T['pointCloudCollectionType'],
    style: CompletePointCloudAppearance);
    // @deprecated
    objectCollection: T['pointCloudCollectionType'];
    style: CompletePointCloudAppearance;
    get volumeCollection(): T['pointCloudCollectionType'];
}

// @public (undocumented)
export type SupportedModelTypes = 'pointcloud' | 'cad';

// @public
export type TimelineDateUpdateDelegate = (event: {
    date: Date;
    activeKeyframe: Keyframe_2 | undefined;
    startDate: Date;
    endDate: Date;
}) => void;

// @public
export class TimelineTool extends Cognite3DViewerToolBase {
    constructor(cadModel: CogniteCadModel);
    createKeyframe(date: Date): Keyframe_2;
    // (undocumented)
    dispose(): void;
    getAllKeyframes(): Keyframe_2[];
    getKeyframeByDate(date: Date): Keyframe_2 | undefined;
    pause(): void;
    play(startDate: Date, endDate: Date, totalDurationInMilliSeconds: number): void;
    removeKeyframe(keyframe: Keyframe_2): void;
    removeKeyframeByDate(date: Date): void;
    resume(): void;
    stop(): void;
    subscribe(event: 'dateChanged', listener: TimelineDateUpdateDelegate): void;
    unsubscribe(event: 'dateChanged', listener: TimelineDateUpdateDelegate): void;
}

// @public
export class TreeIndexNodeCollection extends NodeCollection {
    constructor(treeIndexSet?: IndexSet);
    constructor(treeIndices?: Iterable<number>);
    constructor(treeIndexRange?: NumericRange);
    addAreaPoints(points: THREE.Vector3[]): void;
    addAreas(areas: THREE.Box3[]): void;
    // (undocumented)
    static readonly classToken = "TreeIndexNodeCollection";
    clear(): void;
    // (undocumented)
    clearAreas(): void;
    // (undocumented)
    getAreas(): AreaCollection;
    // (undocumented)
    getIndexSet(): IndexSet;
    // (undocumented)
    get isLoading(): boolean;
    // (undocumented)
    serialize(): SerializedNodeCollection;
    // (undocumented)
    updateSet(treeIndices: IndexSet): void;
    // (undocumented)
    updateSet(treeIndices: NumericRange): void;
    // (undocumented)
    updateSet(treeIndices: Iterable<number>): void;
}

// @public
export class UnionNodeCollection extends CombineNodeCollectionBase {
    constructor(nodeCollections?: NodeCollection[]);
    // (undocumented)
    static readonly classToken = "UnionNodeCollection";
    // (undocumented)
    protected createCombinedIndexSet(): IndexSet;
    // (undocumented)
    getAreas(): AreaCollection;
    // (undocumented)
    serialize(): SerializedNodeCollection;
}

// @beta
export class Vector3Pool {
    constructor(size?: number);
    getNext(copyFrom?: Vector3): Vector3;
}

// @public (undocumented)
export type ViewerState = {
    camera?: {
        position: {
            x: number;
            y: number;
            z: number;
        };
        target: {
            x: number;
            y: number;
            z: number;
        };
    };
    models?: ModelState[];
    clippingPlanes?: ClippingPlanesState[];
};

// @public
export enum WellKnownAsprsPointClassCodes {
    BridgeDeck = 17,
    // (undocumented)
    Building = 6,
    Created = 0,
    Default = -1,
    // (undocumented)
    Ground = 2,
    HighNoise = 18,
    // (undocumented)
    HighVegetation = 5,
    IgnoredGround = 20,
    LowPoint = 7,
    // (undocumented)
    LowVegetation = 3,
    // (undocumented)
    MedVegetation = 4,
    OverheadStructure = 19,
    // (undocumented)
    Rail = 10,
    ReservedOrBridgeDeck = 12,
    ReservedOrHighPoint = 8,
    // (undocumented)
    RoadSurface = 11,
    // (undocumented)
    Snow = 21,
    TemporalExclusion = 22,
    // (undocumented)
    TransmissionTower = 15,
    // (undocumented)
    Unclassified = 1,
    // (undocumented)
    Water = 9,
    WireConductor = 14,
    WireGuard = 13,
    WireStructureConnector = 16
}

// @public
export type WellKnownUnit = 'Meters' | 'Centimeters' | 'Millimeters' | 'Micrometers' | 'Kilometers' | 'Feet' | 'Inches' | 'Yards' | 'Miles' | 'Mils' | 'Microinches';

// (No @packageDocumentation comment for this package)

```
