{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["// This comes from the fact that parseInt trims characters coming\n// after digits and consider it a valid int, so `1*` becomes `1`.\nconst safeParseInt = (value: string): number => {\n  if (/^\\d+$/.test(value)) {\n    return Number(value)\n  } else {\n    return NaN\n  }\n}\n\nconst isWildcard = (value: string): boolean => {\n  return value === '*'\n}\n\nconst isQuestionMark = (value: string): boolean => {\n  return value === '?'\n}\n\nconst isInRange = (value: number, start: number, stop: number): boolean => {\n  return value >= start && value <= stop\n}\n\nconst isValidRange = (value: string, start: number, stop: number): boolean => {\n  const sides = value.split('-')\n  switch (sides.length) {\n    case 1:\n      return isWildcard(value) || isInRange(safeParseInt(value), start, stop)\n    case 2:\n      const [small, big] = sides.map((side: string): number => safeParseInt(side))\n      return small <= big && isInRange(small, start, stop) && isInRange(big, start, stop)\n    default:\n      return false\n  }\n}\n\nconst isValidStep = (value: string | undefined): boolean => {\n  return value === undefined || (value.search(/[^\\d]/) === -1 && safeParseInt(value) > 0)\n}\n\nconst validateForRange = (value: string, start: number, stop: number): boolean => {\n  if (value.search(/[^\\d-,\\/*]/) !== -1) {\n    return false\n  }\n\n  const list = value.split(',')\n  return list.every((condition: string): boolean => {\n    const splits = condition.split('/')\n    // Prevents `*/ * * * *` from being accepted.\n    if (condition.trim().endsWith('/')) {\n      return false\n    }\n\n    // Prevents `*/*/* * * * *` from being accepted\n    if (splits.length > 2) {\n      return false\n    }\n\n    // If we don't have a `/`, right will be undefined which is considered a valid step if we don't a `/`.\n    const [left, right] = splits\n    return isValidRange(left, start, stop) && isValidStep(right)\n  })\n}\n\nconst hasValidSeconds = (seconds: string): boolean => {\n  return validateForRange(seconds, 0, 59)\n}\n\nconst hasValidMinutes = (minutes: string): boolean => {\n  return validateForRange(minutes, 0, 59)\n}\n\nconst hasValidHours = (hours: string): boolean => {\n  return validateForRange(hours, 0, 23)\n}\n\nconst hasValidDays = (days: string, allowBlankDay?: boolean): boolean => {\n  return (allowBlankDay && isQuestionMark(days)) || validateForRange(days, 1, 31)\n}\n\nconst monthAlias: { [key: string]: string } = {\n  jan: '1',\n  feb: '2',\n  mar: '3',\n  apr: '4',\n  may: '5',\n  jun: '6',\n  jul: '7',\n  aug: '8',\n  sep: '9',\n  oct: '10',\n  nov: '11',\n  dec: '12'\n}\n\nconst hasValidMonths = (months: string, alias?: boolean): boolean => {\n  // Prevents alias to be used as steps\n  if (months.search(/\\/[a-zA-Z]/) !== -1) {\n    return false\n  }\n\n  if (alias) {\n    const remappedMonths = months.toLowerCase().replace(/[a-z]{3}/g, (match: string): string => {\n      return monthAlias[match] === undefined ? match : monthAlias[match]\n    })\n    // If any invalid alias was used, it won't pass the other checks as there will be non-numeric values in the months\n    return validateForRange(remappedMonths, 1, 12)\n  }\n\n  return validateForRange(months, 1, 12)\n}\n\nconst weekdaysAlias: { [key: string]: string } = {\n  sun: '0',\n  mon: '1',\n  tue: '2',\n  wed: '3',\n  thu: '4',\n  fri: '5',\n  sat: '6'\n}\n\nconst hasValidWeekdays = (weekdays: string, alias?: boolean, allowBlankDay?: boolean, allowSevenAsSunday?: boolean): boolean => {\n\n  // If there is a question mark, checks if the allowBlankDay flag is set\n  if (allowBlankDay && isQuestionMark(weekdays)) {\n    return true\n  } else if (!allowBlankDay && isQuestionMark(weekdays)) {\n    return false\n  }\n\n  // Prevents alias to be used as steps\n  if (weekdays.search(/\\/[a-zA-Z]/) !== -1) {\n    return false\n  }\n\n  if (alias) {\n    const remappedWeekdays = weekdays.toLowerCase().replace(/[a-z]{3}/g, (match: string): string => {\n      return weekdaysAlias[match] === undefined ? match : weekdaysAlias[match]\n    })\n    // If any invalid alias was used, it won't pass the other checks as there will be non-numeric values in the weekdays\n    return validateForRange(remappedWeekdays, 0, allowSevenAsSunday ? 7 : 6)\n  }\n\n  return validateForRange(weekdays, 0, allowSevenAsSunday ? 7 : 6)\n}\n\nconst hasCompatibleDayFormat = (days: string, weekdays: string, allowBlankDay?: boolean) => {\n  return !(allowBlankDay && isQuestionMark(days) && isQuestionMark(weekdays))\n}\n\nconst split = (cron: string): string[] => {\n  return cron.trim().split(/\\s+/)\n}\n\ntype Options = {\n  alias: boolean\n  seconds: boolean\n  allowBlankDay: boolean\n  allowSevenAsSunday: boolean\n}\n\nconst defaultOptions: Options = {\n  alias: false,\n  seconds: false,\n  allowBlankDay: false,\n  allowSevenAsSunday: false\n}\n\nexport const isValidCron = (cron: string, options?: Partial<Options>): boolean => {\n  options = { ...defaultOptions, ...options }\n\n  const splits = split(cron)\n\n  if (splits.length > (options.seconds ? 6 : 5) || splits.length < 5) {\n    return false\n  }\n\n  const checks: boolean[] = []\n  if (splits.length === 6) {\n    const seconds = splits.shift()\n    if (seconds) {\n      checks.push(hasValidSeconds(seconds))\n    }\n  }\n\n  // We could only check the steps gradually and return false on the first invalid block,\n  // However, this won't have any performance impact so why bother for now.\n  const [minutes, hours, days, months, weekdays] = splits\n  checks.push(hasValidMinutes(minutes))\n  checks.push(hasValidHours(hours))\n  checks.push(hasValidDays(days, options.allowBlankDay))\n  checks.push(hasValidMonths(months, options.alias))\n  checks.push(hasValidWeekdays(weekdays, options.alias, options.allowBlankDay, options.allowSevenAsSunday))\n  checks.push(hasCompatibleDayFormat(days, weekdays, options.allowBlankDay))\n\n  return checks.every(Boolean)\n}\n"]}