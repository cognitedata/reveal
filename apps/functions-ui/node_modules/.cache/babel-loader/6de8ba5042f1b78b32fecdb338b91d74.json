{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// TODO(CDFUX-0): copies from @cognite/cdf-utilities!\nimport { useCallback, useMemo } from 'react';\nimport { useSearchParams } from 'react-router-dom';\nimport isUrl from 'is-url';\nimport queryString from 'query-string';\nexport const useSearchParam = (key, opts) => {\n  _s();\n  const {\n    replace = false,\n    serialize,\n    deserialize\n  } = opts;\n  const [searchParams, setSearchParams] = useSearchParams();\n  const params = useMemo(() => new URLSearchParams(searchParams), [searchParams]);\n  const param = useMemo(() => {\n    const val = params.get(key);\n    if (val) {\n      return deserialize(val);\n    } else {\n      return null;\n    }\n  }, [deserialize, key, params]);\n  const updateParam = useCallback(value => {\n    const val = serialize(value);\n    if (val) {\n      params.set(key, val);\n    } else {\n      params.delete(key);\n    }\n    setSearchParams(params.toString(), {\n      replace\n    });\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [key, params, replace, serialize]);\n  return [param, updateParam];\n};\n_s(useSearchParam, \"VaUsGxBAw/WygpMMBRKHI4p5W08=\", false, function () {\n  return [useSearchParams];\n});\nexport const useSearchParamString = (key, opts) => {\n  _s2();\n  return useSearchParam(key, {\n    replace: opts?.replace,\n    serialize: s => s,\n    deserialize: s => s\n  });\n};\n_s2(useSearchParamString, \"wBdAjbGQ4jraECV4lsq3xSlz3PI=\", false, function () {\n  return [useSearchParam];\n});\nexport const isValidUrl = value => {\n  return isUrl(value);\n};\n\n// Parsed object is not stringified back correctly when `opts` is given as `arrayFormat: 'comma'`,\n// so be very careful while using with `opts` here!\nexport const getSearchParams = (searchParams, opts) => {\n  return queryString.parse(searchParams, opts);\n};","map":{"version":3,"names":["useCallback","useMemo","useSearchParams","isUrl","queryString","useSearchParam","key","opts","replace","serialize","deserialize","searchParams","setSearchParams","params","URLSearchParams","param","val","get","updateParam","value","set","delete","toString","useSearchParamString","s","isValidUrl","getSearchParams","parse"],"sources":["/Volumes/csvol/fusion/libs/data-exploration/core/src/utils/url.ts"],"sourcesContent":["// TODO(CDFUX-0): copies from @cognite/cdf-utilities!\nimport { useCallback, useMemo } from 'react';\nimport { useSearchParams } from 'react-router-dom';\n\nimport isUrl from 'is-url';\nimport queryString from 'query-string';\n\ntype UseSearchParamOpts<T> = {\n  replace?: boolean;\n  deserialize: (val: string | null) => T | null;\n  serialize: (val: T | null) => string | null;\n};\nexport const useSearchParam = <T>(\n  key: string,\n  opts: UseSearchParamOpts<T>\n): [T | null, (v: T | null) => void] => {\n  const { replace = false, serialize, deserialize } = opts;\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  const params = useMemo(\n    () => new URLSearchParams(searchParams),\n    [searchParams]\n  );\n  const param = useMemo(() => {\n    const val = params.get(key);\n    if (val) {\n      return deserialize(val);\n    } else {\n      return null;\n    }\n  }, [deserialize, key, params]);\n\n  const updateParam = useCallback(\n    (value: T | null) => {\n      const val = serialize(value);\n      if (val) {\n        params.set(key, val);\n      } else {\n        params.delete(key);\n      }\n      setSearchParams(params.toString(), { replace });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [key, params, replace, serialize]\n  );\n\n  return [param, updateParam];\n};\nexport const useSearchParamString = (\n  key: string,\n  opts?: { replace?: boolean }\n) => {\n  return useSearchParam<string>(key, {\n    replace: opts?.replace,\n    serialize: (s) => s,\n    deserialize: (s) => s,\n  });\n};\n\nexport const isValidUrl = (value: string) => {\n  return isUrl(value);\n};\n\n// Parsed object is not stringified back correctly when `opts` is given as `arrayFormat: 'comma'`,\n// so be very careful while using with `opts` here!\nexport const getSearchParams = (\n  searchParams: string,\n  opts?: queryString.StringifyOptions\n) => {\n  return queryString.parse(searchParams, opts);\n};\n"],"mappings":";;AAAA;AACA,SAASA,WAAW,EAAEC,OAAO,QAAQ,OAAO;AAC5C,SAASC,eAAe,QAAQ,kBAAkB;AAElD,OAAOC,KAAK,MAAM,QAAQ;AAC1B,OAAOC,WAAW,MAAM,cAAc;AAOtC,OAAO,MAAMC,cAAc,GAAG,CAC5BC,GAAW,EACXC,IAA2B,KACW;EAAA;EACtC,MAAM;IAAEC,OAAO,GAAG,KAAK;IAAEC,SAAS;IAAEC;EAAY,CAAC,GAAGH,IAAI;EACxD,MAAM,CAACI,YAAY,EAAEC,eAAe,CAAC,GAAGV,eAAe,EAAE;EAEzD,MAAMW,MAAM,GAAGZ,OAAO,CACpB,MAAM,IAAIa,eAAe,CAACH,YAAY,CAAC,EACvC,CAACA,YAAY,CAAC,CACf;EACD,MAAMI,KAAK,GAAGd,OAAO,CAAC,MAAM;IAC1B,MAAMe,GAAG,GAAGH,MAAM,CAACI,GAAG,CAACX,GAAG,CAAC;IAC3B,IAAIU,GAAG,EAAE;MACP,OAAON,WAAW,CAACM,GAAG,CAAC;IACzB,CAAC,MAAM;MACL,OAAO,IAAI;IACb;EACF,CAAC,EAAE,CAACN,WAAW,EAAEJ,GAAG,EAAEO,MAAM,CAAC,CAAC;EAE9B,MAAMK,WAAW,GAAGlB,WAAW,CAC5BmB,KAAe,IAAK;IACnB,MAAMH,GAAG,GAAGP,SAAS,CAACU,KAAK,CAAC;IAC5B,IAAIH,GAAG,EAAE;MACPH,MAAM,CAACO,GAAG,CAACd,GAAG,EAAEU,GAAG,CAAC;IACtB,CAAC,MAAM;MACLH,MAAM,CAACQ,MAAM,CAACf,GAAG,CAAC;IACpB;IACAM,eAAe,CAACC,MAAM,CAACS,QAAQ,EAAE,EAAE;MAAEd;IAAQ,CAAC,CAAC;EACjD,CAAC;EACD;EACA,CAACF,GAAG,EAAEO,MAAM,EAAEL,OAAO,EAAEC,SAAS,CAAC,CAClC;EAED,OAAO,CAACM,KAAK,EAAEG,WAAW,CAAC;AAC7B,CAAC;AAAC,GAnCWb,cAAc;EAAA,QAKeH,eAAe;AAAA;AA+BzD,OAAO,MAAMqB,oBAAoB,GAAG,CAClCjB,GAAW,EACXC,IAA4B,KACzB;EAAA;EACH,OAAOF,cAAc,CAASC,GAAG,EAAE;IACjCE,OAAO,EAAED,IAAI,EAAEC,OAAO;IACtBC,SAAS,EAAGe,CAAC,IAAKA,CAAC;IACnBd,WAAW,EAAGc,CAAC,IAAKA;EACtB,CAAC,CAAC;AACJ,CAAC;AAAC,IATWD,oBAAoB;EAAA,QAIxBlB,cAAc;AAAA;AAOvB,OAAO,MAAMoB,UAAU,GAAIN,KAAa,IAAK;EAC3C,OAAOhB,KAAK,CAACgB,KAAK,CAAC;AACrB,CAAC;;AAED;AACA;AACA,OAAO,MAAMO,eAAe,GAAG,CAC7Bf,YAAoB,EACpBJ,IAAmC,KAChC;EACH,OAAOH,WAAW,CAACuB,KAAK,CAAChB,YAAY,EAAEJ,IAAI,CAAC;AAC9C,CAAC"},"metadata":{},"sourceType":"module"}