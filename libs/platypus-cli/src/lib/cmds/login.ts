import { Arguments, Argv } from 'yargs';
import { CogniteClient } from '@cognite/sdk-v6';
import {
  ConfidentialClientApplication,
  PublicClientApplication,
} from '@azure/msal-node';
// eslint-disable-next-line @typescript-eslint/no-var-requires
const open = require('open');

export type LoginArgs = {
  project: string;
  useClientSecret: boolean;
  clientId: string;
  clientSecret: string;
  tenant: string;
  cluster: string;
};

export const command = 'login';
export const desc = 'Login to CDF for using Platypus';
export const builder = (yargs: Argv<LoginArgs>) => {
  yargs
    .usage('$0 login [project]')
    .example('platypus login cognite', 'Login to cognite tenant')
    .positional('project', {
      alias: 'p',
      type: 'string',
      description: 'CDF Project Name',
      default: 'platypus',
    })
    .option('use-client-secret', {
      type: 'boolean',
      default: false,
      description:
        'This flag will enable us to use AAD Client credentials flow usually suitable for CI/CD',
    })
    .option('client-id', {
      type: 'string',
      default: '4770c0f1-7bb6-43b5-8c37-94f2a9306757', //todo: read from app config
      description: "AAD Application's Client ID",
    })
    .option('client-secret', {
      type: 'string',
      description:
        "AAD Application's Client Secret generated by the user they have long expiry and are hence suitable for CI/CD",
    })
    .option('tenant', {
      type: 'string',
      default: 'cogniteappdev.onmicrosoft.com',
      description: 'Azure Active Directory Tenant URI or ID',
    })
    .option('cluster', {
      type: 'string',
      default: 'greenfield',
      description: 'Cluster Name',
    })
    .check((arg) => {
      if (arg.useClientSecret) {
        if (!arg.clientSecret || arg.clientSecret === '') {
          return 'Client Secret needed to be passed when using --use-client-secret';
        }
      }
      return validateClusterName(arg.cluster);
    });
};

const getTokenForArg = (arg: Arguments<LoginArgs>) => async () => {
  const authority = `https://login.microsoftonline.com/${arg.tenant}`;
  const clientId = arg.clientId;
  const baseUrl = `https://${arg.cluster}.cognitedata.com`;
  const scopes = [`${baseUrl}/.default`];

  if (arg.useClientSecret) {
    return (
      await new ConfidentialClientApplication({
        auth: { clientId, authority, clientSecret: arg.clientSecret },
      }).acquireTokenByClientCredential({
        scopes,
        skipCache: true,
      })
    ).accessToken;
  }

  return (
    await new PublicClientApplication({
      auth: { clientId, authority },
    }).acquireTokenByDeviceCode({
      scopes,
      deviceCodeCallback: ({ verificationUri, userCode, message }) => {
        open(verificationUri)
          .then(() =>
            console.log(`Please enter the code in browser: ${userCode}`)
          )
          .catch(() => console.log(`Failed to verify, ${message}`));
      },
    })
  ).accessToken;
};

export const handler = async (arg: Arguments<LoginArgs>) => {
  const baseUrl = `https://${arg.cluster}.cognitedata.com`;
  const appId = 'Platypus';

  try {
    const client = new CogniteClient({
      appId,
      project: arg.project,
      baseUrl,
      getToken: getTokenForArg(arg),
    });
    const token = await client.authenticate();
    console.log('token = ', token);
    await client.assets.list();
    console.log('Login Success!');
  } catch (error) {
    console.log('Error while trying to authenticate');
  }
};

export const validateClusterName = (cluster: string): boolean | string => {
  if (!/^[a-zA-Z0-9-_]+$/.test(cluster)) {
    return 'Cluster name is invalid, make sure its just the name of the cluster; For example if its "api.cognitedata.com" just enter "api"';
  }
  return true;
};
