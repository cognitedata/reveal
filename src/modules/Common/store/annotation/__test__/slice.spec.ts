/* eslint-disable jest/no-disabled-tests */
import {
  ImageObjectDetectionBoundingBox,
  Status,
} from 'src/api/annotation/types';
import reducer, {
  initialState,
} from 'src/modules/Common/store/annotation/slice';
import { AnnotationState } from 'src/modules/Common/store/annotation/types';
import { VisionAnnotation } from 'src/modules/Common/types';
import { createVisionAnnotationStub } from 'src/modules/Common/Utils/AnnotationUtils/AnnotationUtils';
import { DeleteAnnotations } from 'src/store/thunks/Annotation/DeleteAnnotations';
import { RetrieveAnnotations } from 'src/store/thunks/Annotation/RetrieveAnnotations';

const getDummyImageObjectDetectionBoundingBoxAnnotation = ({
  id = 1,
  annotatedResourceId = 10,
}: {
  id?: number;
  annotatedResourceId?: number;
}): VisionAnnotation<ImageObjectDetectionBoundingBox> => {
  const data: ImageObjectDetectionBoundingBox = {
    label: 'pump',
    boundingBox: {
      xMin: 0.25,
      yMin: 0.25,
      xMax: 0.75,
      yMax: 0.75,
    },
  };

  return createVisionAnnotationStub<ImageObjectDetectionBoundingBox>({
    id,
    createdTime: 123,
    lastUpdatedTime: 123,
    status: Status.Suggested,
    resourceId: { annotatedResourceId },
    data,
  });
};

describe('Test annotation reducer', () => {
  test('should return the initial state', () => {
    expect(reducer(undefined, { type: undefined })).toEqual(initialState);
  });

  describe('Test RetrieveAnnotations.fulfilled action', () => {
    test('should clear entire state when clear cache is true and response is empty', () => {
      const previousState: AnnotationState = {
        files: {
          byId: {
            '10': [1, 2],
          },
        },
        annotations: {
          byId: {
            '1': getDummyImageObjectDetectionBoundingBoxAnnotation({ id: 1 }),
            '2': getDummyImageObjectDetectionBoundingBoxAnnotation({ id: 2 }),
          },
        },
      };
      const action = {
        type: RetrieveAnnotations.fulfilled.type,
        meta: {
          arg: {
            fileIds: [],
            clearCache: true,
          },
        },
        payload: [],
      };

      expect(reducer(previousState, action)).toEqual({
        files: {
          byId: {},
        },
        annotations: {
          byId: {},
        },
      });
    });

    test('should clear only specified fileIds when clear cache is false and response is empty', () => {
      const previousState = {
        files: {
          byId: {
            '10': [1],
            '20': [2],
          },
        },
        annotations: {
          byId: {
            '1': getDummyImageObjectDetectionBoundingBoxAnnotation({ id: 1 }),
            '2': getDummyImageObjectDetectionBoundingBoxAnnotation({ id: 2 }),
          },
        },
      };

      const action = {
        type: RetrieveAnnotations.fulfilled.type,
        meta: {
          arg: {
            fileIds: [10],
            clearCache: false,
          },
        },
        payload: [],
      };

      expect(reducer(previousState, action)).toEqual({
        files: {
          byId: { '20': [2] },
        },
        annotations: {
          byId: {
            '2': getDummyImageObjectDetectionBoundingBoxAnnotation({ id: 2 }),
          },
        },
      });
    });

    test('should keep state unchanged if nonexistent fileIds are provided', () => {
      const previousState = {
        files: {
          byId: {
            '10': [1],
          },
        },
        annotations: {
          byId: {
            '1': getDummyImageObjectDetectionBoundingBoxAnnotation({ id: 1 }),
          },
        },
      };

      const action = {
        type: RetrieveAnnotations.pending.type,
        meta: {
          arg: {
            fileIds: [30],
            clearCache: false,
          },
        },
        payload: [],
      };

      expect(reducer(previousState, action)).toEqual(previousState);
    });

    /**
     * ToDo (VIS-794):
     * ideally payload should contain data of the new annotation type
     * even unable to test with a payload of old type annotation data generated by getDummyAnnotationV1
     * as type validation of validBoundingBox is failing for those generated annotations.
     * Skipping this test until the new thunk created
     */
    test.skip('should populate state', () => {
      const previousState = {
        files: {
          byId: {
            '10': [1],
            '20': [],
          },
        },
        annotations: {
          byId: {
            '1': getDummyImageObjectDetectionBoundingBoxAnnotation({
              id: 1,
              annotatedResourceId: 10,
            }),
          },
        },
      };

      const action = {
        type: RetrieveAnnotations.fulfilled.type,
        meta: {
          arg: {
            fileIds: [10, 20, 30],
            clearCache: false,
          },
        },
        payload: [
          getDummyImageObjectDetectionBoundingBoxAnnotation({
            id: 1,
            annotatedResourceId: 10,
          }), // existing annotation and file
          getDummyImageObjectDetectionBoundingBoxAnnotation({
            id: 2,
            annotatedResourceId: 10,
          }), // new annotation for existing file with annotation
          getDummyImageObjectDetectionBoundingBoxAnnotation({
            id: 3,
            annotatedResourceId: 20,
          }), // new annotation for existing file without annotation
          getDummyImageObjectDetectionBoundingBoxAnnotation({
            id: 4,
            annotatedResourceId: 30,
          }), // new file and annotation
        ],
      };

      expect(reducer(previousState, action)).toEqual({
        files: {
          byId: {
            '10': [1, 2], // should add only new annotation to existing file
            '20': [3], // should add new annotation to existing file, previously without annotations
            '30': [4], // should add new file and annotation
          },
        },
        annotations: {
          byId: {
            '1': getDummyImageObjectDetectionBoundingBoxAnnotation({
              id: 1,
              annotatedResourceId: 10,
            }),
            '2': getDummyImageObjectDetectionBoundingBoxAnnotation({
              id: 2,
              annotatedResourceId: 10,
            }),
            '3': getDummyImageObjectDetectionBoundingBoxAnnotation({
              id: 3,
              annotatedResourceId: 20,
            }),
            '4': getDummyImageObjectDetectionBoundingBoxAnnotation({
              id: 4,
              annotatedResourceId: 30,
            }),
          },
        },
      });
    });
  });

  describe('Test DeleteAnnotations.fulfilled action', () => {
    test('should not change state for nonexistent annotation id', () => {
      const previousState = {
        files: {
          byId: {
            '10': [1],
          },
        },
        annotations: {
          byId: {
            '1': getDummyImageObjectDetectionBoundingBoxAnnotation({ id: 1 }),
          },
        },
      };

      const action = {
        type: DeleteAnnotations.fulfilled.type,
        payload: [3], // annotation ids to delete
      };

      expect(reducer(previousState, action)).toEqual(previousState);
    });

    test('should clean entire state since all annotation ids in state given in payload', () => {
      const previousState = {
        files: {
          byId: {
            '10': [1, 2],
          },
        },
        annotations: {
          byId: {
            '1': getDummyImageObjectDetectionBoundingBoxAnnotation({ id: 1 }),
            '2': getDummyImageObjectDetectionBoundingBoxAnnotation({ id: 1 }),
          },
        },
      };

      const action = {
        type: DeleteAnnotations.fulfilled.type,
        payload: [1, 2], // annotation ids to delete
      };

      expect(reducer(previousState, action)).toEqual(initialState);
    });
  });
});
