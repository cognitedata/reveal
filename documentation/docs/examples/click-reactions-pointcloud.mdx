---
id: click-reactions-pointcloud
title: Reacting to clicks in point cloud models
description: Detecting intersections from clicks in point cloud models
---

While point clouds doesn't have a concept of nodes, applications can detect clicked points. Just like with
CAD models, `Cognite3DViewer.getIntersectionFromPixel` is used to determine world position and point from
a mouse click.

import { DemoWrapper } from '@site/docs/components/DemoWrapper';

<DemoWrapper modelType="pointcloud" />

## Detecting clicked positions

The following example detects intersections at clicked positions and marks the intersected positions
using a red sphere.

```js runnable
viewer.on('click', async event => {
  const intersection = await viewer.getIntersectionFromPixel(
    event.offsetX, event.offsetY
  );
  if (intersection) {
    const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.1),
      new THREE.MeshBasicMaterial({ wireframe: true, color: 'red' }));
    sphere.position.copy(intersection.point);
    viewer.addObject3D(sphere);
  };
});
```

## Getting information about object assigned to a clicked point
Using Cognite's Annotations API, a user can define objects within a point cloud model. In order to retrieve information
about a clicked object, users may get the `annotationId` that is assigned to each point.
The `annotationId` is available in the `intersection` object returned from `viewer.getIntersectionFromPixel`. An annotation id of 0 means that the clicked point
is not assigned to any object.

```js runnable
viewer.on('click', async event => {
  const intersection = await viewer.getIntersectionFromPixel(
    event.offsetX, event.offsetY
  );
  if (intersection) {
     alert(`Clicked object: ${intersection.annotationId}`);
  };
});
```

## Controlling the intersection threshold

By default, points within 5 cm of an intersection ray is considered to be intersecting. For point clouds of large
physical assets this is usually a good value, but for point clouds with large extends (e.g. geographical point clouds)
this threshold might be too small.

The intersection threshold can be changed using the `pointIntersectionThreshold` option of `getIntersectionFromPixel`:

```js
const options = { pointIntersectionThreshold: 1.0 /* 1 m */ };
const intersection = await viewer.getIntersectionFromPixel(event.offsetX, event.offsetY, options);
```
