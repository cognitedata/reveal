import { Arguments, Argv } from 'yargs';
import { CogniteClient } from '@cognite/sdk-v6';
import { PublicClientApplication } from '@azure/msal-node';
import { LoginArgs } from '../types';
import { AUTH_TYPE, CONFIG_KEY, LOGIN_STATUS } from '../constants';
import { getAccessTokenForClientSecret } from '../common/auth';
import { setProjectConfig, setProjectConfigItem } from '../utils/config';
// eslint-disable-next-line @typescript-eslint/no-var-requires
const open = require('open');

export const command = 'login';
export const desc = 'Login to CDF for using Platypus';
export const builder = (yargs: Argv<LoginArgs>) => {
  yargs
    .usage('$0 login [project]')
    .example('platypus login cognite', 'Login to cognite tenant')
    .positional('project', {
      alias: 'p',
      type: 'string',
      description: 'CDF Project Name',
      default: 'platypus',
    })
    .option('use-client-secret', {
      type: 'boolean',
      default: false,
      description:
        'This flag will enable us to use AAD Client credentials flow usually suitable for CI/CD',
    })
    .option('client-id', {
      type: 'string',
      default: '4770c0f1-7bb6-43b5-8c37-94f2a9306757', //todo: read from app config
      description: "AAD Application's Client ID",
    })
    .option('client-secret', {
      type: 'string',
      description:
        "AAD Application's Client Secret generated by the user they have long expiry and are hence suitable for CI/CD",
    })
    .option('tenant', {
      type: 'string',
      default: 'cogniteappdev.onmicrosoft.com',
      description: 'Azure Active Directory Tenant URI or ID',
    })
    .option('cluster', {
      type: 'string',
      default: 'greenfield',
      description: 'Cluster Name',
    })
    .check((arg) => {
      if (arg.useClientSecret) {
        if (!arg.clientSecret || arg.clientSecret === '') {
          return 'Client Secret needed to be passed when using --use-client-secret';
        }
      }
      return validateClusterName(arg.cluster);
    });
};

const getTokenForArg = (arg: Arguments<LoginArgs>) => async () => {
  const { clientId, clientSecret, cluster, tenant } = arg;

  const authority = `https://login.microsoftonline.com/${tenant}`;
  const baseUrl = `https://${cluster}.cognitedata.com`;
  const scopes = [`${baseUrl}/.default`];

  if (arg.useClientSecret) {
    return (
      await getAccessTokenForClientSecret({
        clientId,
        clientSecret,
        scopes,
        authority,
      })
    ).accessToken;
  }

  return (
    await new PublicClientApplication({
      auth: { clientId, authority },
    }).acquireTokenByDeviceCode({
      scopes,
      deviceCodeCallback: ({ verificationUri, userCode, message }) => {
        open(verificationUri)
          .then(() =>
            console.log(`Please enter the code in browser: ${userCode}`)
          )
          .catch(() => console.log(`Failed to verify, ${message}`));
      },
    })
  ).accessToken;
};

export const handler = async (arg: Arguments<LoginArgs>) => {
  const { cluster, Conf, project, appId } = arg;
  const baseUrl = `https://${cluster}.cognitedata.com`;

  try {
    const client = new CogniteClient({
      appId,
      project,
      baseUrl,
      getToken: getTokenForArg(arg),
    });
    const token = await client.authenticate();
    if (token) {
      await client.assets.list();

      setProjectConfig(arg, token);

      console.log('Login Success!');
      return;
    }

    throw new Error(
      'Received empty token, please try to login again with proper configs'
    );
  } catch (error) {
    console.log('Error while trying to authenticate');
    setProjectConfigItem(CONFIG_KEY.LOGIN_STATUS, LOGIN_STATUS.FAILED);
  }
};

export const validateClusterName = (cluster: string): boolean | string => {
  if (!/^[a-zA-Z0-9-_]+$/.test(cluster)) {
    return 'Cluster name is invalid, make sure its just the name of the cluster; For example if its "api.cognitedata.com" just enter "api"';
  }
  return true;
};
