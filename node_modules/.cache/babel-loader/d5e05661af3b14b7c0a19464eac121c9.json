{"ast":null,"code":"import isArray from 'lodash/isArray';\nimport isEmpty from 'lodash/isEmpty';\nimport { isNumeric, METADATA_ALL_VALUE } from '@data-exploration-lib/core';\nimport { AdvancedFilterBuilder } from '../../../builders';\nimport { NIL_FILTER_VALUE } from '../../../constants';\nimport { getSearchConfig } from '../../../utils';\nexport const mapFiltersToTimeseriesAdvancedFilters = ({\n  dataSetIds,\n  createdTime,\n  lastUpdatedTime,\n  externalIdPrefix,\n  unit,\n  metadata,\n  isStep,\n  isString,\n  internalId\n}, query, searchConfig = getSearchConfig().timeSeries) => {\n  const builder = new AdvancedFilterBuilder();\n  const filterBuilder = new AdvancedFilterBuilder().in('dataSetId', () => {\n    return dataSetIds?.reduce((acc, {\n      value\n    }) => {\n      if (typeof value === 'number') {\n        return [...acc, value];\n      }\n      return acc;\n    }, []);\n  }).or(new AdvancedFilterBuilder().in('unit', () => {\n    // this condition need to be removed when remove the legacy implementation\n    if (unit && !isArray(unit)) {\n      return [unit];\n    }\n    return unit;\n  }).notExists('unit', () => {\n    if (!unit) return false;\n    if (isArray(unit)) {\n      return unit.includes(NIL_FILTER_VALUE);\n    }\n    return unit === NIL_FILTER_VALUE;\n  })).equals('id', internalId).equals('isStep', isStep).equals('isString', isString).prefix('externalId', externalIdPrefix).range('createdTime', {\n    lte: createdTime?.max,\n    gte: createdTime?.min\n  }).range('lastUpdatedTime', {\n    lte: lastUpdatedTime?.max,\n    gte: lastUpdatedTime?.min\n  });\n  if (metadata) {\n    const metadataBuilder = new AdvancedFilterBuilder();\n    for (const {\n      key,\n      value\n    } of metadata) {\n      if (value === METADATA_ALL_VALUE) {\n        metadataBuilder.exists(`metadata|${key}`);\n      } else {\n        metadataBuilder.equals(`metadata|${key}`, value);\n      }\n    }\n    filterBuilder.or(metadataBuilder);\n  }\n  builder.and(filterBuilder);\n  if (query && !isEmpty(query)) {\n    const searchQueryBuilder = new AdvancedFilterBuilder();\n    if (searchConfig.name.enabled) {\n      searchQueryBuilder.equals('name', query);\n      searchQueryBuilder.prefix('name', query);\n      if (searchConfig.name.enabledFuzzySearch) {\n        searchQueryBuilder.search('name', query);\n      }\n    }\n    if (searchConfig.description.enabled) {\n      searchQueryBuilder.equals('description', query);\n      searchQueryBuilder.prefix('description', query);\n      if (searchConfig.description.enabledFuzzySearch) {\n        searchQueryBuilder.search('description', query);\n      }\n    }\n    if (searchConfig.metadata.enabled) {\n      /**\n       * We want to filter all the metadata keys with the search query, to give a better result\n       * to the user when using our search.\n       */\n      searchQueryBuilder.equals(`metadata`, query);\n      searchQueryBuilder.prefix(`metadata`, query);\n    }\n    if (isNumeric(query) && searchConfig.id.enabled) {\n      searchQueryBuilder.equals('id', Number(query));\n    }\n    if (searchConfig.unit.enabled) {\n      searchQueryBuilder.equals(`unit`, query);\n      searchQueryBuilder.prefix('unit', query);\n    }\n    if (searchConfig.externalId.enabled) {\n      searchQueryBuilder.equals(`externalId`, query);\n      searchQueryBuilder.prefix('externalId', query);\n    }\n    builder.or(searchQueryBuilder);\n  }\n  return new AdvancedFilterBuilder().and(builder).build();\n};","map":{"version":3,"names":["isArray","isEmpty","isNumeric","METADATA_ALL_VALUE","AdvancedFilterBuilder","NIL_FILTER_VALUE","getSearchConfig","mapFiltersToTimeseriesAdvancedFilters","dataSetIds","createdTime","lastUpdatedTime","externalIdPrefix","unit","metadata","isStep","isString","internalId","query","searchConfig","timeSeries","builder","filterBuilder","in","reduce","acc","value","or","notExists","includes","equals","prefix","range","lte","max","gte","min","metadataBuilder","key","exists","and","searchQueryBuilder","name","enabled","enabledFuzzySearch","search","description","id","Number","externalId","build"],"sources":["/Volumes/csvol/fusion/libs/data-exploration/domain-layer/src/timeseries/internal/transformers/mapFiltersToTimeseriesAdvancedFilters.ts"],"sourcesContent":["import isArray from 'lodash/isArray';\nimport isEmpty from 'lodash/isEmpty';\n\nimport {\n  InternalTimeseriesFilters,\n  isNumeric,\n  TimeseriesConfigType,\n  METADATA_ALL_VALUE,\n} from '@data-exploration-lib/core';\n\nimport { AdvancedFilter, AdvancedFilterBuilder } from '../../../builders';\nimport { NIL_FILTER_VALUE } from '../../../constants';\nimport { getSearchConfig } from '../../../utils';\n\nexport type TimeseriesProperties = {\n  assetIds: number[];\n  dataSetId: number[];\n  unit: string | string[];\n  externalId: string;\n  name: string;\n  id: number;\n  isStep: boolean;\n  isString: boolean;\n  description: string;\n  metadata: string;\n  [key: `metadata|${string}`]: string;\n};\n\nexport const mapFiltersToTimeseriesAdvancedFilters = (\n  {\n    dataSetIds,\n    createdTime,\n    lastUpdatedTime,\n    externalIdPrefix,\n    unit,\n    metadata,\n    isStep,\n    isString,\n    internalId,\n  }: InternalTimeseriesFilters,\n  query?: string,\n  searchConfig: TimeseriesConfigType = getSearchConfig().timeSeries\n): AdvancedFilter<TimeseriesProperties> | undefined => {\n  const builder = new AdvancedFilterBuilder<TimeseriesProperties>();\n\n  const filterBuilder = new AdvancedFilterBuilder<TimeseriesProperties>()\n    .in('dataSetId', () => {\n      return dataSetIds?.reduce((acc, { value }) => {\n        if (typeof value === 'number') {\n          return [...acc, value];\n        }\n        return acc;\n      }, [] as number[]);\n    })\n    .or(\n      new AdvancedFilterBuilder<TimeseriesProperties>()\n        .in('unit', () => {\n          // this condition need to be removed when remove the legacy implementation\n          if (unit && !isArray(unit)) {\n            return [unit];\n          }\n          return unit;\n        })\n        .notExists('unit', () => {\n          if (!unit) return false;\n          if (isArray(unit)) {\n            return unit.includes(NIL_FILTER_VALUE);\n          }\n\n          return unit === NIL_FILTER_VALUE;\n        })\n    )\n    .equals('id', internalId)\n    .equals('isStep', isStep)\n    .equals('isString', isString)\n    .prefix('externalId', externalIdPrefix)\n    .range('createdTime', {\n      lte: createdTime?.max as number,\n      gte: createdTime?.min as number,\n    })\n    .range('lastUpdatedTime', {\n      lte: lastUpdatedTime?.max as number,\n      gte: lastUpdatedTime?.min as number,\n    });\n\n  if (metadata) {\n    const metadataBuilder = new AdvancedFilterBuilder<TimeseriesProperties>();\n    for (const { key, value } of metadata) {\n      if (value === METADATA_ALL_VALUE) {\n        metadataBuilder.exists(`metadata|${key}`);\n      } else {\n        metadataBuilder.equals(`metadata|${key}`, value);\n      }\n    }\n    filterBuilder.or(metadataBuilder);\n  }\n\n  builder.and(filterBuilder);\n\n  if (query && !isEmpty(query)) {\n    const searchQueryBuilder =\n      new AdvancedFilterBuilder<TimeseriesProperties>();\n\n    if (searchConfig.name.enabled) {\n      searchQueryBuilder.equals('name', query);\n      searchQueryBuilder.prefix('name', query);\n\n      if (searchConfig.name.enabledFuzzySearch) {\n        searchQueryBuilder.search('name', query);\n      }\n    }\n\n    if (searchConfig.description.enabled) {\n      searchQueryBuilder.equals('description', query);\n      searchQueryBuilder.prefix('description', query);\n\n      if (searchConfig.description.enabledFuzzySearch) {\n        searchQueryBuilder.search('description', query);\n      }\n    }\n\n    if (searchConfig.metadata.enabled) {\n      /**\n       * We want to filter all the metadata keys with the search query, to give a better result\n       * to the user when using our search.\n       */\n      searchQueryBuilder.equals(`metadata`, query);\n      searchQueryBuilder.prefix(`metadata`, query);\n    }\n\n    if (isNumeric(query) && searchConfig.id.enabled) {\n      searchQueryBuilder.equals('id', Number(query));\n    }\n\n    if (searchConfig.unit.enabled) {\n      searchQueryBuilder.equals(`unit`, query);\n      searchQueryBuilder.prefix('unit', query);\n    }\n\n    if (searchConfig.externalId.enabled) {\n      searchQueryBuilder.equals(`externalId`, query);\n      searchQueryBuilder.prefix('externalId', query);\n    }\n\n    builder.or(searchQueryBuilder);\n  }\n\n  return new AdvancedFilterBuilder<TimeseriesProperties>().and(builder).build();\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}