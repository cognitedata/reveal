commit bf293268989f5e02867794da05d341a5c4060dfe
Author: HÃ¥kon Flatval <hakon.flatval@cognite.com>
Date:   Fri Mar 11 14:14:15 2022 +0100

    temp: Checkpoint

diff --git a/src/IPointCloudTreeGeometry.ts b/src/IPointCloudTreeGeometry.ts
new file mode 100644
index 0000000..061659f
--- /dev/null
+++ b/src/IPointCloudTreeGeometry.ts
@@ -0,0 +1,20 @@
+/*!
+ * Coyright 2022 Cognite AS
+ */
+
+import { IPointCloudTreeNodeBase } from "./types/IPointCloudTreeNodeBase";
+
+import * as THREE from 'three';
+
+export interface IPointCloudTreeGeometry {
+
+  root: IPointCloudTreeNodeBase | undefined;
+
+  boundingBox: THREE.Box3;
+  tightBoundingBox: THREE.Box3;
+
+  offset: THREE.Vector3;
+  spacing: number;
+
+  dispose(): void;
+};
diff --git a/src/point-attributes.ts b/src/PointAttributes.ts
similarity index 100%
rename from src/point-attributes.ts
rename to src/PointAttributes.ts
diff --git a/src/PointCloudEptGeometry.ts b/src/PointCloudEptGeometry.ts
new file mode 100644
index 0000000..c7e50f0
--- /dev/null
+++ b/src/PointCloudEptGeometry.ts
@@ -0,0 +1,268 @@
+import * as THREE from 'three';
+
+// import { Version } from './version';
+import { ILoader } from './loading/ept/ILoader';
+import { EptBinaryLoader } from './loading/ept/BinaryLoader';
+
+import { PointCloudEptGeometryNode } from './PointCloudEptGeometryNode';
+import { IPointCloudTreeGeometry } from './IPointCloudTreeGeometry';
+
+import * as proj4 from 'proj4';
+
+type SchemaEntry = {
+  name: string;
+  scale: number;
+  offset: number;
+};
+
+export class Utils {
+  static toVector3(v: number[], offset?: number): THREE.Vector3 {
+    return new THREE.Vector3().fromArray(v, offset || 0);
+  }
+
+  static toBox3(b: number[]): THREE.Box3 {
+    return new THREE.Box3(Utils.toVector3(b), Utils.toVector3(b, 3));
+  };
+
+  static findDim(schema: SchemaEntry[], name: string) {
+    let dim = schema.find((dim) => dim.name == name);
+    if (!dim) throw new Error('Failed to find ' + name + ' in schema');
+    return dim;
+  }
+
+  static sphereFrom(b: THREE.Box3) {
+    return b.getBoundingSphere(new THREE.Sphere());
+  }
+};
+
+export class PointCloudEptGeometry implements IPointCloudTreeGeometry {
+
+  private readonly _eptScale: THREE.Vector3;
+  private readonly _eptOffset: THREE.Vector3;
+
+  private readonly _url: string;
+  // private readonly _type: 'ept';
+
+  private readonly _boundingBox: THREE.Box3;
+  private readonly _tightBoundingBox: THREE.Box3;
+
+  // private readonly _boundingSphere: THREE.Sphere;
+  // private readonly _tightBoundingSphere: THREE.Sphere;
+
+  private readonly _offset: THREE.Vector3;
+  // private readonly _version: Version;
+
+  private readonly _span: number;
+  private readonly _spacing: number;
+
+  private readonly _loader: ILoader;
+
+  private readonly _schema: SchemaEntry[];
+
+  // private readonly _pointAttributes: PointAttributes;
+
+  private _root: PointCloudEptGeometryNode | undefined;
+
+  private _projection: string | null;
+  // private _fallbackProjection: string | null;
+
+  get root(): PointCloudEptGeometryNode | undefined {
+    return this._root;
+  }
+
+  get boundingBox(): THREE.Box3 {
+    return this._boundingBox;
+  }
+
+  get tightBoundingBox(): THREE.Box3 {
+    return this._tightBoundingBox;
+  }
+
+  get offset(): THREE.Vector3 {
+    return this._offset;
+  }
+
+  get spacing(): number {
+    return this._spacing;
+  }
+
+  get url(): string {
+    return this._url;
+  }
+
+  get schema(): SchemaEntry[] {
+    return this._schema;
+  }
+
+  get eptScale(): THREE.Vector3 {
+    return this._eptScale;
+  }
+
+  get eptOffset(): THREE.Vector3 {
+    return this._eptOffset;
+  }
+
+  get loader(): ILoader {
+    return this._loader;
+  }
+
+  set root(r: PointCloudEptGeometryNode | undefined) {
+    this._root = r;
+  }
+
+  constructor(url: string, info: any) {
+    // const version = info.version;
+    const schema = info.schema;
+    const bounds = info.bounds;
+    const boundsConforming = info.boundsConforming;
+
+    let xyz = [
+      Utils.findDim(schema, 'X'),
+      Utils.findDim(schema, 'Y'),
+      Utils.findDim(schema, 'Z')
+    ];
+    let scale = xyz.map((d) => d.scale || 1);
+    let offset = xyz.map((d) => d.offset || 0);
+    this._eptScale = Utils.toVector3(scale);
+    this._eptOffset = Utils.toVector3(offset);
+
+    this._url = url;
+    // this.info = info;
+    // this._type = 'ept';
+
+    this._schema = schema;
+    this._span = info.span || info.ticks;
+    this._boundingBox = Utils.toBox3(bounds);
+    this._tightBoundingBox = Utils.toBox3(boundsConforming);
+    this._offset = Utils.toVector3([0, 0, 0]);
+    // this._boundingSphere = Utils.sphereFrom(this._boundingBox);
+    // this._tightBoundingSphere = Utils.sphereFrom(this._tightBoundingBox);
+    // this._version = new Version('1.7');
+
+    this._projection = null;
+    // this._fallbackProjection = null;
+
+    if (info.srs && info.srs.horizontal) {
+      this._projection = info.srs.authority + ':' + info.srs.horizontal;
+    }
+
+    if (info.srs.wkt) {
+      if (!this._projection) this._projection = info.srs.wkt;
+      // else this._fallbackProjection = info.srs.wkt;
+    }
+
+    if (this._projection)
+    {
+      // TODO [mschuetz]: named projections that proj4 can't handle seem to cause problems.
+      // remove them for now
+
+      try {
+        proj4(this._projection);
+      } catch (e) {
+        this._projection = null;
+      }
+    }
+
+    {
+      /* const attributes = new PointAttributes();
+
+      attributes.add(PointAttributeName.POSITION_CARTESIAN);
+      attributes.add(makePointAttribute("rgba", POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 4));
+      attributes.add(new IPointAttribute("intensity", POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT16, 1));
+      attributes.add(new IPointAttribute("classification", POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1));
+      attributes.add(new IPointAttribute("gps-time", POINT_ATTRIBUTE_TYPES.DATA_TYPE_DOUBLE, 1));
+      attributes.add(new IPointAttribute("returnNumber", POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1));
+      attributes.add(new IPointAttribute("number of returns", POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1));
+      attributes.add(new IPointAttribute("return number", POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1));
+      attributes.add(new IPointAttribute("source id", POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT16, 1)); */
+
+      // this._pointAttributes = POINT_ATTRIBUTES;
+    }
+
+    this._spacing =
+      (this._boundingBox.max.x - this._boundingBox.min.x) / this._span;
+
+    // let hierarchyType = info.hierarchyType || 'json';
+
+    const dataType = info.dataType;
+    /* if (dataType == 'laszip') {
+      this.loader = new Potree.EptLaszipLoader();
+    }
+    else */
+    if (dataType == 'binary') {
+      this._loader = new EptBinaryLoader();
+    }
+    /* else if (dataType == 'zstandard') {
+      this.loader = new Potree.EptZstandardLoader();
+    } */
+    else {
+      throw new Error('Could not read data type: ' + dataType);
+    }
+  }
+
+  dispose() { }
+};
+
+export class EptKey {
+
+  readonly ept: PointCloudEptGeometry;
+  readonly x: number;
+  readonly y: number;
+  readonly z: number;
+  readonly b: THREE.Box3;
+  readonly d: number;
+
+  constructor(ept: PointCloudEptGeometry,
+    b: THREE.Box3,
+    d: number,
+    x?: number,
+    y?: number,
+    z?: number) {
+    this.ept = ept;
+    this.b = b;
+    this.d = d;
+    this.x = x || 0;
+    this.y = y || 0;
+    this.z = z || 0;
+  }
+
+  name() {
+    return this.d + '-' + this.x + '-' + this.y + '-' + this.z;
+  }
+
+  step(a: number, b: number, c: number) {
+    let min = this.b.min.clone();
+    let max = this.b.max.clone();
+    let dst = new THREE.Vector3().subVectors(max, min);
+
+    if (a) min.x += dst.x / 2;
+    else max.x -= dst.x / 2;
+
+    if (b) min.y += dst.y / 2;
+    else max.y -= dst.y / 2;
+
+    if (c) min.z += dst.z / 2;
+    else max.z -= dst.z / 2;
+
+    return new EptKey(
+      this.ept,
+      new THREE.Box3(min, max),
+      this.d + 1,
+      this.x * 2 + a,
+      this.y * 2 + b,
+      this.z * 2 + c);
+  }
+
+  children() {
+    var result: string[] = [];
+    for (var a = 0; a < 2; ++a) {
+      for (var b = 0; b < 2; ++b) {
+        for (var c = 0; c < 2; ++c) {
+          var add = this.step(a, b, c).name();
+          if (!result.includes(add)) result = result.concat(add);
+        }
+      }
+    }
+    return result;
+  }
+}
diff --git a/src/PointCloudEptGeometryNode.ts b/src/PointCloudEptGeometryNode.ts
new file mode 100644
index 0000000..129fb42
--- /dev/null
+++ b/src/PointCloudEptGeometryNode.ts
@@ -0,0 +1,343 @@
+import { IPointCloudTreeGeometryNode } from './types/IPointCloudTreeGeometryNode';
+import { IPointCloudTreeNodeBase } from './types/IPointCloudTreeNodeBase';
+import * as THREE from 'three';
+import {
+  PointCloudEptGeometry,
+  EptKey,
+  Utils
+} from './PointCloudEptGeometry';
+
+import {
+  globalNumNodesLoading,
+  globalMaxNumNodesLoading,
+  incrementGlobalNumNodesLoading,
+  decrementGlobalNumNodesLoading
+} from './loading/globalLoadingCounter';
+
+export class PointCloudEptGeometryNode implements IPointCloudTreeGeometryNode {
+
+  private readonly _id: number;
+  private readonly _ept: PointCloudEptGeometry;
+  private readonly _key: EptKey;
+
+  private readonly _boundingBox: THREE.Box3;
+  // private _tightBoundingBox: THREE.Box3;
+
+  private readonly _boundingSphere: THREE.Sphere;
+  // private readonly _tightBoundingSphere: THREE.Sphere;
+  private readonly _spacing: number;
+  private _level: number;
+  private _numPoints: number;
+  // private _mean: THREE.Vector3;
+
+  private readonly _name: string;
+  private readonly _index: number;
+
+  // private _hasChildren: boolean;
+
+  private readonly _children: IPointCloudTreeGeometryNode[] = new Array(8);
+
+  private _loading: boolean;
+  private _loaded: boolean;
+  // private _parent: PointCloudEptGeometryNode | undefined = undefined;
+
+  private _isLeafNode: boolean;
+
+  private _geometry: THREE.BufferGeometry | undefined;
+
+  private _oneTimeDisposeHandlers: (() => void)[];
+
+  static IDCount: number = 0;
+
+  get id(): number {
+    return this._id;
+  }
+
+  get name(): string {
+    return this._name;
+  }
+
+  get level(): number {
+    return this._level;
+  }
+
+  get spacing(): number {
+    return this._spacing;
+  }
+
+  get boundingBox(): THREE.Box3 {
+    return this._boundingBox;
+  }
+
+  get boundingSphere(): THREE.Sphere {
+    return this._boundingSphere;
+  }
+
+  get loaded(): boolean {
+    return this._loaded;
+  }
+
+  get key(): EptKey {
+    return this._key;
+  }
+
+  get numPoints(): number {
+    return this._numPoints;
+  }
+
+  get children(): IPointCloudTreeNodeBase[] {
+    return this._children;
+  }
+
+  get oneTimeDisposeHandlers(): (() => void)[] {
+    return this._oneTimeDisposeHandlers;
+  }
+
+  get isLeafNode(): boolean {
+    return this._isLeafNode;
+  }
+
+  get geometry(): THREE.BufferGeometry | undefined {
+    return this._geometry!;
+  }
+
+  /* get geometry(): PointCloudEptGeometry {
+    return this._ept;
+  } */
+  get ept(): PointCloudEptGeometry {
+    return this._ept;
+  }
+
+  get index(): number {
+    return this._index;
+  }
+
+  set parent(_p: PointCloudEptGeometryNode) {
+    // this._parent = p;
+  }
+
+  constructor(ept: PointCloudEptGeometry,
+    b?: THREE.Box3,
+    d?: number,
+    x?: number,
+    y?: number,
+    z?: number) {
+    this._ept = ept;
+    this._key = new EptKey(
+      this._ept,
+      b || this._ept.boundingBox,
+      d || 0,
+      x, y, z);
+
+    this._isLeafNode = false;
+
+    this._id = PointCloudEptGeometryNode.IDCount++;
+    this._geometry = undefined;
+    this._boundingBox = this._key.b;
+    // this._tightBoundingBox = this._boundingBox;
+    this._spacing = this._ept.spacing / Math.pow(2, this._key.d);
+    this._boundingSphere = Utils.sphereFrom(this._boundingBox);
+
+    // These are set during hierarchy loading.
+    // this._hasChildren = false;
+    // this._children = { };
+    this._numPoints = -1;
+
+    this._level = this._key.d;
+    this._loaded = false;
+    this._loading = false;
+    this._oneTimeDisposeHandlers = [];
+
+    let k = this._key;
+    this._name = this.toPotreeName(k.d, k.x, k.y, k.z);
+    this._index = parseInt(this._name.charAt(this._name.length - 1));
+  }
+
+  isGeometryNode(): boolean {
+    return true;
+  }
+
+  getLevel() {
+    return this._level;
+  }
+
+  get isTreeNode(): boolean {
+    return false;
+  }
+
+  isLoaded(): boolean {
+    return this._loaded;
+  }
+
+  getBoundingSphere() {
+    return this._boundingSphere;
+  }
+
+  getBoundingBox(): THREE.Box3 {
+    return this._boundingBox;
+  }
+
+  url(): string {
+    return this._ept.url + 'ept-data/' + this.filename();
+  }
+
+  getNumPoints() { return this._numPoints; }
+
+  filename() { return this._key.name(); }
+
+  getChildren() {
+    let children = [];
+
+    for (let i = 0; i < 8; i++) {
+      if (this._children[i]) {
+        children.push(this._children[i]);
+      }
+    }
+
+    return children;
+  }
+
+  traverse(callback: (node: IPointCloudTreeNodeBase) => void, includeSelf: boolean = true): void {
+    const stack: IPointCloudTreeNodeBase[] = includeSelf ? [this] : [];
+
+    let current: IPointCloudTreeNodeBase | undefined;
+    while ((current = stack.pop())) {
+      callback(current);
+
+      for (const child of current.children) {
+        if (child) {
+          stack.push(child);
+        }
+      }
+    }
+  }
+
+  addChild(child: PointCloudEptGeometryNode) {
+    this._children[child.index] = child;
+    child.parent = this;
+  }
+
+  load(): void {
+    if (this._loaded || this._loading)
+      return;
+    if (globalNumNodesLoading >= globalMaxNumNodesLoading)
+      return;
+
+    this._loading = true;
+    incrementGlobalNumNodesLoading();
+
+    if (this._numPoints == -1)
+      this.loadHierarchy();
+    this.loadPoints();
+  }
+
+  loadPoints(): void {
+    this._ept.loader.load(this);
+  }
+
+  async loadHierarchy() {
+    let nodes: { [key: string]: PointCloudEptGeometryNode; } = {};
+    nodes[this.filename()] = this;
+    // this._hasChildren = false;
+
+    let eptHierarchyFile = `${this.ept.url}ept-hierarchy/${this.filename()}.json`;
+
+    let response = await fetch(eptHierarchyFile);
+    let hier = await response.json();
+
+    // Since we want to traverse top-down, and 10 comes
+    // lexicographically before 9 (for example), do a deep sort.
+    var keys = Object.keys(hier).sort((a, b) => {
+      let [da, xa, ya, za] = a.split('-').map((n) => parseInt(n, 10));
+      let [db, xb, yb, zb] = b.split('-').map((n) => parseInt(n, 10));
+      if (da < db)
+        return -1; if (da > db)
+        return 1;
+      if (xa < xb)
+        return -1; if (xa > xb)
+        return 1;
+      if (ya < yb)
+        return -1; if (ya > yb)
+        return 1;
+      if (za < zb)
+        return -1; if (za > zb)
+        return 1;
+      return 0;
+    });
+
+    keys.forEach((v) => {
+      let [d, x, y, z] = v.split('-').map((n) => parseInt(n, 10));
+      let a = x & 1, b = y & 1, c = z & 1;
+      let parentName = (d - 1) + '-' + (x >> 1) + '-' + (y >> 1) + '-' + (z >> 1);
+
+      let parentNode = nodes[parentName];
+      if (!parentNode)
+        return;
+      // parentNode._hasChildren = true;
+
+      let key = parentNode.key.step(a, b, c);
+
+      let node = new PointCloudEptGeometryNode(
+        this.ept,
+        key.b,
+        key.d,
+        key.x,
+        key.y,
+        key.z);
+
+      node._level = d;
+      node._numPoints = hier[v];
+
+      parentNode.addChild(node);
+      nodes[key.name()] = node;
+    });
+  }
+
+  doneLoading(bufferGeometry: THREE.BufferGeometry, _tightBoundingBox: THREE.Box3, np: number, _mean: THREE.Vector3) {
+    bufferGeometry.boundingBox = this._boundingBox;
+    this._geometry = bufferGeometry;
+    // this._tightBoundingBox = tightBoundingBox;
+    this._numPoints = np;
+    // this._mean = mean;
+    this._loaded = true;
+    this._loading = false;
+    decrementGlobalNumNodesLoading();
+  }
+
+  toPotreeName(d: number, x: number, y: number, z: number) {
+    var name = 'r';
+
+    for (var i = 0; i < d; ++i) {
+      var shift = d - i - 1;
+      var mask = 1 << shift;
+      var step = 0;
+
+      if (x & mask)
+        step += 4;
+      if (y & mask)
+        step += 2;
+      if (z & mask)
+        step += 1;
+
+      name += step;
+    }
+
+    return name;
+  }
+
+  dispose() {
+    if (this._geometry && this.parent != null) {
+      this._geometry.dispose();
+      this._geometry = undefined;
+      this._loaded = false;
+      this._isLeafNode = true;
+
+      // this.dispatchEvent( { type: 'dispose' } );
+      for (let i = 0; i < this._oneTimeDisposeHandlers.length; i++) {
+        let handler = this._oneTimeDisposeHandlers[i];
+        handler();
+      }
+      this._oneTimeDisposeHandlers = [];
+    }
+  }
+}
diff --git a/src/point-cloud-octree.ts b/src/PointCloudOctree.ts
similarity index 83%
rename from src/point-cloud-octree.ts
rename to src/PointCloudOctree.ts
index a18f8b4..3272c8b 100644
--- a/src/point-cloud-octree.ts
+++ b/src/PointCloudOctree.ts
@@ -1,18 +1,23 @@
 import { Box3, Camera, Object3D, Points, Ray, Sphere, Vector3, WebGLRenderer } from 'three';
 import { DEFAULT_MIN_NODE_PIXEL_SIZE } from './constants';
 import { PointCloudMaterial, PointSizeType } from './materials';
-import { PointCloudOctreeGeometry } from './point-cloud-octree-geometry';
-import { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';
-import { PointCloudOctreeNode } from './point-cloud-octree-node';
-import { PickParams, PointCloudOctreePicker } from './point-cloud-octree-picker';
-import { PointCloudTree } from './point-cloud-tree';
-import { IPointCloudTreeNode, IPotree, PickPoint } from './types';
+// import { PointCloudOctreeGeometry } from './point-cloud-octree-geometry';
+import { IPointCloudTreeGeometry } from './IPointCloudTreeGeometry';
+// import { IPointCloudOctree } from './IPointCloudOctree';
+// import { PointCloudOctreeGeometryNode } from './PointCloudOctreeGeometryNode';
+import { IPointCloudTreeGeometryNode } from './types/IPointCloudTreeGeometryNode';
+import { PointCloudOctreeNode } from './PointCloudOctreeNode';
+import { PickParams, PointCloudOctreePicker } from './PointCloudOctreePicker';
+import { PointCloudTree } from './PointCloudTree';
+import { IPotree, PickPoint } from './types';
+import { IPointCloudTreeNodeBase } from './types/IPointCloudTreeNodeBase';
+import { IPointCloudTreeNode } from './types/IPointCloudTreeNode';
 import { computeTransformedBoundingBox } from './utils/bounds';
 
 export class PointCloudOctree extends PointCloudTree {
   potree: IPotree;
   disposed: boolean = false;
-  pcoGeometry: PointCloudOctreeGeometry;
+  pcoGeometry: IPointCloudTreeGeometry;
   boundingBox: Box3;
   boundingSphere: Sphere;
   material: PointCloudMaterial;
@@ -22,10 +27,10 @@ export class PointCloudOctree extends PointCloudTree {
    * The minimum radius of a node's bounding sphere on the screen in order to be displayed.
    */
   minNodePixelSize: number = DEFAULT_MIN_NODE_PIXEL_SIZE;
-  root: IPointCloudTreeNode | null = null;
+  root: IPointCloudTreeNodeBase | undefined = undefined;
   boundingBoxNodes: Object3D[] = [];
-  visibleNodes: PointCloudOctreeNode[] = [];
-  visibleGeometry: PointCloudOctreeGeometryNode[] = [];
+  visibleNodes: IPointCloudTreeNode[] = [];
+  visibleGeometry: IPointCloudTreeGeometryNode[] = [];
   numVisiblePoints: number = 0;
   showBoundingBox: boolean = false;
   private visibleBounds: Box3 = new Box3();
@@ -33,7 +38,7 @@ export class PointCloudOctree extends PointCloudTree {
 
   constructor(
     potree: IPotree,
-    pcoGeometry: PointCloudOctreeGeometry,
+    pcoGeometry: IPointCloudTreeGeometry,
     material?: PointCloudMaterial,
   ) {
     super();
@@ -70,7 +75,7 @@ export class PointCloudOctree extends PointCloudTree {
       this.root.dispose();
     }
 
-    this.pcoGeometry.root.traverse(n => this.potree.lru.remove(n));
+    this.pcoGeometry.root?.traverse(n => this.potree.lru.remove(n));
     this.pcoGeometry.dispose();
     this.material.dispose();
 
@@ -94,9 +99,9 @@ export class PointCloudOctree extends PointCloudTree {
   }
 
   toTreeNode(
-    geometryNode: PointCloudOctreeGeometryNode,
-    parent?: PointCloudOctreeNode | null,
-  ): PointCloudOctreeNode {
+    geometryNode: IPointCloudTreeGeometryNode,
+    parent?: IPointCloudTreeNode | null,
+  ): IPointCloudTreeNode {
     const points = new Points(geometryNode.geometry, this.material);
     const node = new PointCloudOctreeNode(geometryNode, points);
     points.name = geometryNode.name;
diff --git a/src/point-cloud-octree-geometry.ts b/src/PointCloudOctreeGeometry.ts
similarity index 79%
rename from src/point-cloud-octree-geometry.ts
rename to src/PointCloudOctreeGeometry.ts
index 2c91c7c..f98cdab 100644
--- a/src/point-cloud-octree-geometry.ts
+++ b/src/PointCloudOctreeGeometry.ts
@@ -1,9 +1,10 @@
 import { Box3, Vector3 } from 'three';
 import { BinaryLoader, XhrRequest } from './loading';
-import { PointAttributes } from './point-attributes';
-import { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';
+import { PointAttributes } from './PointAttributes';
+import { PointCloudOctreeGeometryNode } from './PointCloudOctreeGeometryNode';
+import { IPointCloudTreeGeometry } from './IPointCloudTreeGeometry';
 
-export class PointCloudOctreeGeometry {
+export class PointCloudOctreeGeometry implements IPointCloudTreeGeometry {
   disposed: boolean = false;
   needsUpdate: boolean = true;
   root!: PointCloudOctreeGeometryNode;
diff --git a/src/point-cloud-octree-geometry-node.ts b/src/PointCloudOctreeGeometryNode.ts
similarity index 96%
rename from src/point-cloud-octree-geometry-node.ts
rename to src/PointCloudOctreeGeometryNode.ts
index 704ed35..c30cec0 100644
--- a/src/point-cloud-octree-geometry-node.ts
+++ b/src/PointCloudOctreeGeometryNode.ts
@@ -4,8 +4,8 @@
  */
 
 import { Box3, BufferGeometry, EventDispatcher, Sphere, Vector3 } from 'three';
-import { PointCloudOctreeGeometry } from './point-cloud-octree-geometry';
-import { IPointCloudTreeNode } from './types';
+import { PointCloudOctreeGeometry } from './PointCloudOctreeGeometry';
+import { IPointCloudTreeGeometryNode } from './types/IPointCloudTreeGeometryNode';
 import { createChildAABB } from './utils/bounds';
 import { getIndexFromName } from './utils/utils';
 
@@ -17,7 +17,7 @@ export interface NodeData {
 
 const NODE_STRIDE = 5;
 
-export class PointCloudOctreeGeometryNode extends EventDispatcher implements IPointCloudTreeNode {
+export class PointCloudOctreeGeometryNode extends EventDispatcher implements IPointCloudTreeGeometryNode {
   id: number = PointCloudOctreeGeometryNode.idCount++;
   name: string;
   pcoGeometry: PointCloudOctreeGeometry;
@@ -25,7 +25,7 @@ export class PointCloudOctreeGeometryNode extends EventDispatcher implements IPo
   level: number = 0;
   spacing: number = 0;
   hasChildren: boolean = false;
-  readonly children: ReadonlyArray<PointCloudOctreeGeometryNode | null> = [
+  readonly children: Array<PointCloudOctreeGeometryNode | null> = [
     null,
     null,
     null,
diff --git a/src/point-cloud-octree-node.ts b/src/PointCloudOctreeNode.ts
similarity index 75%
rename from src/point-cloud-octree-node.ts
rename to src/PointCloudOctreeNode.ts
index 7b0d81f..4dcd8fb 100644
--- a/src/point-cloud-octree-node.ts
+++ b/src/PointCloudOctreeNode.ts
@@ -1,18 +1,19 @@
 import { Box3, BufferGeometry, EventDispatcher, Object3D, Points, Sphere } from 'three';
-import { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';
-import { IPointCloudTreeNode } from './types';
+import { IPointCloudTreeGeometryNode } from 'types/IPointCloudTreeGeometryNode';
+import { IPointCloudTreeNode } from './types/IPointCloudTreeNode';
+import { IPointCloudTreeNodeBase } from './types/IPointCloudTreeNodeBase';
 
 export class PointCloudOctreeNode extends EventDispatcher implements IPointCloudTreeNode {
-  geometryNode: PointCloudOctreeGeometryNode;
+  geometryNode: IPointCloudTreeGeometryNode;
   sceneNode: Points;
   pcIndex: number | undefined = undefined;
-  boundingBoxNode: Object3D | null = null;
-  readonly children: (IPointCloudTreeNode | null)[];
+  boundingBoxNode?: Object3D | undefined = undefined;
+  readonly children: (IPointCloudTreeNodeBase | null)[];
   readonly loaded = true;
   readonly isTreeNode: boolean = true;
   readonly isGeometryNode: boolean = false;
 
-  constructor(geometryNode: PointCloudOctreeGeometryNode, sceneNode: Points) {
+  constructor(geometryNode: IPointCloudTreeGeometryNode, sceneNode: Points) {
     super();
 
     this.geometryNode = geometryNode;
@@ -44,7 +45,7 @@ export class PointCloudOctreeNode extends EventDispatcher implements IPointCloud
     }
   }
 
-  traverse(cb: (node: IPointCloudTreeNode) => void, includeSelf?: boolean): void {
+  traverse(cb: (node: IPointCloudTreeNodeBase) => void, includeSelf?: boolean): void {
     this.geometryNode.traverse(cb, includeSelf);
   }
 
diff --git a/src/point-cloud-octree-picker.ts b/src/PointCloudOctreePicker.ts
similarity index 97%
rename from src/point-cloud-octree-picker.ts
rename to src/PointCloudOctreePicker.ts
index 7219bc0..93e0ce7 100644
--- a/src/point-cloud-octree-picker.ts
+++ b/src/PointCloudOctreePicker.ts
@@ -17,8 +17,8 @@ import {
 } from 'three';
 import { COLOR_BLACK, DEFAULT_PICK_WINDOW_SIZE } from './constants';
 import { ClipMode, PointCloudMaterial, PointColorType } from './materials';
-import { PointCloudOctree } from './point-cloud-octree';
-import { PointCloudOctreeNode } from './point-cloud-octree-node';
+import { PointCloudOctree } from './PointCloudOctree';
+import { IPointCloudTreeNode } from './types/IPointCloudTreeNode';
 import { PickPoint, PointCloudHit } from './types';
 import { clamp } from './utils/math';
 
@@ -50,7 +50,7 @@ interface IPickState {
 }
 
 interface RenderedNode {
-  node: PointCloudOctreeNode;
+  node: IPointCloudTreeNode;
   octree: PointCloudOctree;
 }
 
@@ -191,8 +191,8 @@ export class PointCloudOctreePicker {
     return renderedNodes;
   }
 
-  private static nodesOnRay(octree: PointCloudOctree, ray: Ray): PointCloudOctreeNode[] {
-    const nodesOnRay: PointCloudOctreeNode[] = [];
+  private static nodesOnRay(octree: PointCloudOctree, ray: Ray): IPointCloudTreeNode[] {
+    const nodesOnRay: IPointCloudTreeNode[] = [];
 
     const rayClone = ray.clone();
     for (const node of octree.visibleNodes) {
@@ -231,7 +231,7 @@ export class PointCloudOctreePicker {
 
   private static createTempNodes(
     octree: PointCloudOctree,
-    nodes: PointCloudOctreeNode[],
+    nodes: IPointCloudTreeNode[],
     pickMaterial: PointCloudMaterial,
     nodeIndexOffset: number,
   ): Points[] {
diff --git a/src/PointCloudTree.ts b/src/PointCloudTree.ts
new file mode 100644
index 0000000..ace3b12
--- /dev/null
+++ b/src/PointCloudTree.ts
@@ -0,0 +1,10 @@
+import { Object3D } from 'three';
+import { IPointCloudTreeNodeBase } from "./types/IPointCloudTreeNodeBase";
+
+export class PointCloudTree extends Object3D {
+  root: IPointCloudTreeNodeBase | undefined = undefined;
+
+  initialized() {
+    return this.root !== undefined;
+  }
+}
diff --git a/src/index.ts b/src/index.ts
index 5c6ae95..00d9c90 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -1,11 +1,11 @@
 export * from './materials';
-export * from './point-attributes';
-export * from './point-cloud-octree-geometry-node';
-export * from './point-cloud-octree-geometry';
-export * from './point-cloud-octree-node';
-export * from './point-cloud-octree-picker';
-export * from './point-cloud-octree';
-export * from './point-cloud-tree';
+export * from './PointAttributes';
+export * from './PointCloudOctreeGeometryNode';
+export * from './PointCloudOctreeGeometry';
+export * from './PointCloudOctreeNode';
+export * from './PointCloudOctreePicker';
+export * from './PointCloudOctree';
+export * from './PointCloudTree';
 export * from './potree';
 export * from './types';
 export * from './version';
diff --git a/src/libs/ept/ParseBuffer.js b/src/libs/ept/ParseBuffer.js
new file mode 100644
index 0000000..104d2d0
--- /dev/null
+++ b/src/libs/ept/ParseBuffer.js
@@ -0,0 +1,207 @@
+function parseEpt(event) {
+	let buffer = event.data.buffer;
+	let view = new DataView(buffer);
+	let schema = event.data.schema;
+	let scale = event.data.scale;
+	let offset = event.data.offset;
+	let mins = event.data.mins;
+
+	let dimensions = schema.reduce((p, c) => {
+		p[c.name] = c;
+		return p;
+	}, { });
+
+	let dimOffset = (name) => {
+		let offset = 0;
+		for (var i = 0; i < schema.length; ++i) {
+			if (schema[i].name == name) return offset;
+			offset += schema[i].size;
+		}
+		return undefined;
+	};
+
+	let getExtractor = (name) => {
+		let offset = dimOffset(name);
+		let type = dimensions[name].type;
+		let size = dimensions[name].size;
+
+		if (type == 'signed') switch (size) {
+			case 1: return (p) => view.getInt8(p + offset);
+			case 2: return (p) => view.getInt16(p + offset, true);
+			case 4: return (p) => view.getInt32(p + offset, true);
+			case 8: return (p) => view.getInt64(p + offset, true);
+		}
+		if (type == 'unsigned') switch (size) {
+			case 1: return (p) => view.getUint8(p + offset);
+			case 2: return (p) => view.getUint16(p + offset, true);
+			case 4: return (p) => view.getUint32(p + offset, true);
+			case 8: return (p) => view.getUint64(p + offset, true);
+		}
+		if (type == 'float') switch (size) {
+			case 4: return (p) => view.getFloat32(p + offset, true);
+			case 8: return (p) => view.getFloat64(p + offset, true);
+		}
+
+		let str = JSON.stringify(dimensions[name]);
+		throw new Error(`Invalid dimension specification for ${name}: ${str}`);
+	};
+
+	let pointSize = schema.reduce((p, c) => p + c.size, 0);
+	let numPoints = buffer.byteLength / pointSize;
+
+	let xyzBuffer, rgbBuffer, intensityBuffer, classificationBuffer,
+		returnNumberBuffer, numberOfReturnsBuffer, pointSourceIdBuffer;
+	let xyz, rgb, intensity, classification, returnNumber, numberOfReturns,
+		pointSourceId;
+	let xyzExtractor, rgbExtractor, intensityExtractor, classificationExtractor,
+		returnNumberExtractor, numberOfReturnsExtractor, pointSourceIdExtractor;
+	let twoByteColor = false;
+
+	if (dimensions['X'] && dimensions['Y'] && dimensions['Z']) {
+		xyzBuffer = new ArrayBuffer(numPoints * 4 * 3);
+		xyz = new Float32Array(xyzBuffer);
+		xyzExtractor = [
+			getExtractor('X'),
+			getExtractor('Y'),
+			getExtractor('Z')
+		];
+	}
+
+	if (dimensions['Red'] && dimensions['Green'] && dimensions['Blue']) {
+		rgbBuffer = new ArrayBuffer(numPoints * 4);
+		rgb = new Uint8Array(rgbBuffer);
+		rgbExtractor = [
+			getExtractor('Red'),
+			getExtractor('Green'),
+			getExtractor('Blue')
+		];
+
+		let r, g, b, pos;
+		for (let i = 0; i < numPoints && !twoByteColor; ++i) {
+			pos = i * pointSize;
+			r = rgbExtractor[0](pos);
+			g = rgbExtractor[1](pos);
+			b = rgbExtractor[2](pos);
+			if (r > 255 || g > 255 || b > 255) twoByteColor = true;
+		}
+	}
+
+	if (dimensions['Intensity']) {
+		intensityBuffer = new ArrayBuffer(numPoints * 4);
+		intensity = new Float32Array(intensityBuffer);
+		intensityExtractor = getExtractor('Intensity');
+	}
+
+	if (dimensions['Classification']) {
+		classificationBuffer = new ArrayBuffer(numPoints);
+		classification = new Uint8Array(classificationBuffer);
+		classificationExtractor = getExtractor('Classification');
+	}
+
+	if (dimensions['ReturnNumber']) {
+		returnNumberBuffer = new ArrayBuffer(numPoints);
+		returnNumber = new Uint8Array(returnNumberBuffer);
+		returnNumberExtractor = getExtractor('ReturnNumber');
+	}
+
+	if (dimensions['NumberOfReturns']) {
+		numberOfReturnsBuffer = new ArrayBuffer(numPoints);
+		numberOfReturns = new Uint8Array(numberOfReturnsBuffer);
+		numberOfReturnsExtractor = getExtractor('NumberOfReturns');
+	}
+
+	if (dimensions['PointSourceId']) {
+		pointSourceIdBuffer = new ArrayBuffer(numPoints * 2);
+		pointSourceId = new Uint16Array(pointSourceIdBuffer);
+		pointSourceIdExtractor = getExtractor('PointSourceId');
+	}
+
+	let mean = [0, 0, 0];
+	let bounds = {
+		min: [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE],
+		max: [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE],
+	};
+
+	let x, y, z, r, g, b;
+	for (let i = 0; i < numPoints; ++i) {
+		let pos = i * pointSize;
+		if (xyz) {
+			x = xyzExtractor[0](pos) * scale.x + offset.x - mins[0];
+			y = xyzExtractor[1](pos) * scale.y + offset.y - mins[1];
+			z = xyzExtractor[2](pos) * scale.z + offset.z - mins[2];
+
+			mean[0] += x / numPoints;
+			mean[1] += y / numPoints;
+			mean[2] += z / numPoints;
+
+			bounds.min[0] = Math.min(bounds.min[0], x);
+			bounds.min[1] = Math.min(bounds.min[1], y);
+			bounds.min[2] = Math.min(bounds.min[2], z);
+
+			bounds.max[0] = Math.max(bounds.max[0], x);
+			bounds.max[1] = Math.max(bounds.max[1], y);
+			bounds.max[2] = Math.max(bounds.max[2], z);
+
+			xyz[3 * i + 0] = x;
+			xyz[3 * i + 1] = y;
+			xyz[3 * i + 2] = z;
+		}
+
+		if (rgb) {
+			r = rgbExtractor[0](pos);
+			g = rgbExtractor[1](pos);
+			b = rgbExtractor[2](pos);
+
+			if (twoByteColor) {
+				r /= 256;
+				g /= 256;
+				b /= 256;
+			}
+
+			rgb[4 * i + 0] = r;
+			rgb[4 * i + 1] = g;
+			rgb[4 * i + 2] = b;
+		}
+
+		if (intensity) intensity[i] = intensityExtractor(pos);
+		if (classification) classification[i] = classificationExtractor(pos);
+		if (returnNumber) returnNumber[i] = returnNumberExtractor(pos);
+		if (numberOfReturns) numberOfReturns[i] = numberOfReturnsExtractor(pos);
+		if (pointSourceId) pointSourceId[i] = pointSourceIdExtractor(pos);
+	}
+
+	let indicesBuffer = new ArrayBuffer(numPoints * 4);
+	let indices = new Uint32Array(indicesBuffer);
+	for (let i = 0; i < numPoints; ++i) {
+		indices[i] = i;
+	}
+
+	let message = {
+		numPoints: numPoints,
+		tightBoundingBox: bounds,
+		mean: mean,
+
+		position: xyzBuffer,
+		color: rgbBuffer,
+		intensity: intensityBuffer,
+		classification: classificationBuffer,
+		returnNumber: returnNumberBuffer,
+		numberOfReturns: numberOfReturnsBuffer,
+		pointSourceId: pointSourceIdBuffer,
+		indices: indicesBuffer
+	};
+
+	let transferables = [
+		message.position,
+		message.color,
+		message.intensity,
+		message.classification,
+		message.returnNumber,
+		message.numberOfReturns,
+		message.pointSourceId,
+		message.indices
+	].filter((v) => v);
+
+	postMessage(message, transferables);
+}
+
diff --git a/src/loading/EptLoader.ts b/src/loading/EptLoader.ts
new file mode 100644
index 0000000..5751d1d
--- /dev/null
+++ b/src/loading/EptLoader.ts
@@ -0,0 +1,25 @@
+/**
+ * @author Connor Manning
+ */
+
+import { PointCloudEptGeometry } from '../PointCloudEptGeometry';
+import { PointCloudEptGeometryNode } from "../PointCloudEptGeometryNode";
+
+export class EptLoader {
+  static async load(fullUrl: string): Promise<PointCloudEptGeometry> {
+    return new Promise<PointCloudEptGeometry>(async (res, _rej) => {
+      const response = await fetch(fullUrl);
+      const json = await response.json();
+
+      const url = fullUrl.substr(0, fullUrl.lastIndexOf('ept.json'));
+      const geometry = new PointCloudEptGeometry(url, json);
+      const root = new PointCloudEptGeometryNode(geometry);
+
+      geometry.root = root;
+      geometry.root.load();
+
+      res(geometry);
+		// callback(geometry);
+    });
+  }
+}
diff --git a/src/loading/binary-loader.ts b/src/loading/binary-loader.ts
index 2b27540..aa7f3ea 100644
--- a/src/loading/binary-loader.ts
+++ b/src/loading/binary-loader.ts
@@ -3,8 +3,8 @@
 // -------------------------------------------------------------------------------------------------
 
 import { Box3, BufferAttribute, BufferGeometry, Uint8BufferAttribute, Vector3 } from 'three';
-import { PointAttributeName, PointAttributeType } from '../point-attributes';
-import { PointCloudOctreeGeometryNode } from '../point-cloud-octree-geometry-node';
+import { PointAttributeName, PointAttributeType } from '../PointAttributes';
+import { PointCloudOctreeGeometryNode } from '../PointCloudOctreeGeometryNode';
 import { Version } from '../version';
 import { GetUrlFn, XhrRequest } from './types';
 
diff --git a/src/loading/ept/BinaryLoader.ts b/src/loading/ept/BinaryLoader.ts
new file mode 100644
index 0000000..3bb69cf
--- /dev/null
+++ b/src/loading/ept/BinaryLoader.ts
@@ -0,0 +1,119 @@
+
+import { PointCloudEptGeometryNode } from "../../PointCloudEptGeometryNode";
+import * as THREE from 'three';
+
+import { XHRFactory } from '../../utils/XHRFactory';
+import { workerPool } from '../../utils/WorkerPool';
+
+import { ILoader } from './ILoader';
+
+export class EptBinaryLoader implements ILoader{
+  extension() {
+    return '.bin';
+  }
+
+  workerPath() {
+    // return Potree.scriptPath + './workers/EptBinaryDecoderWorker.js';
+    return './workers/EptBinaryDecoderWorker.js';
+  }
+
+  load(node: any) {
+    if (node.loaded) return;
+
+    let url = node.url() + this.extension();
+
+    let xhr = XHRFactory.createXMLHttpRequest();
+    xhr.open('GET', url, true);
+    xhr.responseType = 'arraybuffer';
+    xhr.overrideMimeType('text/plain; charset=x-user-defined');
+    xhr.onreadystatechange = () => {
+      if (xhr.readyState === 4) {
+	if (xhr.status === 200) {
+	  let buffer = xhr.response;
+	  this.parse(node, buffer);
+	} else {
+	  console.log('Failed ' + url + ': ' + xhr.status);
+	}
+      }
+    };
+
+    try {
+      xhr.send(null);
+    }
+    catch (e) {
+      console.log('Failed request: ' + e);
+    }
+  }
+
+  parse(node: PointCloudEptGeometryNode, buffer: ArrayBuffer) {
+    let workerPath = this.workerPath();
+    let worker = workerPool.getWorker(workerPath);
+
+    worker.onmessage = function(e: any) {
+      let g = new THREE.BufferGeometry();
+      let numPoints = e.data.numPoints;
+
+      let position = new Float32Array(e.data.position);
+      g.setAttribute('position', new THREE.BufferAttribute(position, 3));
+
+      let indices = new Uint8Array(e.data.indices);
+      g.setAttribute('indices', new THREE.BufferAttribute(indices, 4));
+
+      if (e.data.color) {
+	let color = new Uint8Array(e.data.color);
+	g.setAttribute('color', new THREE.BufferAttribute(color, 4, true));
+      }
+      if (e.data.intensity) {
+	let intensity = new Float32Array(e.data.intensity);
+	g.setAttribute('intensity',
+		       new THREE.BufferAttribute(intensity, 1));
+      }
+      if (e.data.classification) {
+	let classification = new Uint8Array(e.data.classification);
+	g.setAttribute('classification',
+		       new THREE.BufferAttribute(classification, 1));
+      }
+      if (e.data.returnNumber) {
+	let returnNumber = new Uint8Array(e.data.returnNumber);
+	g.setAttribute('return number',
+		       new THREE.BufferAttribute(returnNumber, 1));
+      }
+      if (e.data.numberOfReturns) {
+	let numberOfReturns = new Uint8Array(e.data.numberOfReturns);
+	g.setAttribute('number of returns',
+		       new THREE.BufferAttribute(numberOfReturns, 1));
+      }
+      if (e.data.pointSourceId) {
+	let pointSourceId = new Uint16Array(e.data.pointSourceId);
+	g.setAttribute('source id',
+		       new THREE.BufferAttribute(pointSourceId, 1));
+      }
+
+      g.attributes.indices.normalized = true;
+
+      let tightBoundingBox = new THREE.Box3(
+	new THREE.Vector3().fromArray(e.data.tightBoundingBox.min),
+	new THREE.Vector3().fromArray(e.data.tightBoundingBox.max)
+      );
+
+      node.doneLoading(
+	g,
+	tightBoundingBox,
+	numPoints,
+	new THREE.Vector3(...e.data.mean));
+
+      workerPool.returnWorker(workerPath, worker);
+    };
+
+    let toArray = (v: THREE.Vector3) => [v.x, v.y, v.z];
+    let message = {
+      buffer: buffer,
+      schema: node.ept.schema,
+      scale: node.ept.eptScale,
+      offset: node.ept.eptOffset,
+      mins: toArray(node.key.b.min)
+    };
+
+    worker.postMessage(message, [message.buffer]);
+  }
+};
diff --git a/src/loading/ept/ILoader.ts b/src/loading/ept/ILoader.ts
new file mode 100644
index 0000000..cdbcc58
--- /dev/null
+++ b/src/loading/ept/ILoader.ts
@@ -0,0 +1,9 @@
+/*!
+ * Copyright 2022 Cognite AS
+ */
+
+export interface ILoader {
+  load(node: any): void;
+
+  parse(node: any, buffer: ArrayBuffer): void;
+}
diff --git a/src/loading/ept/LaszipLoader.js b/src/loading/ept/LaszipLoader.js
new file mode 100644
index 0000000..40fe98c
--- /dev/null
+++ b/src/loading/ept/LaszipLoader.js
@@ -0,0 +1,176 @@
+
+import * as THREE from "../../../libs/three.js/build/three.module.js";
+import {XHRFactory} from "../../XHRFactory.js";
+
+/**
+ * laslaz code taken and adapted from plas.io js-laslaz
+ *	  http://plas.io/
+ *	https://github.com/verma/plasio
+ *
+ * Thanks to Uday Verma and Howard Butler
+ *
+ */
+
+export class EptLaszipLoader {
+	load(node) {
+		if (node.loaded) return;
+
+		let url = node.url() + '.laz';
+
+		let xhr = XHRFactory.createXMLHttpRequest();
+		xhr.open('GET', url, true);
+		xhr.responseType = 'arraybuffer';
+		xhr.overrideMimeType('text/plain; charset=x-user-defined');
+		xhr.onreadystatechange = () => {
+			if (xhr.readyState === 4) {
+				if (xhr.status === 200) {
+					let buffer = xhr.response;
+					this.parse(node, buffer);
+				} else {
+					console.log('Failed ' + url + ': ' + xhr.status);
+				}
+			}
+		};
+
+		xhr.send(null);
+	}
+
+	async parse(node, buffer){
+		let lf = new LASFile(buffer);
+		let handler = new EptLazBatcher(node);
+
+		try{
+			await lf.open();
+
+			lf.isOpen = true;
+
+			const header = await lf.getHeader();
+
+			{
+				let i = 0;
+
+				let toArray = (v) => [v.x, v.y, v.z];
+				let mins = toArray(node.key.b.min);
+				let maxs = toArray(node.key.b.max);
+
+				let hasMoreData = true;
+
+				while(hasMoreData){
+					const data = await lf.readData(1000000, 0, 1);
+
+					let d = new LASDecoder(
+						data.buffer,
+						header.pointsFormatId,
+						header.pointsStructSize,
+						data.count,
+						header.scale,
+						header.offset,
+						mins,
+						maxs);
+
+					d.extraBytes = header.extraBytes;
+					d.pointsFormatId = header.pointsFormatId;
+					handler.push(d);
+
+					i += data.count;
+
+					hasMoreData = data.hasMoreData;
+				}
+
+				header.totalRead = i;
+				header.versionAsString = lf.versionAsString;
+				header.isCompressed = lf.isCompressed;
+
+				await lf.close();
+
+				lf.isOpen = false;
+			}
+
+		}catch(err){
+			console.error('Error reading LAZ:', err);
+			
+			if (lf.isOpen) {
+				await lf.close();
+
+				lf.isOpen = false;
+			}
+			
+			throw err;
+		}
+	}
+};
+
+export class EptLazBatcher {
+	constructor(node) { this.node = node; }
+
+	push(las) {
+		let workerPath = Potree.scriptPath +
+			'/workers/EptLaszipDecoderWorker.js';
+		let worker = Potree.workerPool.getWorker(workerPath);
+
+		worker.onmessage = (e) => {
+			let g = new THREE.BufferGeometry();
+			let numPoints = las.pointsCount;
+
+			let positions = new Float32Array(e.data.position);
+			let colors = new Uint8Array(e.data.color);
+
+			let intensities = new Float32Array(e.data.intensity);
+			let classifications = new Uint8Array(e.data.classification);
+			let returnNumbers = new Uint8Array(e.data.returnNumber);
+			let numberOfReturns = new Uint8Array(e.data.numberOfReturns);
+			let pointSourceIDs = new Uint16Array(e.data.pointSourceID);
+			let indices = new Uint8Array(e.data.indices);
+			let gpsTime = new Float32Array(e.data.gpsTime);
+
+			g.setAttribute('position',
+					new THREE.BufferAttribute(positions, 3));
+			g.setAttribute('rgba',
+					new THREE.BufferAttribute(colors, 4, true));
+			g.setAttribute('intensity',
+					new THREE.BufferAttribute(intensities, 1));
+			g.setAttribute('classification',
+					new THREE.BufferAttribute(classifications, 1));
+			g.setAttribute('return number',
+					new THREE.BufferAttribute(returnNumbers, 1));
+			g.setAttribute('number of returns',
+					new THREE.BufferAttribute(numberOfReturns, 1));
+			g.setAttribute('source id',
+					new THREE.BufferAttribute(pointSourceIDs, 1));
+			g.setAttribute('indices',
+					new THREE.BufferAttribute(indices, 4));
+			g.setAttribute('gpsTime',
+					new THREE.BufferAttribute(gpsTime, 1));
+			this.node.gpsTime = e.data.gpsMeta;
+
+			g.attributes.indices.normalized = true;
+
+			let tightBoundingBox = new THREE.Box3(
+				new THREE.Vector3().fromArray(e.data.tightBoundingBox.min),
+				new THREE.Vector3().fromArray(e.data.tightBoundingBox.max)
+			);
+
+			this.node.doneLoading(
+				g,
+				tightBoundingBox,
+				numPoints,
+				new THREE.Vector3(...e.data.mean));
+
+			Potree.workerPool.returnWorker(workerPath, worker);
+		};
+
+		let message = {
+			buffer: las.arrayb,
+			numPoints: las.pointsCount,
+			pointSize: las.pointSize,
+			pointFormatID: las.pointsFormatId,
+			scale: las.scale,
+			offset: las.offset,
+			mins: las.mins,
+			maxs: las.maxs
+		};
+
+		worker.postMessage(message, [message.buffer]);
+	};
+};
+
diff --git a/src/loading/ept/ZstandardLoader.js b/src/loading/ept/ZstandardLoader.js
new file mode 100644
index 0000000..ac7a687
--- /dev/null
+++ b/src/loading/ept/ZstandardLoader.js
@@ -0,0 +1,12 @@
+import {EptBinaryLoader} from "./BinaryLoader.js";
+
+export class EptZstandardLoader extends EptBinaryLoader {
+    extension() {
+        return '.zst';
+    }
+
+    workerPath() {
+        return Potree.scriptPath + '/workers/EptZstandardDecoderWorker.js';
+    }
+};
+
diff --git a/src/loading/globalLoadingCounter.ts b/src/loading/globalLoadingCounter.ts
new file mode 100644
index 0000000..e95f115
--- /dev/null
+++ b/src/loading/globalLoadingCounter.ts
@@ -0,0 +1,16 @@
+
+let globalNumNodesLoading: number = 0;
+const globalMaxNumNodesLoading: number = 10;
+
+export {
+  globalNumNodesLoading,
+  globalMaxNumNodesLoading
+};
+
+export function incrementGlobalNumNodesLoading() {
+  globalNumNodesLoading++;
+}
+
+export function decrementGlobalNumNodesLoading() {
+  globalNumNodesLoading--;
+}
diff --git a/src/loading/load-poc.ts b/src/loading/load-poc.ts
index c679042..2d0ef2e 100644
--- a/src/loading/load-poc.ts
+++ b/src/loading/load-poc.ts
@@ -3,9 +3,9 @@
 // -------------------------------------------------------------------------------------------------
 
 import { Box3, Vector3 } from 'three';
-import { PointAttributes, PointAttributeStringName } from '../point-attributes';
-import { PointCloudOctreeGeometry } from '../point-cloud-octree-geometry';
-import { PointCloudOctreeGeometryNode } from '../point-cloud-octree-geometry-node';
+import { PointAttributes, PointAttributeStringName } from '../PointAttributes';
+import { PointCloudOctreeGeometry } from '../PointCloudOctreeGeometry';
+import { PointCloudOctreeGeometryNode } from '../PointCloudOctreeGeometryNode';
 import { createChildAABB } from '../utils/bounds';
 import { getIndexFromName } from '../utils/utils';
 import { Version } from '../version';
diff --git a/src/materials/point-cloud-material.ts b/src/materials/PointCloudMaterial.ts
similarity index 98%
rename from src/materials/point-cloud-material.ts
rename to src/materials/PointCloudMaterial.ts
index 4566f06..5fe27c7 100644
--- a/src/materials/point-cloud-material.ts
+++ b/src/materials/PointCloudMaterial.ts
@@ -25,8 +25,9 @@ import {
   DEFAULT_RGB_GAMMA,
   PERSPECTIVE_CAMERA,
 } from '../constants';
-import { PointCloudOctree } from '../point-cloud-octree';
-import { PointCloudOctreeNode } from '../point-cloud-octree-node';
+import { PointCloudOctree } from '../PointCloudOctree';
+import { IPointCloudTreeNodeBase } from "../types/IPointCloudTreeNodeBase";
+import { IPointCloudTreeNode } from '../types/IPointCloudTreeNode';
 import { byLevelAndIndex } from '../utils/utils';
 import { DEFAULT_CLASSIFICATION } from './classification';
 import { ClipMode, IClipBox } from './clipping';
@@ -516,7 +517,7 @@ export class PointCloudMaterial extends RawShaderMaterial {
 
   updateMaterial(
     octree: PointCloudOctree,
-    visibleNodes: PointCloudOctreeNode[],
+    visibleNodes: IPointCloudTreeNodeBase[],
     camera: Camera,
     renderer: WebGLRenderer,
   ): void {
@@ -548,7 +549,7 @@ export class PointCloudMaterial extends RawShaderMaterial {
     }
   }
 
-  private updateVisibilityTextureData(nodes: PointCloudOctreeNode[]) {
+  private updateVisibilityTextureData(nodes: IPointCloudTreeNodeBase[]) {
     nodes.sort(byLevelAndIndex);
 
     const data = new Uint8Array(nodes.length * 4);
@@ -588,7 +589,7 @@ export class PointCloudMaterial extends RawShaderMaterial {
 
   static makeOnBeforeRender(
     octree: PointCloudOctree,
-    node: PointCloudOctreeNode,
+    node: IPointCloudTreeNode,
     pcIndex?: number,
   ) {
     return (
diff --git a/src/materials/index.ts b/src/materials/index.ts
index d2002d2..b79302c 100644
--- a/src/materials/index.ts
+++ b/src/materials/index.ts
@@ -1,7 +1,7 @@
 export * from './blur-material';
 export * from './clipping';
 export * from './enums';
-export * from './point-cloud-material';
+export * from './PointCloudMaterial';
 export * from './texture-generation';
 export * from './types';
 export * from './gradients';
diff --git a/src/point-cloud-tree.ts b/src/point-cloud-tree.ts
deleted file mode 100644
index 62274cd..0000000
--- a/src/point-cloud-tree.ts
+++ /dev/null
@@ -1,10 +0,0 @@
-import { Object3D } from 'three';
-import { IPointCloudTreeNode } from './types';
-
-export class PointCloudTree extends Object3D {
-  root: IPointCloudTreeNode | null = null;
-
-  initialized() {
-    return this.root !== null;
-  }
-}
diff --git a/src/potree.ts b/src/potree.ts
index 0f0a876..4c4c1a2 100644
--- a/src/potree.ts
+++ b/src/potree.ts
@@ -17,14 +17,18 @@ import {
   PERSPECTIVE_CAMERA,
 } from './constants';
 import { FEATURES } from './features';
-import { GetUrlFn, loadPOC } from './loading';
+import { GetUrlFn /* , loadPOC */ } from './loading';
+import { EptLoader } from './loading/EptLoader';
 import { ClipMode } from './materials';
-import { PointCloudOctree } from './point-cloud-octree';
-import { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';
-import { PointCloudOctreeNode } from './point-cloud-octree-node';
-import { PickParams, PointCloudOctreePicker } from './point-cloud-octree-picker';
+import { PointCloudOctree } from './PointCloudOctree';
+import { PointCloudOctreeGeometryNode } from './PointCloudOctreeGeometryNode';
+import { PointCloudOctreeNode } from './PointCloudOctreeNode';
+// import { IPointCloudOctree } from './IPointCloudOctree';
+import { PickParams, PointCloudOctreePicker } from './PointCloudOctreePicker';
 import { isGeometryNode, isTreeNode } from './type-predicates';
-import { IPointCloudTreeNode, IPotree, IVisibilityUpdateResult, PickPoint } from './types';
+import { IPotree, IVisibilityUpdateResult, PickPoint } from './types';
+import { IPointCloudTreeNodeBase } from './types/IPointCloudTreeNodeBase';
+import { IPointCloudTreeNode } from './types/IPointCloudTreeNode';
 import { BinaryHeap } from './utils/binary-heap';
 import { Box3Helper } from './utils/box3-helper';
 import { LRU } from './utils/lru';
@@ -33,8 +37,8 @@ export class QueueItem {
   constructor(
     public pointCloudIndex: number,
     public weight: number,
-    public node: IPointCloudTreeNode,
-    public parent?: IPointCloudTreeNode | null,
+    public node: IPointCloudTreeNodeBase,
+    public parent?: IPointCloudTreeNodeBase | null,
   ) {}
 }
 
@@ -47,12 +51,15 @@ export class Potree implements IPotree {
   features = FEATURES;
   lru = new LRU(this._pointBudget);
 
-  loadPointCloud(
+  async loadPointCloud(
     url: string,
     getUrl: GetUrlFn,
-    xhrRequest = (input: RequestInfo, init?: RequestInit) => fetch(input, init),
+    _xhrRequest = (input: RequestInfo, init?: RequestInit) => fetch(input, init),
   ): Promise<PointCloudOctree> {
-    return loadPOC(url, getUrl, xhrRequest).then(geometry => new PointCloudOctree(this, geometry));
+
+    return EptLoader.load(await getUrl(url)).then(geometry => new PointCloudOctree(this, geometry) );
+    // throw Error("Tried using url = " + url);
+    // return loadPOC(url, getUrl, xhrRequest).then(geometry => new PointCloudOctree(this, geometry));
   }
 
   updatePointClouds(
@@ -200,8 +207,8 @@ export class Potree implements IPotree {
 
   private updateTreeNodeVisibility(
     pointCloud: PointCloudOctree,
-    node: PointCloudOctreeNode,
-    visibleNodes: IPointCloudTreeNode[],
+    node: IPointCloudTreeNode,
+    visibleNodes: IPointCloudTreeNodeBase[],
   ): void {
     this.lru.touch(node.geometryNode);
 
@@ -265,7 +272,7 @@ export class Potree implements IPotree {
 
   private updateBoundingBoxVisibility(
     pointCloud: PointCloudOctree,
-    node: PointCloudOctreeNode,
+    node: IPointCloudTreeNode,
   ): void {
     if (pointCloud.showBoundingBox && !node.boundingBoxNode) {
       const boxHelper = new Box3Helper(node.boundingBox);
@@ -357,12 +364,18 @@ export class Potree implements IPotree {
 
         if (pointCloud.visible && pointCloud.root !== null) {
           const weight = Number.MAX_VALUE;
-          priorityQueue.push(new QueueItem(i, weight, pointCloud.root));
+          priorityQueue.push(new QueueItem(i, weight, pointCloud.root!));
         }
 
         // Hide any previously visible nodes. We will later show only the needed ones.
         if (isTreeNode(pointCloud.root)) {
-          pointCloud.hideDescendants(pointCloud.root.sceneNode);
+          console.log("Point cloud root: ", pointCloud.root);
+          console.log("Scene node: ", pointCloud.root!.sceneNode);
+          try {
+            pointCloud.hideDescendants(pointCloud.root!.sceneNode);
+          } catch (e) {
+            console.log("AAAAAH");
+          }
         }
 
         for (const boundingBoxNode of pointCloud.boundingBoxNodes) {
diff --git a/src/type-predicates.ts b/src/type-predicates.ts
index 894ce24..2ef6f2e 100644
--- a/src/type-predicates.ts
+++ b/src/type-predicates.ts
@@ -1,10 +1,11 @@
-import { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';
-import { PointCloudOctreeNode } from './point-cloud-octree-node';
+import { IPointCloudTreeNodeBase } from 'types/IPointCloudTreeNodeBase';
+import { PointCloudOctreeGeometryNode } from './PointCloudOctreeGeometryNode';
+import { PointCloudOctreeNode } from './PointCloudOctreeNode';
 
 export function isGeometryNode(node?: any): node is PointCloudOctreeGeometryNode {
   return node !== undefined && node !== null && node.isGeometryNode;
 }
 
-export function isTreeNode(node?: any): node is PointCloudOctreeNode {
+export function isTreeNode(node?: IPointCloudTreeNodeBase): boolean /* : node is PointCloudOctreeNode */ {
   return node !== undefined && node !== null && node.isTreeNode;
 }
diff --git a/src/types.ts b/src/types.ts
index 97e5988..dfb8092 100644
--- a/src/types.ts
+++ b/src/types.ts
@@ -1,28 +1,11 @@
-import { Box3, Camera, Sphere, Vector3, WebGLRenderer } from 'three';
+import { Camera, Vector3, WebGLRenderer } from 'three';
 import { GetUrlFn, XhrRequest } from './loading/types';
-import { PointCloudOctree } from './point-cloud-octree';
 import { LRU } from './utils/lru';
-
-export interface IPointCloudTreeNode {
-  id: number;
-  name: string;
-  level: number;
-  index: number;
-  spacing: number;
-  boundingBox: Box3;
-  boundingSphere: Sphere;
-  loaded: boolean;
-  numPoints: number;
-  readonly children: ReadonlyArray<IPointCloudTreeNode | null>;
-  readonly isLeafNode: boolean;
-
-  dispose(): void;
-
-  traverse(cb: (node: IPointCloudTreeNode) => void, includeSelf?: boolean): void;
-}
+import { PointCloudOctree } from './PointCloudOctree';
+import { IPointCloudTreeNodeBase } from './types/IPointCloudTreeNodeBase';
 
 export interface IVisibilityUpdateResult {
-  visibleNodes: IPointCloudTreeNode[];
+  visibleNodes: IPointCloudTreeNodeBase[];
   numVisiblePoints: number;
   /**
    * True when a node has been loaded but was not added to the scene yet.
diff --git a/src/types/IPointCloudTreeGeometryNode.ts b/src/types/IPointCloudTreeGeometryNode.ts
new file mode 100644
index 0000000..6d74a53
--- /dev/null
+++ b/src/types/IPointCloudTreeGeometryNode.ts
@@ -0,0 +1,11 @@
+/*!
+ * Copyright 2022 Cognite AS
+ */
+
+import { IPointCloudTreeNodeBase } from './IPointCloudTreeNodeBase';
+import * as THREE from 'three';
+
+export interface IPointCloudTreeGeometryNode extends IPointCloudTreeNodeBase {
+  geometry: THREE.BufferGeometry | undefined;
+  oneTimeDisposeHandlers: (() => void)[];
+};
diff --git a/src/types/IPointCloudTreeNode.ts b/src/types/IPointCloudTreeNode.ts
new file mode 100644
index 0000000..82115d4
--- /dev/null
+++ b/src/types/IPointCloudTreeNode.ts
@@ -0,0 +1,13 @@
+/*!
+ * Copyright 2022 Cognite AS
+ */
+
+import { IPointCloudTreeNodeBase } from './IPointCloudTreeNodeBase';
+import { IPointCloudTreeGeometryNode } from './IPointCloudTreeGeometryNode';
+
+import * as THREE from 'three';
+
+export interface IPointCloudTreeNode extends IPointCloudTreeNodeBase {
+  sceneNode: THREE.Points;
+  geometryNode: IPointCloudTreeGeometryNode;
+};
diff --git a/src/types/IPointCloudTreeNodeBase.ts b/src/types/IPointCloudTreeNodeBase.ts
new file mode 100644
index 0000000..309a700
--- /dev/null
+++ b/src/types/IPointCloudTreeNodeBase.ts
@@ -0,0 +1,25 @@
+
+import * as THREE from 'three';
+
+
+export interface IPointCloudTreeNodeBase {
+  id: number;
+  name: string;
+  level: number;
+  index: number;
+  spacing: number;
+  boundingBox: THREE.Box3;
+  boundingSphere: THREE.Sphere;
+  loaded: boolean;
+  numPoints: number;
+  isTreeNode: boolean;
+
+  boundingBoxNode?: THREE.Object3D;
+
+  readonly children: Array<IPointCloudTreeNodeBase | null>;
+  readonly isLeafNode: boolean;
+
+  dispose(): void;
+
+  traverse(cb: (node: IPointCloudTreeNodeBase) => void, includeSelf?: boolean): void;
+}
diff --git a/src/utils/WorkerPool.ts b/src/utils/WorkerPool.ts
new file mode 100644
index 0000000..ef8b9da
--- /dev/null
+++ b/src/utils/WorkerPool.ts
@@ -0,0 +1,29 @@
+
+class WorkerPool{
+  private readonly _workers: any;
+
+  constructor(){
+    this._workers = {};
+  }
+
+  getWorker(url: string){
+    if (!this._workers[url]){
+      this._workers[url] = [];
+    }
+
+    if (this._workers[url].length === 0){
+      let worker = new Worker(url);
+      this._workers[url].push(worker);
+    }
+
+    let worker = this._workers[url].pop();
+
+    return worker;
+  }
+
+  returnWorker(url: string, worker: any){
+    this._workers[url].push(worker);
+  }
+};
+
+export const workerPool = new WorkerPool();
diff --git a/src/utils/XHRFactory.ts b/src/utils/XHRFactory.ts
new file mode 100644
index 0000000..fb4d342
--- /dev/null
+++ b/src/utils/XHRFactory.ts
@@ -0,0 +1,32 @@
+
+const XHRFactory = {
+  config: {
+    withCredentials: false,
+    customHeaders: [
+      { header: null, value: null }
+    ]
+  },
+
+  createXMLHttpRequest: function () {
+    let xhr = new XMLHttpRequest();
+
+    if (this.config.customHeaders &&
+      Array.isArray(this.config.customHeaders) &&
+      this.config.customHeaders.length > 0) {
+      let baseOpen = xhr.open;
+      let customHeaders = this.config.customHeaders;
+      xhr.open = function () {
+	baseOpen.apply(this, ([] as any).slice.call(arguments));
+	customHeaders.forEach(function (customHeader: any) {
+	  if (!!customHeader.header && !!customHeader.value) {
+	    xhr.setRequestHeader(customHeader.header, customHeader.value);
+	  }
+	});
+      };
+    }
+
+    return xhr;
+  }
+};
+
+export { XHRFactory };
diff --git a/src/utils/lru.ts b/src/utils/lru.ts
index c134424..a0e0cb9 100644
--- a/src/utils/lru.ts
+++ b/src/utils/lru.ts
@@ -1,6 +1,6 @@
-import { IPointCloudTreeNode } from '../types';
+import { IPointCloudTreeNodeBase } from "../types/IPointCloudTreeNodeBase";
 
-export type Node = IPointCloudTreeNode;
+export type Node = IPointCloudTreeNodeBase;
 
 export class LRUItem {
   next: LRUItem | null = null;
diff --git a/src/utils/utils.ts b/src/utils/utils.ts
index 7c67c33..848d5a2 100644
--- a/src/utils/utils.ts
+++ b/src/utils/utils.ts
@@ -1,4 +1,4 @@
-import { IPointCloudTreeNode } from '../types';
+import { IPointCloudTreeNodeBase } from "../types/IPointCloudTreeNodeBase";
 
 export function getIndexFromName(name: string) {
   return parseInt(name.charAt(name.length - 1), 10);
@@ -7,7 +7,7 @@ export function getIndexFromName(name: string) {
 /**
  * When passed to `[].sort`, sorts the array by level and index: r, r0, r3, r4, r01, r07, r30, ...
  */
-export function byLevelAndIndex(a: IPointCloudTreeNode, b: IPointCloudTreeNode) {
+export function byLevelAndIndex(a: IPointCloudTreeNodeBase, b: IPointCloudTreeNodeBase) {
   const na = a.name;
   const nb = b.name;
   if (na.length !== nb.length) {
diff --git a/src/workers/EptBinaryDecoderWorker.js b/src/workers/EptBinaryDecoderWorker.js
new file mode 100644
index 0000000..b71e11d
--- /dev/null
+++ b/src/workers/EptBinaryDecoderWorker.js
@@ -0,0 +1,5 @@
+// importScripts('/libs/ept/ParseBuffer.js');
+onmessage = function(event) {
+	parseEpt(event);
+}
+
diff --git a/src/workers/binary-decoder-worker-internal.ts b/src/workers/binary-decoder-worker-internal.ts
index 2577cac..2ec699d 100644
--- a/src/workers/binary-decoder-worker-internal.ts
+++ b/src/workers/binary-decoder-worker-internal.ts
@@ -8,7 +8,7 @@ import {
   IPointAttributes,
   PointAttributeName,
   POINT_ATTRIBUTES,
-} from '../point-attributes';
+} from '../PointAttributes';
 import { Version } from '../version';
 import { CustomArrayView } from './custom-array-view';
 
