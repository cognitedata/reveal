{"ast":null,"code":"import head from 'lodash/head';\nimport isArray from 'lodash/isArray';\nimport unset from 'lodash/unset';\n/**\n * Tech debt: Remove me once api is shifted over to latest\n */\nexport const transformNewFilterToOldFilter = filter => {\n  if (filter === undefined) {\n    return {};\n  }\n  if (filter.internalId) {\n    filter = {\n      ...filter,\n      internalId: undefined\n    };\n  }\n  if (filter.metadata && isArray(filter.metadata)) {\n    filter = {\n      ...filter,\n      metadata: filter.metadata.reduce((accumulator, {\n        key,\n        value\n      }) => {\n        return {\n          ...accumulator,\n          [key]: value\n        };\n      }, {})\n    };\n  }\n\n  // TODO: Remove this when migrated\n  if (filter.assetSubtreeIds) {\n    filter = {\n      ...filter,\n      assetSubtreeIds: filter?.assetSubtreeIds?.map(({\n        value\n      }) => ({\n        id: value\n      }))\n    };\n  }\n  if (filter.dataSetIds) {\n    filter = {\n      ...filter,\n      dataSetIds: filter?.dataSetIds?.map(({\n        value\n      }) => ({\n        id: value\n      }))\n    };\n  }\n  if (filter.labels) {\n    filter = {\n      ...filter,\n      labels: {\n        containsAny: filter?.labels?.map(({\n          value\n        }) => ({\n          externalId: value\n        }))\n      }\n    };\n  }\n\n  /**\n   * Here, `source` is supposed to be a string value.\n   * Since now we filter by multiple sources, passing an array result in a request error.\n   * Hence, set the source to the first value of sources.\n   */\n  if (filter.sources) {\n    filter = {\n      ...filter,\n      source: head(filter.sources).value\n    };\n  }\n\n  /**\n   * `sources` is not supported in the old filter.\n   */\n  unset(filter, 'sources');\n  return filter;\n};","map":{"version":3,"names":["head","isArray","unset","transformNewFilterToOldFilter","filter","undefined","internalId","metadata","reduce","accumulator","key","value","assetSubtreeIds","map","id","dataSetIds","labels","containsAny","externalId","sources","source"],"sources":["/Volumes/csvol/fusion/libs/data-exploration/domain-layer/src/transformers.ts"],"sourcesContent":["import head from 'lodash/head';\nimport isArray from 'lodash/isArray';\nimport isEmpty from 'lodash/isEmpty';\nimport take from 'lodash/take';\nimport unset from 'lodash/unset';\n\nimport { isObjectEmpty } from '@data-exploration-lib/core';\n\nimport { InternalAssetData } from './assets';\nimport { MAX_METADATA_KEYS } from './constants';\nimport { InternalEventsData } from './events';\n\n/**\n * Tech debt: Remove me once api is shifted over to latest\n */\nexport const transformNewFilterToOldFilter = <T>(\n  filter?: any\n): T | undefined => {\n  if (filter === undefined) {\n    return {} as T;\n  }\n\n  if (filter.internalId) {\n    filter = {\n      ...filter,\n      internalId: undefined,\n    };\n  }\n\n  if (filter.metadata && isArray(filter.metadata)) {\n    filter = {\n      ...filter,\n      metadata: (filter.metadata as { key: string; value: string }[]).reduce(\n        (accumulator, { key, value }) => {\n          return {\n            ...accumulator,\n            [key]: value,\n          };\n        },\n        {} as Record<string, unknown>\n      ),\n    };\n  }\n\n  // TODO: Remove this when migrated\n  if (filter.assetSubtreeIds) {\n    filter = {\n      ...filter,\n      assetSubtreeIds: filter?.assetSubtreeIds?.map(({ value }: any) => ({\n        id: value,\n      })) as any,\n    };\n  }\n\n  if (filter.dataSetIds) {\n    filter = {\n      ...filter,\n      dataSetIds: filter?.dataSetIds?.map(({ value }: any) => ({\n        id: value,\n      })) as any,\n    };\n  }\n\n  if (filter.labels) {\n    filter = {\n      ...filter,\n      labels: {\n        containsAny: filter?.labels?.map(({ value }: any) => ({\n          externalId: value,\n        })),\n      },\n    };\n  }\n\n  /**\n   * Here, `source` is supposed to be a string value.\n   * Since now we filter by multiple sources, passing an array result in a request error.\n   * Hence, set the source to the first value of sources.\n   */\n  if (filter.sources) {\n    filter = {\n      ...filter,\n      source: (head(filter.sources) as { value: string }).value,\n    };\n  }\n\n  /**\n   * `sources` is not supported in the old filter.\n   */\n  unset(filter, 'sources');\n\n  return filter as T;\n};\n\ntype ResourceTypeData = InternalEventsData | InternalAssetData;\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,aAAa;AAC9B,OAAOC,OAAO,MAAM,gBAAgB;AAGpC,OAAOC,KAAK,MAAM,cAAc;AAQhC;AACA;AACA;AACA,OAAO,MAAMC,6BAA6B,GACxCC,MAAY,IACM;EAClB,IAAIA,MAAM,KAAKC,SAAS,EAAE;IACxB,OAAO,CAAC,CAAC;EACX;EAEA,IAAID,MAAM,CAACE,UAAU,EAAE;IACrBF,MAAM,GAAG;MACP,GAAGA,MAAM;MACTE,UAAU,EAAED;IACd,CAAC;EACH;EAEA,IAAID,MAAM,CAACG,QAAQ,IAAIN,OAAO,CAACG,MAAM,CAACG,QAAQ,CAAC,EAAE;IAC/CH,MAAM,GAAG;MACP,GAAGA,MAAM;MACTG,QAAQ,EAAGH,MAAM,CAACG,QAAQ,CAAsCC,MAAM,CACpE,CAACC,WAAW,EAAE;QAAEC,GAAG;QAAEC;MAAM,CAAC,KAAK;QAC/B,OAAO;UACL,GAAGF,WAAW;UACd,CAACC,GAAG,GAAGC;QACT,CAAC;MACH,CAAC,EACD,CAAC,CAAC;IAEN,CAAC;EACH;;EAEA;EACA,IAAIP,MAAM,CAACQ,eAAe,EAAE;IAC1BR,MAAM,GAAG;MACP,GAAGA,MAAM;MACTQ,eAAe,EAAER,MAAM,EAAEQ,eAAe,EAAEC,GAAG,CAAC,CAAC;QAAEF;MAAW,CAAC,MAAM;QACjEG,EAAE,EAAEH;MACN,CAAC,CAAC;IACJ,CAAC;EACH;EAEA,IAAIP,MAAM,CAACW,UAAU,EAAE;IACrBX,MAAM,GAAG;MACP,GAAGA,MAAM;MACTW,UAAU,EAAEX,MAAM,EAAEW,UAAU,EAAEF,GAAG,CAAC,CAAC;QAAEF;MAAW,CAAC,MAAM;QACvDG,EAAE,EAAEH;MACN,CAAC,CAAC;IACJ,CAAC;EACH;EAEA,IAAIP,MAAM,CAACY,MAAM,EAAE;IACjBZ,MAAM,GAAG;MACP,GAAGA,MAAM;MACTY,MAAM,EAAE;QACNC,WAAW,EAAEb,MAAM,EAAEY,MAAM,EAAEH,GAAG,CAAC,CAAC;UAAEF;QAAW,CAAC,MAAM;UACpDO,UAAU,EAAEP;QACd,CAAC,CAAC;MACJ;IACF,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIP,MAAM,CAACe,OAAO,EAAE;IAClBf,MAAM,GAAG;MACP,GAAGA,MAAM;MACTgB,MAAM,EAAGpB,IAAI,CAACI,MAAM,CAACe,OAAO,CAAC,CAAuBR;IACtD,CAAC;EACH;;EAEA;AACF;AACA;EACET,KAAK,CAACE,MAAM,EAAE,SAAS,CAAC;EAExB,OAAOA,MAAM;AACf,CAAC"},"metadata":{},"sourceType":"module"}