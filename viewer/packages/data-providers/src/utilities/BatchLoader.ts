/*!
 * Copyright 2025 Cognite AS
 */

/**
 * Generic batch loader for accumulating and processing requests in batches.
 * This prevents overwhelming APIs with thousands of individual requests by grouping them.
 *
 * Example use cases:
 * - Batching DMS queries for multiple 360 image collections
 * - Batching CDF Events/Files API calls for event-based 360 images
 * - Batching point cloud data fetching
 *
 * @template TIdentifier - Type of the identifier used to request data (e.g., DMInstanceRef, string)
 * @template TResult - Type of the result returned for each identifier
 */
export abstract class BatchLoader<TIdentifier, TResult> {
  private readonly _pendingBatch: Array<{
    identifier: TIdentifier;
    resolve: (result: TResult) => void;
    reject: (error: unknown) => void;
  }> = [];
  private _batchTimer: ReturnType<typeof setTimeout> | null = null;
  private _isProcessing = false;

  /**
   * @param _batchSize - Maximum number of identifiers to process in a single batch
   * @param _batchDelayMs - Delay in milliseconds to wait for more requests before executing batch
   */
  constructor(
    private readonly _batchSize: number,
    private readonly _batchDelayMs: number
  ) {}

  /**
   * Load data for the given identifier. Requests are automatically batched.
   *
   * @param identifier - The identifier to load data for
   * @returns Promise that resolves with the result for this identifier
   */
  public async load(identifier: TIdentifier): Promise<TResult> {
    return new Promise((resolve, reject) => {
      this._pendingBatch.push({ identifier, resolve, reject });

      // Clear existing timer
      if (this._batchTimer) {
        clearTimeout(this._batchTimer);
      }

      // If we've hit the batch size, execute immediately
      if (this._pendingBatch.length >= this._batchSize) {
        void this.tryExecuteBatch();
      } else {
        // Otherwise, wait a bit to accumulate more requests
        this._batchTimer = setTimeout(() => {
          void this.tryExecuteBatch();
        }, this._batchDelayMs);
      }
    });
  }

  /**
   * Try to execute a batch. If already processing, this will be a no-op.
   * The next batch will be picked up when the current one finishes.
   */
  private async tryExecuteBatch(): Promise<void> {
    if (this._isProcessing || this._pendingBatch.length === 0) {
      return;
    }

    this._isProcessing = true;

    // Atomically extract up to _batchSize items to prevent race condition
    // where items are added between checking the length and executing
    const batchToProcess = this._pendingBatch.splice(0, this._batchSize);
    this._batchTimer = null;

    try {
      await this.executeBatch(batchToProcess);
    } finally {
      this._isProcessing = false;

      // If there are more pending requests, process the next batch
      if (this._pendingBatch.length > 0) {
        // Small delay before next batch to avoid rapid-fire requests
        setTimeout(() => {
          void this.tryExecuteBatch();
        }, 50);
      }
    }
  }

  /**
   * Execute a batch of requests.
   */
  private async executeBatch(
    batch: Array<{
      identifier: TIdentifier;
      resolve: (result: TResult) => void;
      reject: (error: unknown) => void;
    }>
  ): Promise<void> {
    const identifiers = batch.map(item => item.identifier);

    try {
      // Call the abstract method that subclasses implement
      const resultsByKey = await this.fetchBatch(identifiers);

      // Resolve each request with its specific result
      batch.forEach(({ identifier, resolve }) => {
        const key = this.getKeyForIdentifier(identifier);
        const result = resultsByKey.get(key);

        if (result !== undefined) {
          resolve(result);
        } else {
          // Identifier not found in results
          resolve(this.getDefaultResult(identifier));
        }
      });
    } catch (error) {
      console.error('Batch execution failed:', error);
      batch.forEach(({ reject }) => reject(error));
    }
  }

  /**
   * Fetch data for a batch of identifiers. This is where the actual API calls happen.
   *
   * @param identifiers - Array of identifiers to fetch data for
   * @returns Map of key to result, where key is generated by getKeyForIdentifier
   */
  protected abstract fetchBatch(identifiers: TIdentifier[]): Promise<Map<string, TResult>>;

  /**
   * Convert an identifier to a string key for mapping results.
   * This key is used to match requests with their results.
   *
   * @param identifier - The identifier to convert
   * @returns String key uniquely identifying this identifier
   */
  protected abstract getKeyForIdentifier(identifier: TIdentifier): string;

  /**
   * Get the default result when an identifier is not found in the batch results.
   * This is called when fetchBatch doesn't return a result for a given identifier.
   *
   * @param identifier - The identifier that wasn't found
   * @returns Default result to return
   */
  protected abstract getDefaultResult(identifier: TIdentifier): TResult;
}
