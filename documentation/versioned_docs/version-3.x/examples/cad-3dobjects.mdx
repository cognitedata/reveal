---
id: cad-3dobjects
title: Add custom 3D objects
description: Extend the scene with custom ThreeJS objects.
---

import { DemoWrapper } from '@site/docs/components/DemoWrapper';
import useBaseUrl from '@docusaurus/useBaseUrl';

Sometimes it's useful to add custom content to the 3D scene to model data Reveal doesn't
support or to customize the 3D environment. Reveal supports this by using the
`Cognite3DViewer.addObject3D`-function which accepts [ThreeJS](https://threejs.org/) objects.

:::note
There are a few restrictions to the 3D content that is to be combined with Reveal models:
- Reveal uses an "implicit lighting model", i.e. no lights are added to the scene. If you
need lights this needs to be added to the viewer scene.
- Geometry is expected to use "default depth testing", meaning
[`THREE.Material.depthTest`](https://threejs.org/docs/#api/en/materials/Material.depthTest) must be `true`,
[`THREE.Material.depthWrite`](https://threejs.org/docs/#api/en/materials/Material.depthWrite) must  `true` and
[`THREE.Material.depthFunc`](https://threejs.org/docs/#api/en/materials/Material.depthFunc) must be `LessEqualDepth`.
You might experience unexpected results if you are using materials where this doesn't hold.
- Objects with opacity less than 1.0 will appear transparent regardless of if
[`THREE.Material.transparent`](https://threejs.org/docs/?q=Material#api/en/materials/Material.transparent) is `true` or
`false`. The final composited image is always blended as if
[`THREE.Material.blendDst`](https://threejs.org/docs/?q=Material#api/en/materials/Material.blendDst) is
`OneMinusSrcAlphaFactor` and the blending settings on the material won't have any effect on the composition.
:::

<!-- :::tip
Reveal uses an "implicit lighting model", i.e. no lights are added to the scene. If you
need lights this needs to be added to the viewer scene.
::: -->

<DemoWrapper name="Cognite3DViewerDemo" />

## Adding markers to the scene on clicks

The following example reacts to clicks in the scene and adds markers to the positions clicked.

```jsx runnable
const markerGeometry = new THREE.SphereBufferGeometry(1, 10, 10);
const markerMaterial = new THREE.MeshBasicMaterial({
  color: 'blue',
  transparent: true,
  opacity: 0.7
});
viewer.on('click', async event => {
  const intersection = await viewer.getIntersectionFromPixel(event.offsetX, event.offsetY);
  if (intersection) {
    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
    marker.position.copy(intersection.point);
    viewer.addObject3D(marker);
  }
});
```

## Add environment

To make a model feel more natural it might be useful to add an environment. The following
example adds sky and a sea effect for the example oil rig.

<img
  src={useBaseUrl('/img/cad-skyandocean.png')}
  alt="Oil rig with sky and ocean"
/>

Below you'll find [an interactive example](#interactive-example), but first lets walk through
the different parts.
See the bottom of this page for an interactive example.

First, let's encapsulate the model in a large sky-textured sphere to create an illusion of
skies. The sphere map is available from [Free HDR - EXR SKIES-blog](http://freepanorama.blogspot.com/).

```js
const modelCenterAtSeaLevel = model
  .getModelBoundingBox()
  .getCenter(new THREE.Vector3());
modelCenterAtSeaLevel.y = 0.0;

// Skybox
const skyBox = new THREE.Mesh(
  new THREE.SphereBufferGeometry(3000, 15, 15),
  new THREE.MeshBasicMaterial({
    side: THREE.BackSide,
    // Skybox texture from http://freepanorama.blogspot.com/2010/01/sky7-spherical.html
    map: new THREE.TextureLoader().load(skyUrl),
  })
);
skyBox.position.copy(modelCenterAtSeaLevel);
viewer.addObject3D(skyBox);
```

This looks a bit better, but the oil rig appears to be floating mid-air at this point. Lets
add an ocean. A plane is rendered at the sea level and an ocean effect is applied to the plane.

Note that since the ocean has moving waves we want to render the model continuously and not only
when camera changes or data is loaded. We do this by repeatedly calling `Cognite3DViewer.requestRedraw()`.


### Water Shader
Shader using [Perlin Noise](https://en.wikipedia.org/wiki/Perlin_noise) to create waves for the ocean.

```js
const VertexShader = `precision highp float;

uniform float		u_amplitude;
uniform float 	u_frequency;
uniform float   u_time;

out vec2 vUV;

vec3 mod289(vec3 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 fade(vec3 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

// Classic Perlin noise
float cnoise(vec3 P)
{
  vec3 Pi0 = floor(P); // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 * (1.0 / 7.0);
  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 * (1.0 / 7.0);
  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return 2.2 * n_xyz;
}

void main() {

  float displacement = u_amplitude * cnoise( u_frequency * position + u_time );

  vec3 newPosition = position + normal * displacement;
  vUV = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );

}`;

const FragmentShader = `precision highp float;
uniform sampler2D map;
uniform vec3 color;
in vec2 vUV;

void main() {
  gl_FragColor = texture2D(map, vUV) * vec4(color, 0.5) ;
}`;
```

```js
// Water
const waterGeometry = new THREE.PlaneBufferGeometry(6000, 6000, 63, 63);
const clock = new THREE.Clock();
const waterUniforms = {
  u_amplitude: { value: 10 },
  u_frequency: { value: 0.25 },
  u_time: { value: 0.0 },
  map: { value: new THREE.TextureLoader().load(
          'https://threejs.org/examples/textures/water.jpg',
          (texture) => {
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    } )},
    color: { value: new THREE.Color(0x0099ff)}
};

var material = new THREE.ShaderMaterial({
  uniforms: waterUniforms,
  side: THREE.DoubleSide,
  vertexShader: WaterShader.Vertex,
  fragmentShader: WaterShader.Fragment
});

water = new THREE.Mesh(waterGeometry, material);
// Make the ocean horizontal
water.rotation.x = -Math.PI / 2;
water.position.copy(modelCenterAtSeaLevel);
viewer.addObject3D(water);

function updateOcean() {
  waterUniforms.u_time.value += clock.getDelta();
  viewer.requestRedraw();
  requestAnimationFrame(updateOcean);
}
updateOcean();
```

The user is available to move below sea level. Let's restrict the movement to avoid this.

```js
viewer.on('cameraChange', (position, target) => {
  // Keep camera above sea level
  if (position.y < 20) {
    position.y = 21;
    viewer.setCameraPosition(position);
  }
  // Clamp point within our skybox to avoid moving outside the defined 'world'
  if (!boundingSphere.containsPoint(position)) {
    boundingSphere.clampPoint(position, position);
    viewer.setCameraPosition(position);
  }
});
```

### Interactive example

Below is the complete code for adding a skybox and ocean to the scene.

```jsx runnable
const modelCenterAtSeaLevel = model
  .getModelBoundingBox()
  .getCenter(new THREE.Vector3());
modelCenterAtSeaLevel.y = 0.0;

// Skybox
const skyBox = new THREE.Mesh(
  new THREE.SphereBufferGeometry(3000, 15, 15),
  new THREE.MeshBasicMaterial({
    side: THREE.BackSide,
    // Skybox texture from http://freepanorama.blogspot.com/2010/01/sky7-spherical.html
    map: new THREE.TextureLoader().load(skyUrl),
  })
);
skyBox.position.copy(modelCenterAtSeaLevel);
viewer.addObject3D(skyBox);

// Water
const waterGeometry = new THREE.PlaneBufferGeometry(6000, 6000, 63, 63);
const clock = new THREE.Clock();
const waterUniforms = {
  u_amplitude: { value: 10 },
  u_frequency: { value: 0.25 },
  u_time: { value: 0.0 },
  map: { value: new THREE.TextureLoader().load(
          'https://threejs.org/examples/textures/water.jpg',
          (texture) => {
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    } )},
    color: { value: new THREE.Color(0x0099ff)}
};

var material = new THREE.ShaderMaterial({
  uniforms: waterUniforms,
  side: THREE.DoubleSide,
  vertexShader: WaterShader.Vertex,
  fragmentShader: WaterShader.Fragment
});

water = new THREE.Mesh(waterGeometry, material);
// Make the ocean horizontal
water.rotation.x = -Math.PI / 2;
water.position.copy(modelCenterAtSeaLevel);
viewer.addObject3D(water);

function updateOcean() {
  waterUniforms.u_time.value += clock.getDelta();
  viewer.requestRedraw();
  requestAnimationFrame(updateOcean);
}
updateOcean();

// Restrict camera movement
const boundingSphere = new THREE.Sphere(modelCenterAtSeaLevel, 2000);
viewer.on('cameraChange', (position, target) => {
  // Keep camera above sea level
  if (position.y < 20) {
    position.y = 21;
    viewer.setCameraPosition(position);
  }
  // Clamp point within our skybox to avoid moving outside the defined 'world'
  if (!boundingSphere.containsPoint(position)) {
    boundingSphere.clampPoint(position, position);
    viewer.setCameraPosition(position);
  }
});
```
