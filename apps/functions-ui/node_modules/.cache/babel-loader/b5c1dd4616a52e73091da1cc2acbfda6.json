{"ast":null,"code":"import queryString from 'query-string';\nexport const getQueryParameter = parameterKey => {\n  const parameters = queryString.parse(window.location.search) ?? {};\n  return parameters[parameterKey] ?? '';\n};\nexport const getProject = () => new URL(window.location.href).pathname.split('/')[1];\nexport const getCluster = () => {\n  const cluster = getQueryParameter('cluster');\n  return Array.isArray(cluster) ? cluster[0] : cluster;\n};\nexport const getEnv = () => {\n  const env = getQueryParameter('env');\n  return Array.isArray(env) ? env[0] : env;\n};\nexport const getUrl = (hostname, protocol = 'https') => {\n  let url = hostname;\n  if (hostname.substr(0, protocol.length) !== protocol) {\n    url = `${protocol}://${hostname}`;\n  }\n  return url;\n};\nexport const createLink = (path, queries = {}, opts) => {\n  // No more base project name\n  const project = getProject() || '';\n  const env = getEnv();\n  const cluster = getCluster();\n  const query = queryString.stringify({\n    ...queries,\n    ...(env ? {\n      env\n    } : {}),\n    ...(cluster ? {\n      cluster\n    } : {})\n  }, opts);\n  if (query.length > 0) {\n    return `/${project}${path}?${query}`;\n  }\n  if (path.length > 0 && path !== '/') {\n    return `/${project}${path}`;\n  }\n  return `/${project}`;\n};\n\n/**\n * We check what Fusion environment it is by extracting what we suppose to be env\n * directly from the URL. We can't just check if the string representing env\n * is in the hostname because some org named include \"dev\" or \"prod\" string.\n *\n * Examples:\n *\n * dev.fusion.cogniteapp.com - dev - will return true for \"dev\"\n * fusion.cognite.com - prod - will return true for \"prod\"\n * next-release.fusion.cognite.com - next-release - will return true for \"next-release\"\n * devex.dev.fusion.cogniteapp.com - dev - will return true for \"dev\"\n * devex.fusion.cognite.com - prod - will return true for \"prod\"\n * devex.next-release.fusion.cognite.com - next-release - will return true for \"next-release\"\n */\nexport const checkUrl = env => {\n  const {\n    hostname\n  } = window.location;\n  // Disabling this eslint rule because Regex actually DOES need that escape\n  // eslint-disable-next-line no-useless-escape\n  const regex = /([^\\.\\s]*?)(?=.fusion)/gi;\n  const hostnameEnvMatch = hostname.match(regex);\n  const hostnameEnv = hostnameEnvMatch?.[0];\n  if (env === 'prod') {\n    /**\n     * Production environment will return:\n     * - null - if there's no org name in URL\n     * - org name - if there is org name\n     * To detect if env is production, we just check if hostname env is null or some\n     * other string than other env names.\n     */\n    const nonProdEnvs = Object.keys(Envs).filter(e => e !== Envs.PROD);\n    return !hostnameEnv || !nonProdEnvs.includes(hostnameEnv);\n  }\n  return hostnameEnv === env;\n};\nexport let Envs;\n(function (Envs) {\n  Envs[\"PROD\"] = \"prod\";\n  Envs[\"DEV\"] = \"dev\";\n  Envs[\"LOCALHOST\"] = \"localhost\";\n  Envs[\"STAGING\"] = \"staging\";\n  Envs[\"NEXT_RELEASE\"] = \"next-release\";\n  Envs[\"PR\"] = \"pr\";\n})(Envs || (Envs = {}));\nexport const isDevelopment = () => checkUrl(Envs.DEV) || checkUrl(Envs.LOCALHOST);\nexport const isStaging = () => checkUrl(Envs.STAGING) || checkUrl(Envs.PR) || checkUrl(Envs.NEXT_RELEASE);\nexport const isProduction = () => !(isStaging() || isDevelopment());\nexport const getEnvironment = () => {\n  if (isDevelopment()) {\n    return 'development';\n  }\n  if (isStaging()) {\n    return 'staging';\n  }\n  return 'production';\n};\nexport const isValidEmail = email => {\n  // Just checking by length as it's super tricky and fragile to check by char here.\n  return /^.{1,64}@.{1,255}$/.test(email);\n};","map":{"version":3,"names":["queryString","getQueryParameter","parameterKey","parameters","parse","window","location","search","getProject","URL","href","pathname","split","getCluster","cluster","Array","isArray","getEnv","env","getUrl","hostname","protocol","url","substr","length","createLink","path","queries","opts","project","query","stringify","checkUrl","regex","hostnameEnvMatch","match","hostnameEnv","nonProdEnvs","Object","keys","Envs","filter","e","PROD","includes","isDevelopment","DEV","LOCALHOST","isStaging","STAGING","PR","NEXT_RELEASE","isProduction","getEnvironment","isValidEmail","email","test"],"sources":["/Volumes/csvol/fusion/libs/shared/plotting-components/src/TimeseriesChart/utils/utils.ts"],"sourcesContent":["import queryString from 'query-string';\n\nexport const getQueryParameter = (parameterKey: string) => {\n  const parameters = queryString.parse(window.location.search) ?? {};\n  return parameters[parameterKey] ?? '';\n};\n\nexport const getProject = () =>\n  new URL(window.location.href).pathname.split('/')[1];\n\nexport const getCluster = () => {\n  const cluster = getQueryParameter('cluster');\n  return Array.isArray(cluster) ? cluster[0] : cluster;\n};\n\nexport const getEnv = () => {\n  const env = getQueryParameter('env');\n  return Array.isArray(env) ? env[0] : env;\n};\n\nexport const getUrl = (\n  hostname: string,\n  protocol: 'https' | 'http' = 'https'\n) => {\n  let url = hostname;\n  if (hostname.substr(0, protocol.length) !== protocol) {\n    url = `${protocol}://${hostname}`;\n  }\n\n  return url;\n};\n\nexport const createLink = (\n  path: string,\n  queries: any = {},\n  opts?: queryString.StringifyOptions\n): string => {\n  // No more base project name\n  const project = getProject() || '';\n  const env = getEnv();\n  const cluster = getCluster();\n  const query = queryString.stringify(\n    { ...queries, ...(env ? { env } : {}), ...(cluster ? { cluster } : {}) },\n    opts\n  );\n  if (query.length > 0) {\n    return `/${project}${path}?${query}`;\n  }\n  if (path.length > 0 && path !== '/') {\n    return `/${project}${path}`;\n  }\n  return `/${project}`;\n};\n\n/**\n * We check what Fusion environment it is by extracting what we suppose to be env\n * directly from the URL. We can't just check if the string representing env\n * is in the hostname because some org named include \"dev\" or \"prod\" string.\n *\n * Examples:\n *\n * dev.fusion.cogniteapp.com - dev - will return true for \"dev\"\n * fusion.cognite.com - prod - will return true for \"prod\"\n * next-release.fusion.cognite.com - next-release - will return true for \"next-release\"\n * devex.dev.fusion.cogniteapp.com - dev - will return true for \"dev\"\n * devex.fusion.cognite.com - prod - will return true for \"prod\"\n * devex.next-release.fusion.cognite.com - next-release - will return true for \"next-release\"\n */\nexport const checkUrl = (env: Envs) => {\n  const { hostname } = window.location;\n  // Disabling this eslint rule because Regex actually DOES need that escape\n  // eslint-disable-next-line no-useless-escape\n  const regex = /([^\\.\\s]*?)(?=.fusion)/gi;\n  const hostnameEnvMatch = hostname.match(regex);\n  const hostnameEnv = hostnameEnvMatch?.[0];\n  if (env === 'prod') {\n    /**\n     * Production environment will return:\n     * - null - if there's no org name in URL\n     * - org name - if there is org name\n     * To detect if env is production, we just check if hostname env is null or some\n     * other string than other env names.\n     */\n    const nonProdEnvs = Object.keys(Envs).filter((e) => e !== Envs.PROD);\n    return !hostnameEnv || !nonProdEnvs.includes(hostnameEnv);\n  }\n  return hostnameEnv === env;\n};\n\nexport enum Envs {\n  PROD = 'prod',\n  DEV = 'dev',\n  LOCALHOST = 'localhost',\n  STAGING = 'staging',\n  NEXT_RELEASE = 'next-release',\n  PR = 'pr',\n}\n\nexport const isDevelopment = () =>\n  checkUrl(Envs.DEV) || checkUrl(Envs.LOCALHOST);\nexport const isStaging = () =>\n  checkUrl(Envs.STAGING) || checkUrl(Envs.PR) || checkUrl(Envs.NEXT_RELEASE);\nexport const isProduction = () => !(isStaging() || isDevelopment());\n\nexport const getEnvironment = () => {\n  if (isDevelopment()) {\n    return 'development';\n  }\n  if (isStaging()) {\n    return 'staging';\n  }\n  return 'production';\n};\n\nexport const isValidEmail = (email: string) => {\n  // Just checking by length as it's super tricky and fragile to check by char here.\n  return /^.{1,64}@.{1,255}$/.test(email);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}