---
id: camera-manager
title: Custom CameraManager
description: Shows how to implement custom CameraManager to enable new camera manipulation features.
---

import useBaseUrl from '@docusaurus/useBaseUrl';

By default `Cognite3DViewer` uses `DefaultCameraManager` class to manage user interaction with the camera.
In certain cases it could be useful to customize behaviour of the camera:

- Need to provide custom `THREE.PerspectiveCamera` object to `Cognite3DViewer`
- Need to extend camera controls to any specific case that is not covered by current implementation


## Overview

To create a custom camera manager class, `CameraManager` interface from `@cognite/reveal` must be implemented
and provided to `Cognite3DViewer` on construction using the `cameraManager`-option. Interface looks like this:

```js
export interface CameraManager {
  /**
   * Returns the camera used for rendering in {@link Cognite3DViewer}.
   * Note that the camera will not be modified directly by Reveal.
   * Implementations must trigger the `cameraChange`-event whenever the
   * camera changes.
   */
  getCamera(): THREE.PerspectiveCamera;
  /**
   * Set camera's state. Rotation and target can't be set at the same time. as they could conflict.
   *
   * @param state Camera state, all fields are optional.
   * @param state.position Camera position in world space.
   * @param state.target Camera target in world space.
   * @param state.rotation Camera local rotation in quaternion form.
   * @example
   * ```js
   * // store position, target
   * const { position, target } = cameraManager.getCameraState();
   * // restore position, target
   * cameraManager.setCameraState({ position, target });
   * ```
   */
  setCameraState(state: CameraState): void;

  /**
   * Get camera's state
   * @returns Camera state: position, target and rotation.
   */
  getCameraState(): Required<CameraState>;

  /**
   * Subscribes to changes of the camera event. This is used by Reveal to react on changes of the camera.
   * @param event Name of the event.
   * @param callback Callback to be called when the event is fired.
   */
  on(event: 'cameraChange', callback: CameraChangedEvent): void;
  /**
   * Unsubscribes from changes of the camera event.
   * @param event Name of the event.
   * @param callback Callback function to be unsubscribed.
   */
  off(event: 'cameraChange', callback: CameraChangedEvent): void;

  /**
   * Moves camera to a place where the content of a bounding box is visible to the camera.
   * @param box The bounding box in world space.
   * @param duration The duration of the animation moving the camera.
   * @param radiusFactor The ratio of the distance from camera to center of box and radius of the box.
   */
  fitCameraToBoundingBox(boundingBox: THREE.Box3, duration?: number, radiusFactor?: number): void;
  /**
   * Updates internal state of camera manager. Expected to update visual state of the camera
   * as well as it's near and far planes if needed. Called in `requestAnimationFrame`-loop.
   * Reveal performance affects frequency with which this method is called.
   * @param deltaTime Delta time since last update in seconds.
   * @param boundingBox Global bounding box of the model(s) and any custom objects added to the scene.
   */
  update(deltaTime: number, boundingBox: THREE.Box3): void;
  /**
   * @obvious
   */
  dispose(): void;
}

```

Main implementation specific functions are `setCameraState`, `fitCameraToBoundingBox` and `update`. 
Setting state shouldn't be possible when `rotation` and `target` are passed at the same time because they could conflict.
When implementing these functions you can use a helper class `CameraManagerHelper` that contains some useful methods.

## Example implementation

Here is an example implementation of a custom camera manager that utilizes standard ThreeJS `OrbitControls` for mouse movement:

```js
import * as THREE from 'three';
import range from 'lodash/range';

/**
 * Helper methods for implementing a camera manager.
 */
export class CameraManagerHelper {
  /**
   * Reusable buffers used by updateNearAndFarPlane function to avoid allocations.
   */
  private readonly _updateNearAndFarPlaneBuffers = {
    cameraPosition: new THREE.Vector3(),
    cameraDirection: new THREE.Vector3(),
    corners: new Array<THREE.Vector3>(
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    )
  };

  private readonly _calculateCameraFarBuffers = {
    nearPlaneCoplanarPoint: new THREE.Vector3(),
    nearPlane: new THREE.Plane()
  };

  calculateNewTargetFromRotation(
    camera: THREE.PerspectiveCamera,
    rotation: THREE.Quaternion,
    currentTarget: THREE.Vector3
  ): THREE.Vector3 {
    const distToTarget = currentTarget.clone().sub(camera.position);
    const tempCam = camera.clone();

    tempCam.setRotationFromQuaternion(rotation);
    tempCam.updateMatrix();

    const newTarget = tempCam
      .getWorldDirection(new THREE.Vector3())
      .normalize()
      .multiplyScalar(distToTarget.length())
      .add(tempCam.position);

    return newTarget;
  }

  updateCameraNearAndFar(camera: THREE.PerspectiveCamera, combinedBbox: THREE.Box3): void {
    const { cameraPosition, cameraDirection, corners } = this._updateNearAndFarPlaneBuffers;
    this.getBoundingBoxCorners(combinedBbox, corners);
    camera.getWorldPosition(cameraPosition);
    camera.getWorldDirection(cameraDirection);

    // 1. Compute nearest to fit the whole bbox (the case
    // where the camera is inside the box is ignored for now)
    let near = this.calculateCameraNear(camera, combinedBbox, cameraPosition);

    // 2. Compute the far distance to the distance from camera to furthest
    // corner of the boundingbox that is "in front" of the near plane
    const far = this.calculateCameraFar(near, cameraPosition, cameraDirection, corners);

    // 3. Handle when camera is inside the model by adjusting the near value
    if (combinedBbox.containsPoint(cameraPosition)) {
      near = Math.min(0.1, far / 1000.0);
    }

    camera.near = near;
    camera.far = far;
    camera.updateProjectionMatrix();
  }

  calculateCameraStateToFitBoundingBox(
    camera: THREE.PerspectiveCamera,
    box: THREE.Box3,
    radiusFactor: number = 2
  ): { position: THREE.Vector3; target: THREE.Vector3 } {
    const boundingSphere = box.getBoundingSphere(new THREE.Sphere());

    const target = boundingSphere.center;
    const distance = boundingSphere.radius * radiusFactor;
    const direction = new THREE.Vector3(0, 0, -1);
    direction.applyQuaternion(camera.quaternion);

    const position = direction.clone().multiplyScalar(-distance).add(target);

    return { position, target };
  }

  private calculateCameraFar(
    near: number,
    cameraPosition: THREE.Vector3,
    cameraDirection: THREE.Vector3,
    corners: Array<THREE.Vector3>
  ): number {
    const { nearPlane, nearPlaneCoplanarPoint } = this._calculateCameraFarBuffers;

    nearPlaneCoplanarPoint.copy(cameraPosition).addScaledVector(cameraDirection, near);
    nearPlane.setFromNormalAndCoplanarPoint(cameraDirection, nearPlaneCoplanarPoint);
    let far = -Infinity;
    for (let i = 0; i < corners.length; ++i) {
      if (nearPlane.distanceToPoint(corners[i]) >= 0) {
        const dist = corners[i].distanceTo(cameraPosition);
        far = Math.max(far, dist);
      }
    }
    far = Math.max(near * 2, far);

    return far;
  }

  private calculateCameraNear(
    camera: THREE.PerspectiveCamera,
    combinedBbox: THREE.Box3,
    cameraPosition: THREE.Vector3
  ): number {
    let near = combinedBbox.distanceToPoint(cameraPosition);
    near /= Math.sqrt(1 + Math.tan(((camera.fov / 180) * Math.PI) / 2) ** 2 * (camera.aspect ** 2 + 1));
    near = Math.max(0.1, near);

    return near;
  }

  private getBoundingBoxCorners(bbox: THREE.Box3, outBuffer?: THREE.Vector3[]): THREE.Vector3[] {
    outBuffer = outBuffer || range(0, 8).map(_ => new THREE.Vector3());
    if (outBuffer.length !== 8) {
      throw new Error(`outBuffer must hold exactly 8 elements, but holds ${outBuffer.length} elemnents`);
    }

    const min = bbox.min;
    const max = bbox.max;
    outBuffer[0].set(min.x, min.y, min.z);
    outBuffer[1].set(max.x, min.y, min.z);
    outBuffer[2].set(min.x, max.y, min.z);
    outBuffer[3].set(min.x, min.y, max.z);
    outBuffer[4].set(max.x, max.y, min.z);
    outBuffer[5].set(max.x, max.y, max.z);
    outBuffer[6].set(max.x, min.y, max.z);
    outBuffer[7].set(min.x, max.y, max.z);
    return outBuffer;
  }
}
```

